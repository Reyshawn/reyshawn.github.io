<!DOCTYPE html>
<html lang="en">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
        <link rel="icon" type="image/png" href="./favicon.png">
        <link rel="apple-touch-icon" href="./favicon180x180.png" sizes="180x180">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Josefin+Sans:400,400i,600,600i" rel="stylesheet">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/main.css">
    <title>reyshawn.C</title>
</head>

<body class='home blog'>
    <header id="hagoromo-header" class="hagoromo-header">
    <div class="container">
        <div class="slot-l">
            <div class="hagoromo-site-branding">
                <h1 class="site-title h4">
                    <a href="/"><img class="typology-logo" src="/images/logo.png" alt="hagoromo" style="width: 125px;"></a>
                </h1>
            </div>
        </div>
        <div class="slot-r">
            <ul class="hagoromo-nav hagoromo-actions-list">
                <li class="hagoromo-action-button hagoromo-action-sidebar">
                    <span><i class="fa fa-bars"></i></span>
                </li>
            </ul>
        </div>
    </div>
</header>
<div id="hagoromo-cover" class="hagoromo-cover hagoromo-cover-empty"></div>

    <div class="hagoromo-fake-bg">
        <div class="hagoromo-section">
    <div class="section-head"><h1 class="section-title h6">Tag · JavaScript</h1></div>
    <div class="section-content">
        <div class="hagoromo-posts">
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/08/29/多个项目共享-Webpack/">多个项目共享 Webpack</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 08 月 29 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>最近在看 <a href>@keyframer</a> 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。</p>
<p>因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  <code>package.json</code> 里预先定义好 </p>
<pre><code class="json">&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server&quot;,
    &quot;build&quot;: &quot;webpack&quot;
}</code></pre>
<p>然后 <code>npm run dev</code>。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/08/29/多个项目共享-Webpack/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/07/06/Lazy-Evaluation/">Lazy Evaluation, foldr | 5kyu</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 07 月 06 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：</p>
<pre><code class="javascript">// Evaluates with call-by-name strategy
1 function callByName (a, b) {
2  if (a === 1) {
3    return 10
4  }
5  return a + b
6 }
// Evaluates with call-by-value strategy
1 function callByValue (a, b) {
2  if (a === 1) {
3    return 10
4  }
5  return a + b
6 }</code></pre>
<p>两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；</p>
<pre><code class="shell">&gt; callByName (1, 2 + 3)
&gt; a === 1
&gt; return 10

&gt; callByValue(1, 2 + 3)
&gt; callByValue(1, 5)
&gt; a === 1
&gt; return 10</code></pre>
<p>使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。</p>
<p>实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/07/06/Lazy-Evaluation/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/06/29/JavaScript-Semicolon 二三事/">JavaScript: Semicolon 二三事</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 06 月 29 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>由于 JavaScript 拥有 <em>Automatic Semicolon Insertion</em> 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：</p>
<pre><code class="javascript">let i = 0

(function test () {
  console.log(&#39;hello&#39;)
})()</code></pre>
<p>这里会提示报错：</p>
<pre><code>TypeError: 0 is not a function</code></pre><p>观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。</p>
<pre><code class="javascript">let i = 0;

(function test () {
  console.log(&#39;hello&#39;)
})()</code></pre>
<p>关于 JavaScript 的 <em>Automatic Semicolon Insertion</em>，规则是这样的：</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/06/29/JavaScript-Semicolon 二三事/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/06/12/JSON-Web-Token-的产生和认证/">JSON Web Token 的产生和认证</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 06 月 12 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <h2 id="Cookie-based-vs-Token-based"><a href="#Cookie-based-vs-Token-based" class="headerlink" title="Cookie-based vs Token-based"></a>Cookie-based vs Token-based</h2><p>有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：</p>
<p>cookie-based authentication 的认证流程是:</p>
<ol>
<li>用户填写 credentials，包括用户名，邮箱，密码这些内容；</li>
<li>Server 服务器验证这些 credentials 是否正确，如果正确，则<strong>认证成功</strong>，创建一个 session 存储在数据库中；</li>
<li>将这个 session 的 session id 存储在浏览器端的 cookie 里；</li>
<li>接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；</li>
<li>一旦用户登出，client 端和 server 端的 session 均被摧毁；</li>
</ol>
<p>token-based authentication:</p>
<ol>
<li>用户填写 credentials，包括用户名，邮箱，密码；</li>
<li>Server 服务器验证这些 credentials 是否正确，如果<strong>认证成功</strong>，则返回一个 signed token；</li>
<li>这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；</li>
<li>接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。</li>
<li>Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；</li>
</ol>
<p><img src="/images/auto01.png" alt="auto01"></p>
<p>为什么会说 token-based 更好：</p>
<ol>
<li>stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；</li>
<li>cookie 对跨域 CORS 操作不友好，token 则没有这个问题；</li>
</ol>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/06/12/JSON-Web-Token-的产生和认证/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/05/18/JavaScript-async-and-Promise/">JavaScript async and Promise</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 05 月 18 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p>
<h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p>
<pre><code class="javascript">$.get(&#39;http://twitter.com&#39;)
$.get(&#39;http://youtube.com&#39;)
$.get(&#39;http://google.com&#39;)</code></pre>
<p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p>
<pre><code class="Javascript">console.log(&#39;hi&#39;)
setTimeout(() =&gt; console.log(&#39;there&#39;), 0)
console.log(&#39;Welcome!&#39;)

// output:
// hi
// Welcome
// there</code></pre>
<p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p>
<p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/05/18/JavaScript-async-and-Promise/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/01/31/「User Authentication with Passport and Koa 」Summary/">「User Authentication with Passport and Koa 」Summary</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 01 月 31 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href="https://mherman.org/blog/user-authentication-with-passport-and-koa/" target="_blank" rel="noopener">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p>
<p>需要通过 brew 安装：</p>
<ul>
<li>postgresql</li>
<li>redis</li>
</ul>
<p>使用 npm 全局安装：</p>
<ul>
<li>knex</li>
</ul>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/01/31/「User Authentication with Passport and Koa 」Summary/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/01/26/初见 Koa/">初见 Koa.js</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 01 月 26 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p>
<ul>
<li>Node.js 的异步特性及异步是如何实现的</li>
<li>异步实现的几种方式，callback 到 Promise 到 async/await</li>
<li>什么是 middleware？</li>
<li>ejs template engine</li>
</ul>
<p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/01/26/初见 Koa/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/01/25/异步 & callback/">异步 &amp; callback</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 01 月 25 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href="https://search.packtpub.com/" target="_blank" rel="noopener">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p>
<p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/01/25/异步 & callback/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2019/01/20/Hexo Theme 开发不完全记录/">Hexo Theme 开发不完全记录</a>
                    </h2>
                    <div class="entry-meta">
                        2019 年 01 月 20 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <p>决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 <a href="https://github.com/getpelican/pelican" target="_blank" rel="noopener">Pelican</a> 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：</p>
<blockquote>
<p>两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。</p>
</blockquote>
<p>那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。</p>
<p>目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">Themes | Hexo</a> 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2019/01/20/Hexo Theme 开发不完全记录/">Read More</a>
                </div>
            </article>
            
            <article class="hagoromo-post">
                <header class="entry-header">
                    <h2 class="entry-title h1">
                        <a href="/2018/06/29/Lowest base system | 4kyu/">Lowest base system | 4kyu</a>
                    </h2>
                    <div class="entry-meta">
                        2018 年 06 月 29 日
                    </div>
                    <div class="post-letter"></div>
                </header>
                <div class="entry-content">
                    <h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>除法，求余，因子</li>
<li><code>Number.MAX_SAFE_INTEGER</code></li>
<li>二分法求方程根</li>
</ul>
<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Your task is determine lowest number base system in which the input <code>n</code> (base 10), expressed in this number base system, is all <code>1</code> in its digit. See an example:</p>
<p>‘7’ in base 2 is ‘111’ - fits! answer is 2</p>
<p>‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4</p>
<p><code>n</code> is always less than <code>Number.MAX_SAFE_INTEGER</code>.</p>
<p>这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。</p>
                </div>
                <div class="entry-footer">
                    <a class="hagoromo-button" href="/2018/06/29/Lowest base system | 4kyu/">Read More</a>
                </div>
            </article>
            
        </div>
        
<div class="hagoromo-pagination">
    <nav class="navigation pagination" role="navigation">
        
        
        <span class="page-number current">1</span><a class="page-number" href="/tags/JavaScript/page/2/">2</a><a class="extend next" rel="next" href="/tags/JavaScript/page/2/">next &raquo;</a>
    </nav>
</div>


    </div>
</div>
        <footer id="hagoromo-footer" class="hagoromo-footer">
    <div class="container">
        <div class="hagoromo-footer-widget"></div>
        <div class="hagoromo-footer-widget">
            <img class="typology-logo" src="/images/footer.png" alt="hagoromo" style="width: 125px;">
            <p>Inspired by <a href="https://demo.mekshq.com/typology/">typology</a> · Powered by <a href="https://hexo.io">Hexo</a> <br> All rights reserved</p>
        </div>
        <div class="hagoromo-footer-widget social">
            
                
                    <span class="social-button">
                        <a href="https://github.com/Reyshawn" rel="alternate"><i class="fa fa-github"></i></a>
                    </span>
                
                    <span class="social-button">
                        <a href="https://twitter.com/ReshawnChang" rel="alternate"><i class="fa fa-twitter"></i></a>
                    </span>
                
                    <span class="social-button">
                        <a href="http://weibo.com/u/1724849591" rel="alternate"><i class="fa fa-weibo"></i></a>
                    </span>
                
                    <span class="social-button">
                        <a href="https://www.douban.com/people/53350454/" rel="alternate"><i class="fa fa-film"></i></a>
                    </span>
                
                    <span class="social-button">
                        <a href="https://www.zhihu.com/people/zhang-yun-xiao-61/activities" rel="alternate"><i class="fa fa-globe"></i></a>
                    </span>
                
            
            <span class="social-button">
                <a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i></a>
            </span>
        </div> 
    </div>
</footer>
    </div>

    <div class="hagoromo-sidebar">
    <div class="hagoromo-sidebar-header">
        <div class="hagoromo-sidebar-header-wrapper">
            <div class="hagoromo-site-branding">
                <h1 class="site-title h4">
                    <a href="/"><img class="typology-logo" src="/images/logo.png" alt="hagoromo" style="width: 125px;"></a>
                </h1>
            </div>
            <span class="hagoromo-sidebar-close">
                <i class="fa fa-times" aria-hidden="true"></i>
            </span>
        </div>
    </div>
    <div class="widget search">
        <form id="hagoromo-search-form" class="hagoromo-search-form">
            <input name="s" type="text" placeholder="Type here to search ... ">
            <button type="submit" class="hagoromo-button hagoromo-button-search">SEARCH</button>
        </form>
    </div>
    <div class="widget categories">
        <h4 class="widget-title h5">分类</h4>
        <ul>
            <li><a href="/archives">Archive</a></li>
              
            <li><a href="/categories/Coding/">Coding</a></li>
              
            <li><a href="/categories/I-O/">I/O</a></li>
            
        </ul>
    </div>
    <div class="widget tags">
        <h4 class="widget-title h5">标签</h4>
        <ul>
              
                <li><a href="/tags/Algorithm/">Algorithm<a></a></a></li>
              
                <li><a href="/tags/codewars/">codewars<a></a></a></li>
              
                <li><a href="/tags/Python/">Python<a></a></a></li>
              
                <li><a href="/tags/JavaScript/">JavaScript<a></a></a></li>
              
                <li><a href="/tags/Front-end/">Front-end<a></a></a></li>
              
                <li><a href="/tags/游戏/">游戏<a></a></a></li>
              
                <li><a href="/tags/故事/">故事<a></a></a></li>
              
                <li><a href="/tags/电影/">电影<a></a></a></li>
              
                <li><a href="/tags/Anime/">Anime<a></a></a></li>
              
                <li><a href="/tags/Node-js/">Node.js<a></a></a></li>
              
                <li><a href="/tags/音乐/">音乐<a></a></a></li>
            
        </ul>
    </div>
</div>

<div class="hagoromo-sidebar-overlay"></div>

    <script src="/js/jquery-3.3.1.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script src="/js/highlightjs-line-numbers.js"></script>
    <script src="/js/main.js"></script>
</body>
</html>