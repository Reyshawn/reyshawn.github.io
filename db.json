{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Hagoromo/source/images/footer.png","path":"images/footer.png","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/js/highlightjs-line-numbers.js","path":"js/highlightjs-line-numbers.js","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/js/jquery-3.3.1.min.js","path":"js/jquery-3.3.1.min.js","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/js/highlight.min.js","path":"js/highlight.min.js","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/Hagoromo/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/favicon.png","path":"favicon.png","modified":0,"renderable":0},{"_id":"source/favicon180x180.png","path":"favicon180x180.png","modified":0,"renderable":0},{"_id":"source/images/IMG_1578.JPG","path":"images/IMG_1578.JPG","modified":0,"renderable":0},{"_id":"source/images/Mocha_test.png","path":"images/Mocha_test.png","modified":0,"renderable":0},{"_id":"source/images/Reward.png","path":"images/Reward.png","modified":0,"renderable":0},{"_id":"source/images/auth02.png","path":"images/auth02.png","modified":0,"renderable":0},{"_id":"source/images/auto01.png","path":"images/auto01.png","modified":0,"renderable":0},{"_id":"source/images/Promise.png","path":"images/Promise.png","modified":0,"renderable":0},{"_id":"source/images/eva-1.png","path":"images/eva-1.png","modified":0,"renderable":0},{"_id":"source/images/eva-3.png","path":"images/eva-3.png","modified":0,"renderable":0},{"_id":"source/images/eva-2.png","path":"images/eva-2.png","modified":0,"renderable":0},{"_id":"source/images/eventLoop.png","path":"images/eventLoop.png","modified":0,"renderable":0},{"_id":"source/images/eva-4.png","path":"images/eva-4.png","modified":0,"renderable":0},{"_id":"source/images/exp.png","path":"images/exp.png","modified":0,"renderable":0},{"_id":"source/images/iOS13 tab 1.png","path":"images/iOS13 tab 1.png","modified":0,"renderable":0},{"_id":"source/images/iOS13 tab 2.png","path":"images/iOS13 tab 2.png","modified":0,"renderable":0},{"_id":"source/images/iOS13 tab 3.png","path":"images/iOS13 tab 3.png","modified":0,"renderable":0},{"_id":"source/images/iPad files bug.png","path":"images/iPad files bug.png","modified":0,"renderable":0},{"_id":"source/images/intro.jpg","path":"images/intro.jpg","modified":0,"renderable":0},{"_id":"source/images/knex.png","path":"images/knex.png","modified":0,"renderable":0},{"_id":"source/images/koa_routing.png","path":"images/koa_routing.png","modified":0,"renderable":0},{"_id":"source/images/long division.png","path":"images/long division.png","modified":0,"renderable":0},{"_id":"source/images/metroid.png","path":"images/metroid.png","modified":0,"renderable":0},{"_id":"source/images/movies_2020.PNG","path":"images/movies_2020.PNG","modified":0,"renderable":0},{"_id":"source/images/p5r-ending.png","path":"images/p5r-ending.png","modified":0,"renderable":0},{"_id":"source/images/repl.png","path":"images/repl.png","modified":0,"renderable":0},{"_id":"source/images/shin-megami-tensei-v.png","path":"images/shin-megami-tensei-v.png","modified":0,"renderable":0},{"_id":"source/images/switch_2020.png","path":"images/switch_2020.png","modified":0,"renderable":0},{"_id":"source/images/value1.png","path":"images/value1.png","modified":0,"renderable":0},{"_id":"source/images/value2.png","path":"images/value2.png","modified":0,"renderable":0},{"_id":"source/images/zelda-botw.jpg","path":"images/zelda-botw.jpg","modified":0,"renderable":0},{"_id":"source/images/舞！舞！舞！.png","path":"images/舞！舞！舞！.png","modified":0,"renderable":0},{"_id":"source/images/Game/Go-Trilogy.png","path":"images/Game/Go-Trilogy.png","modified":0,"renderable":0},{"_id":"source/images/Game/Lara Go .jpg","path":"images/Game/Lara Go .jpg","modified":0,"renderable":0},{"_id":"source/images/Game/Lara Go 1.jpg","path":"images/Game/Lara Go 1.jpg","modified":0,"renderable":0},{"_id":"source/images/Game/Lara Go 2.jpg","path":"images/Game/Lara Go 2.jpg","modified":0,"renderable":0},{"_id":"source/images/Game/Lara Go 3.jpg","path":"images/Game/Lara Go 3.jpg","modified":0,"renderable":0},{"_id":"source/images/Game/devotion.png","path":"images/Game/devotion.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/Hagoromo/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1547886254000},{"_id":"themes/Hagoromo/.DS_Store","hash":"b5b78bc2742174509add6bc36011327584fd19b2","modified":1562925479000},{"_id":"themes/Hagoromo/_config.yml","hash":"40d7d5edb644cafac1dd5e9fe6a346a9253d6e21","modified":1548147347000},{"_id":"themes/Hagoromo/layout/.DS_Store","hash":"05ec2b80b3e40ae6ab56a70d6f24cc66458881e9","modified":1562404656000},{"_id":"themes/Hagoromo/layout/index.ejs","hash":"c5ace92cc5d3c3e2d7732f221eebc34fab2d0e72","modified":1547804168000},{"_id":"themes/Hagoromo/layout/archive.ejs","hash":"a30104d0cd8c7e1da908cecb6a0932629a9b676f","modified":1547890312000},{"_id":"themes/Hagoromo/layout/category.ejs","hash":"42693ff37aa7cec880255c4d084aa4f63528725c","modified":1562401991000},{"_id":"themes/Hagoromo/layout/layout.ejs","hash":"5c73afb47089ef9b3917753e55c5193d74a2ad1d","modified":1547860350000},{"_id":"themes/Hagoromo/layout/post.ejs","hash":"984e7093fdea397ccfa1ceb90d9a458a81bda556","modified":1562401903000},{"_id":"themes/Hagoromo/layout/tag.ejs","hash":"3570e8850a7d79ff216ffb85254b13e98905b841","modified":1562401990000},{"_id":"themes/Hagoromo/source/.DS_Store","hash":"58c0b7226e793f8daa8927c534a6b5a7d937e87a","modified":1562925527000},{"_id":"themes/Hagoromo/layout/_partials/head.ejs","hash":"8f2e21ea6304a0743ad1fc66d22d15fa3e05a8fa","modified":1548149551000},{"_id":"themes/Hagoromo/layout/_partials/footer.ejs","hash":"b310d823f9dbfb005d235600e5b234e2e0430ebc","modified":1547787990000},{"_id":"themes/Hagoromo/layout/_partials/header.ejs","hash":"7e96acbca36b35f4b274286a77c2e297ee0cb453","modified":1547733323000},{"_id":"themes/Hagoromo/source/images/.DS_Store","hash":"baa9e8dd2eff9117d2157809a88a81a44d3b6161","modified":1562404656000},{"_id":"themes/Hagoromo/layout/_partials/sidebar.ejs","hash":"fef138dfbfa05dbf7400fddfbb401d4c0afc84b9","modified":1547886092000},{"_id":"themes/Hagoromo/source/images/logo.png","hash":"ced8adad841411d31c1ec54306fe3a2942bab292","modified":1547733483000},{"_id":"themes/Hagoromo/source/js/.DS_Store","hash":"d7fbb074684603bed861212f68151ccffdc7adba","modified":1562404656000},{"_id":"themes/Hagoromo/source/images/footer.png","hash":"84887971754777c38043e04921f530ed60c2754f","modified":1547778093000},{"_id":"themes/Hagoromo/source/js/highlightjs-line-numbers.js","hash":"eb08de1981d754e58b5a686e1f9a523def180872","modified":1547860213000},{"_id":"themes/Hagoromo/layout/_partials/pagination.ejs","hash":"f2cb5901350d54b96de87d11506d230a097e87a3","modified":1641004809623},{"_id":"themes/Hagoromo/source/css/.DS_Store","hash":"4efe2fa299fa73280c314bd39229e4bfa11efa47","modified":1562404656000},{"_id":"themes/Hagoromo/source/js/main.js","hash":"013069d1fb4adcf881e51a4328898c825f456591","modified":1547882962000},{"_id":"themes/Hagoromo/source/js/highlight.min.js","hash":"fbaec451eb5541f7d0e8c6910af13977043d478a","modified":1547817219000},{"_id":"themes/Hagoromo/source/css/highlight.css","hash":"019aad2812e8bc119513d43890ac2cefa70d73a6","modified":1547818250000},{"_id":"themes/Hagoromo/source/css/main.css","hash":"53b3b2a47c842819971145de691d9d69efe62a25","modified":1562925764000},{"_id":"themes/Hagoromo/source/js/jquery-3.3.1.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1547601521000},{"_id":"source/CNAME","hash":"51be50ef18c59721f889cb63e1e8db80108c2cf8","modified":1509719728000},{"_id":"source/.DS_Store","hash":"102756855044b96873be8e80431e22ae8325e0cf","modified":1735655379043},{"_id":"source/favicon180x180.png","hash":"6d3090987005a21f38bea3521a7622d7159349e7","modified":1548149510000},{"_id":"source/_posts/2023-summary.md","hash":"d41e0d1eb1ced98baaab18673cdb092493ad138b","modified":1707484535250},{"_id":"source/_posts/2024-summary.md","hash":"908fa971f7170435f78ac3ad2358bbf0bfc705bd","modified":1735664386753},{"_id":"source/_posts/.DS_Store","hash":"4352d57d4dcd6387281032a70c2e773bd4961d9f","modified":1735665369320},{"_id":"source/_posts/1n- Cycle | 6kyu.md","hash":"b0c7e3ccae919daf4dfbb4ff5f86e1077c63688d","modified":1548207068000},{"_id":"source/_posts/@wraps | 6kyu.md","hash":"f4cb0db9566690aac477bb9b2b4d34ce1b30bc71","modified":1548170093000},{"_id":"source/_posts/Codewars.com | ES5 Generators(i).md","hash":"78f1a11ec043c914bc54729d3968ee812dbe4a15","modified":1547821830000},{"_id":"source/_posts/Codewars.com | Wrapped Function.md","hash":"0e5de14cd82ac88ecb3649017a24238177a7fa12","modified":1547821927000},{"_id":"source/_posts/Argument Mapper | 5kyu.md","hash":"33c54c463f6d9a9f898f3b83890c838459fec526","modified":1548170124000},{"_id":"source/_posts/Born to be chained | 4kyu.md","hash":"9f5f20e38be79c19092e6fd26be878ab0152f96d","modified":1548170153000},{"_id":"source/_posts/Binary Search Trees | 5kyu.md","hash":"acb8956ea6009990a95ea2328d9b5cd65111db52","modified":1548170134000},{"_id":"source/_posts/Default Arguments | 4kyu.md","hash":"1b755cff2d1ff4f574cb6fa1ba72d311e0b64514","modified":1548170074000},{"_id":"source/_posts/Codewars.com-|-Catching-Car-Mileage-Numbers.md","hash":"dbfe85d616e024043c21c23c61d299615c09504d","modified":1547822673000},{"_id":"source/_posts/Hexo Theme 开发不完全记录.md","hash":"2f3493f4e16ba6f7d3c18eaf7bbb4d8f228e3f02","modified":1548167333000},{"_id":"source/_posts/Hexo部署到新电脑.md","hash":"dffa3e89d407b6aa0112e7f78a4f9cf86cbbcdc5","modified":1547822622000},{"_id":"source/_posts/I-O-18-名为丢失的记忆.md","hash":"daacc290c9690dc430a9f0e5a98ef4a6f768adba","modified":1547976917000},{"_id":"source/_posts/I-O-20-「有目标，能坚持！」.md","hash":"77863181dd987f5d1939cd331d4600dd670b7c34","modified":1547976960000},{"_id":"source/_posts/I-O-19-Samorost-的银河历险记.md","hash":"29f28dbda6fb949f06c709c07cf0f0937f941e90","modified":1547976947000},{"_id":"source/_posts/Fly-Me-to-the-Moon.md","hash":"5176e63d3b079f1f2625c5e24a8178d76ed3a23d","modified":1641003083405},{"_id":"source/_posts/I-O-21-Habitica 的量化人生.md","hash":"f1f91d5d6a2109223a098def8fb134dcefb94491","modified":1548208095000},{"_id":"source/_posts/I-O-22-端午.md","hash":"a47a62c36c870cd5bb623bf3ef5a4dd36753ae86","modified":1547976764000},{"_id":"source/_posts/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」.md","hash":"3df1448493867c005107a173f10b6711df3e674f","modified":1547977371000},{"_id":"source/_posts/JSON-Web-Token-的产生和认证.md","hash":"f417c54edfe7f7d00a90e58ce94eae68f70bf3bf","modified":1560328134000},{"_id":"source/_posts/JavaScript-async-and-Promise.md","hash":"df56c132ebf4dc9e0d3ec558530258986a92f46e","modified":1558187259000},{"_id":"source/_posts/「User Authentication with Passport and Koa 」Summary.md","hash":"f85638ca45b73aba7f4bfdfe8b06e5f7e2cd527c","modified":1549116936000},{"_id":"source/_posts/JavaScript-Semicolon 二三事.md","hash":"46450849add1260c3d518ffac51a6621a17878d8","modified":1561827740000},{"_id":"source/_posts/Lazy-Evaluation.md","hash":"5cd6481e8298059a09d62c0839517285d6364712","modified":1562391746000},{"_id":"source/_posts/Lowest base system | 4kyu.md","hash":"e220d8ac218700bb91341df29782cd0997337eb7","modified":1548170173000},{"_id":"source/_posts/iPadOS-使用体验.md","hash":"0b98bd85a1ca2a813c2d54dd7b12acaefe0550b6","modified":1559707745000},{"_id":"source/_posts/「可我会永远喜欢你的，这和时间没关系，我想」.md","hash":"a6c52752951d47a2bf57f8146cdc7210fdc18ac0","modified":1609388416000},{"_id":"source/_posts/初见 Koa.md","hash":"ddea4064283fd48a91a9a1b37f9edecfec3be27a","modified":1548503310000},{"_id":"source/_posts/十年回顾.md","hash":"cff4cc093e6298609136b5858063dc76ab36c1ef","modified":1609381642000},{"_id":"source/_posts/多个项目共享-Webpack.md","hash":"09bbe46967cd41737d85e4c5b00cb24184ac97b8","modified":1567086531000},{"_id":"source/_posts/异步 & callback.md","hash":"4d796daacc20356c8278ff368f83c287d0876e54","modified":1548406338000},{"_id":"source/_posts/棋盘上的「古墓丽影」.md","hash":"ea4c16d550e46ff0a6bc94fed92fc4d2076d8eb6","modified":1549546769000},{"_id":"source/_posts/象棋 (XiangqiChinese Chess) Board Validator | 4kyu.md","hash":"fb3ab15a82cd819036e62c79f4a491b8507c01f1","modified":1548170332000},{"_id":"source/_posts/赤烛 - 『还愿』.md","hash":"6016596cfc50fdbd8bd27ca7d41972cfe8cc1025","modified":1550891894000},{"_id":"source/_posts/阅读摘要-issue-2.md","hash":"37538f366246224dd60c5523240536337ac5fcb9","modified":1562924231000},{"_id":"source/_posts/阅读摘要-issues-1.md","hash":"5a89591496541b3e63b27df6e8ea8be547e48a8b","modified":1560344243000},{"_id":"source/categories/index.md","hash":"ab323749a84911d5274ccba3e3f6e1c53b3692dc","modified":1509719728000},{"_id":"source/images/.DS_Store","hash":"ce092f9457cbd16630d3c98c364453656f806e39","modified":1641003053081},{"_id":"source/_posts/热病.md","hash":"df0eff16c592bac93795b72fdc312ec52d8434dd","modified":1672499404089},{"_id":"source/_posts/阅读摘要-issue-3.md","hash":"392dc7918716c2d1a6143c613ac36bb481fce5a3","modified":1562925215000},{"_id":"source/images/Reward.png","hash":"a980a79cd0ccd89b39208669682a2c47d7c2aeba","modified":1509719728000},{"_id":"source/images/exp.png","hash":"32c2b5b7467f3a03dbdd8733b2565551ef61c471","modified":1509719728000},{"_id":"source/images/iOS13 tab 3.png","hash":"6b75b314c28ecfc45d2b832259987ba6a920bac9","modified":1559704799000},{"_id":"source/images/intro.jpg","hash":"a0a366851bda70575031ee76cfae55f93244bdac","modified":1509719728000},{"_id":"source/images/value1.png","hash":"bfd1e8b2d2dbe6694501341fa35198df13b8b7f6","modified":1509719728000},{"_id":"source/images/value2.png","hash":"3efcd3cbf3be76a7ed3ec2f4d500472946bf344d","modified":1509719728000},{"_id":"source/tags/index.md","hash":"ea8bd2a980807dd662c29797b814db7a0c7648a9","modified":1509719728000},{"_id":"source/images/Game/.DS_Store","hash":"78e82cce464dd58426d0dd90e57d8dc255df4633","modified":1562404656000},{"_id":"source/favicon.png","hash":"f2f39eb11c01ef692750ec368caaca57920db238","modified":1548140917000},{"_id":"source/favicon.ico","hash":"a6e0f72689bd896eb0e1f1d30c08b8adce8ece87","modified":1548140620000},{"_id":"source/_posts/热病/.DS_Store","hash":"1ae7dfc1485583d865719d996b5fa67b3db0154a","modified":1672498516122},{"_id":"source/images/iOS13 tab 2.png","hash":"703b5536e2174ed7a78eebe965f33dda5675c25b","modified":1559704761000},{"_id":"source/images/Game/Lara Go 2.jpg","hash":"1ea205bfae83e482404d40e76f7c31b83e2a0699","modified":1549544301000},{"_id":"source/_posts/2023-summary/first-game.jpg","hash":"9b869313948a63e7be84d6c7e0c79fdf6b89bd32","modified":1704037353374},{"_id":"source/images/Game/Lara Go .jpg","hash":"c17900027e77df34a81a13f5ab3948e4373cbeaa","modified":1549544045000},{"_id":"source/images/zelda-botw.jpg","hash":"851f70bcf16d6dcb04373398ea94c6cc8f4bffad","modified":1641002935478},{"_id":"source/images/Game/Lara Go 1.jpg","hash":"5dba652d113f7f0fa7b48254606c9bde9ca899e0","modified":1549543902000},{"_id":"source/images/Game/Lara Go 3.jpg","hash":"2567302a73dec4d5c3b03ff2600c4681a5cd3633","modified":1549544358000},{"_id":"source/images/Mocha_test.png","hash":"36c377ae7299ed69d1b9990a56ec0b3601e946db","modified":1549114657000},{"_id":"source/images/eva-1.png","hash":"15b35531416ff47dc9f44bf9d266ef6eb87fd503","modified":1640932904115},{"_id":"source/images/long division.png","hash":"561f9f3c89d91315c00403881736c518191fe7f3","modified":1531236085000},{"_id":"source/_posts/2024-summary/night.jpeg","hash":"d95ee87dc878a0efc78f65f958617a5e6f29d3e7","modified":1735665405801},{"_id":"source/images/eva-2.png","hash":"304e34656ffa19ec3b96929be1640a7d1ad55a5e","modified":1640932954045},{"_id":"source/images/Game/devotion.png","hash":"1ce892fbbcfea86c01424e9027657d68253a9ed1","modified":1550754457000},{"_id":"source/images/metroid.png","hash":"4b66a75f79cfa8bb4ab556b698165bc9a1e81635","modified":1640923049772},{"_id":"source/images/repl.png","hash":"bc4902a6e8fdb2ab25c3cfd4348baf865d25baaf","modified":1559702599000},{"_id":"source/images/eva-4.png","hash":"9381ed3fa21243386fb8dff287977b409135657d","modified":1640933002603},{"_id":"source/images/eva-3.png","hash":"00bae73078c2b4bd9bea43657e6cc1f84e3d08b8","modified":1640932981272},{"_id":"source/images/iOS13 tab 1.png","hash":"92d1b1254ce8c15aa3d770a51b45c42292cd7ed4","modified":1559706251000},{"_id":"source/images/koa_routing.png","hash":"a4f7addd2d15c2b32866b4205b79d41c99c85b27","modified":1548502827000},{"_id":"source/images/shin-megami-tensei-v.png","hash":"c16a9e6446b049285e07f1202d715bece8dec2ed","modified":1640922981283},{"_id":"source/images/Game/Go-Trilogy.png","hash":"1747482cc270f4f3f21e2a5d9b37b4e609dcfbc3","modified":1549543849000},{"_id":"source/images/iPad files bug.png","hash":"f9eaa62c84a4b3af32bc5d1d435a301515356195","modified":1559704629000},{"_id":"source/images/p5r-ending.png","hash":"e55e78ad115a6a06bbbf46bea1c89197cca651f0","modified":1640923023216},{"_id":"source/_posts/2023-summary/rye.jpeg","hash":"802005c29e1157eaf3afc4e554e65c4e78952efd","modified":1704035054890},{"_id":"source/_posts/热病/drive-my-car.jpeg","hash":"5b8fb3afd81bf59f23dee752df7109aff8045bd7","modified":1672482957652},{"_id":"source/_posts/热病/tlou.jpeg","hash":"c4455a7fd664adbd16f6805b01f2f04eb5a35382","modified":1672498489275},{"_id":"source/images/auth02.png","hash":"2ecbc6d438a85fe20fbe3b5fb3e6da970ae21e7f","modified":1560327761000},{"_id":"source/images/Promise.png","hash":"88e474127a492e3fa065480d66c9f7a944c71fbf","modified":1558186260000},{"_id":"source/images/knex.png","hash":"a1084185fc9edcf099c2dfe74fc6e80946dd982e","modified":1549114906000},{"_id":"source/images/IMG_1578.JPG","hash":"860b41f6f6accaad3bce7acc23e4957b2487e452","modified":1577868396000},{"_id":"source/_posts/2023-summary/zelda.png","hash":"1e8ad214fdebdfd619e8eb18e1ca4b1301428c7b","modified":1704034798034},{"_id":"source/images/auto01.png","hash":"fefa86b78f54e2a3cf2c7b553d59209c5580efe7","modified":1560319482000},{"_id":"source/images/eventLoop.png","hash":"65dd2790e47a13b1338f0cbd56e6dcff0abc6066","modified":1558187298000},{"_id":"source/images/movies_2020.PNG","hash":"28a2cd9b6c154c458a9259e1d5992ede6cbbf5c7","modified":1609384126000},{"_id":"source/images/switch_2020.png","hash":"ead8b0ab6ef824289c24cdf9cbdeb60b2b9030e3","modified":1608726030000},{"_id":"source/images/舞！舞！舞！.png","hash":"7fffa1202a4c4ab72ea106c87e22064a598889f0","modified":1609382859000},{"_id":"public/atom.xml","hash":"c583419f95cbea8a7f248e57671c2de0a79e16a0","modified":1735664408742},{"_id":"public/categories/index.html","hash":"991ec8dd1691b34f39c492fd0451b2521c92540f","modified":1748439887426},{"_id":"public/tags/index.html","hash":"991ec8dd1691b34f39c492fd0451b2521c92540f","modified":1748439887426},{"_id":"public/2024/12/31/2024-summary/index.html","hash":"e25efba04b7a80f440cbaec263710c09a5db1c39","modified":1748439887426},{"_id":"public/2023/12/30/2023-summary/index.html","hash":"d6a7f45d2fff6cd967bf6cad3a20e1d84c309667","modified":1748439887426},{"_id":"public/2022/12/31/热病/index.html","hash":"f63901e3e84e42d3b15abe14af6df438dd39f391","modified":1748439887426},{"_id":"public/2021/12/31/Fly-Me-to-the-Moon/index.html","hash":"15913680c0dad6ea75c5ce5ad5bbba91de68ab03","modified":1748439887426},{"_id":"public/2020/12/31/「可我会永远喜欢你的，这和时间没关系，我想」/index.html","hash":"b193e83b5b6ec54daefc8598c69d1fe2206c998d","modified":1748439887426},{"_id":"public/2020/01/01/十年回顾/index.html","hash":"379aa308e093a41c8087e98b953c50a6aa64ee96","modified":1748439887426},{"_id":"public/2019/08/29/多个项目共享-Webpack/index.html","hash":"23907ee014226a8ef52c101bbb0117b77963abce","modified":1748439887426},{"_id":"public/2019/07/06/Lazy-Evaluation/index.html","hash":"7bf398bd9fb088ca7c667fb9e6554080f44081c0","modified":1748439887426},{"_id":"public/2019/06/29/JavaScript-Semicolon 二三事/index.html","hash":"210ea29487aaf46132fcfc1c3f2ccfe49f7a0208","modified":1748439887426},{"_id":"public/2019/07/12/阅读摘要-issue-3/index.html","hash":"2044d2a0627afeaf5416024920603da3e71c0d73","modified":1748439887426},{"_id":"public/2019/06/12/JSON-Web-Token-的产生和认证/index.html","hash":"bc49a497da590d2423ecb955649f1c0c4335f380","modified":1748439887426},{"_id":"public/2019/06/05/iPadOS-使用体验/index.html","hash":"b480e78d90b22a6dd867a7c4ebb9f5f964ec0a3d","modified":1748439887426},{"_id":"public/2019/05/31/阅读摘要-issues-1/index.html","hash":"7c6f1b734aa86cb08c11a1f3f63d82b293cb9939","modified":1748439887426},{"_id":"public/2019/06/12/阅读摘要-issue-2/index.html","hash":"51c936e8586148a89de6a3e2e13e50c87531900a","modified":1748439887426},{"_id":"public/2019/05/18/JavaScript-async-and-Promise/index.html","hash":"7fce2c5de06e447df0b58dc3367471befe7d1c36","modified":1748439887426},{"_id":"public/2019/02/23/赤烛 - 『还愿』/index.html","hash":"7737ef44c06badedcad33015acae25e2ee794cfa","modified":1748439887426},{"_id":"public/2019/02/07/棋盘上的「古墓丽影」/index.html","hash":"99b5984914809e8bed4f13fe0748ca1716bdb0ad","modified":1748439887426},{"_id":"public/2019/02/02/「User Authentication with Passport and Koa 」Summary/index.html","hash":"91821585e4d6307813599304a89477453f11a1dd","modified":1748439887426},{"_id":"public/2019/01/26/初见 Koa/index.html","hash":"51e6f14ff73cd45b91e4d1b13dbc77d031a564f6","modified":1748439887426},{"_id":"public/2019/01/25/异步 & callback/index.html","hash":"9876fb75fcbd81573c1c867b0423198069d5c705","modified":1748439887426},{"_id":"public/2019/01/23/1n- Cycle | 6kyu/index.html","hash":"cc2289bd26a1d315195751701dcc92df1fa00d85","modified":1748439887426},{"_id":"public/2019/01/22/象棋 (XiangqiChinese Chess) Board Validator | 4kyu/index.html","hash":"72925f21228d64f00d56aa0474794ccf41255a77","modified":1748439887426},{"_id":"public/2019/01/22/Lowest base system | 4kyu/index.html","hash":"9c6a3baa995d787321bb362701adb88c5e2dc53b","modified":1748439887426},{"_id":"public/2019/01/22/Born to be chained | 4kyu/index.html","hash":"2dea01c1fd8811679fa0e8171e3125cf1a0267a5","modified":1748439887426},{"_id":"public/2019/01/22/Binary Search Trees | 5kyu/index.html","hash":"86a3f52b43f81a357a6992a42e9ab27e3f854602","modified":1748439887426},{"_id":"public/2019/01/22/Argument Mapper | 5kyu/index.html","hash":"ab59e257be497f6b899d3a1531ec4046f4ff7219","modified":1748439887426},{"_id":"public/2019/01/22/@wraps | 6kyu/index.html","hash":"a9c9eb02784c124f7fa71c44430d71097c8b8de3","modified":1748439887426},{"_id":"public/2019/01/22/Default Arguments | 4kyu/index.html","hash":"e3c5f1d41f1f3d97657142e816473b47ed5aaf8d","modified":1748439887426},{"_id":"public/2019/01/22/Hexo Theme 开发不完全记录/index.html","hash":"41013788f96cc08aade8533197a8b5708b0f93e9","modified":1748439887426},{"_id":"public/2019/01/18/Codewars.com-|-Catching-Car-Mileage-Numbers/index.html","hash":"ae6293436a1568bffcdb6a37b737844019f309c5","modified":1748439887426},{"_id":"public/2019/01/18/Codewars.com | Wrapped Function/index.html","hash":"97125967710880561c5e4116f04fb98c6cee91d9","modified":1748439887426},{"_id":"public/2019/01/18/Codewars.com | ES5 Generators(i)/index.html","hash":"79db401d10edd3d9ef437a192089ef281bfd9c9a","modified":1748439887426},{"_id":"public/2017/11/02/Hexo部署到新电脑/index.html","hash":"cd971e4829add54d0dd82d3edc5cf4ff6ba3f087","modified":1748439887426},{"_id":"public/2017/09/10/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」/index.html","hash":"a698a512918316e493fccb5db51ce182fd4b47d3","modified":1748439887426},{"_id":"public/2017/04/15/I-O-21-Habitica 的量化人生/index.html","hash":"c3d505f3984c105773d0ecd41e4e895e2e12b08e","modified":1748439887426},{"_id":"public/2017/05/31/I-O-22-端午/index.html","hash":"01b65e1c5cbdfb25c01af8f4745069854253cbe3","modified":1748439887426},{"_id":"public/2017/01/05/I-O-20-「有目标，能坚持！」/index.html","hash":"9ee3a4f9b5e02b37d25752039ac1ca07d36d2c61","modified":1748439887426},{"_id":"public/categories/Coding/index.html","hash":"5c59e308069e8dcc015753feb26f202f992d850f","modified":1748439887426},{"_id":"public/2016/12/17/I-O-19-Samorost-的银河历险记/index.html","hash":"8031b0d38bed3a51161165d38d5186db862c2def","modified":1748439887426},{"_id":"public/2016/09/12/I-O-18-名为丢失的记忆/index.html","hash":"076f370f654830666a2dfab5c0761dfc43a7937f","modified":1748439887426},{"_id":"public/categories/Coding/page/2/index.html","hash":"028b5f16afa7b972308c88212bbc32d188acc83f","modified":1748439887426},{"_id":"public/categories/I-O/index.html","hash":"e5850c4fea08092e86846c8e8259326c195dfddc","modified":1748439887426},{"_id":"public/categories/I-O/page/2/index.html","hash":"3baa95ff57e901149d8e1ac33d3be5673d902d67","modified":1748439887426},{"_id":"public/index.html","hash":"91982b5b15cdbb9ceae2f8dcebe27f243b04759a","modified":1748439887426},{"_id":"public/page/2/index.html","hash":"34eb4d2b81381571bdaaf9e5253c46acb869ff6e","modified":1748439887426},{"_id":"public/page/3/index.html","hash":"ca5fe6f818ded57d31a0182b6c233354226ae367","modified":1748439887426},{"_id":"public/page/4/index.html","hash":"82f582117140ca41089a9fd06b90c2582b7d37b9","modified":1748439887426},{"_id":"public/archives/index.html","hash":"704f47416fda9f03f379263f165feadc59025ea6","modified":1748439887426},{"_id":"public/archives/2016/index.html","hash":"7628fb9a5849e32500bf912bdb360a299c7a6b92","modified":1748439887426},{"_id":"public/archives/2016/09/index.html","hash":"77f80413f5db4f933cf02e71505aa23e64bb0a58","modified":1748439887426},{"_id":"public/archives/2016/12/index.html","hash":"93b45634c54c91310c04fc680cf617cc3c2d35c3","modified":1748439887426},{"_id":"public/archives/2017/index.html","hash":"928fba07eb8ab152f03456a7784c8781bc2ffbe4","modified":1748439887426},{"_id":"public/archives/2017/01/index.html","hash":"ca0a02474de7cc7c7863410cf819caf83c74ef22","modified":1748439887426},{"_id":"public/archives/2017/04/index.html","hash":"699f55b38d5c4ef9afac1128bf1b2a23ef075b23","modified":1748439887426},{"_id":"public/archives/2017/05/index.html","hash":"98bb3cca015f83b2a8d8c5184b150b129040f6c6","modified":1748439887426},{"_id":"public/archives/2017/09/index.html","hash":"94d68a3e77cfbf92952dc078de3ee5bc375f5171","modified":1748439887426},{"_id":"public/archives/2017/11/index.html","hash":"6289fcaaf9b8f1110fa728973e57551372551cca","modified":1748439887426},{"_id":"public/archives/2019/index.html","hash":"003e6ac4fbb37fe13f1633e6e412a6a8010c6561","modified":1748439887426},{"_id":"public/archives/2019/02/index.html","hash":"6406be364cf78a04c9cfd39276afafbf4260226e","modified":1748439887426},{"_id":"public/archives/2019/05/index.html","hash":"781ec4018bca62e3493b797117d7bab77157ddea","modified":1748439887426},{"_id":"public/archives/2019/06/index.html","hash":"fdb500f06b333c646cfb839e2499ff479dc0233f","modified":1748439887426},{"_id":"public/archives/2019/01/index.html","hash":"19cde1aa36d124bff1a8bcb40a3230282d5fa817","modified":1748439887426},{"_id":"public/archives/2019/08/index.html","hash":"620f2d8a61ea1ff895002810385ef21f9d13b041","modified":1748439887426},{"_id":"public/archives/2020/index.html","hash":"f236c1516bdf6286b3772877f66b6a1af13971e6","modified":1748439887426},{"_id":"public/archives/2019/07/index.html","hash":"376e285a9f5debfdb803d8b8c450bf90b9b862de","modified":1748439887426},{"_id":"public/archives/2020/01/index.html","hash":"b484209b88aa64cbc4150527f18dcb6495e90518","modified":1748439887426},{"_id":"public/archives/2020/12/index.html","hash":"51b862b388efca504adef876b17590e60a313cfc","modified":1748439887426},{"_id":"public/archives/2021/index.html","hash":"8322369edd379855930b1bc7a052fd2e1f2755ed","modified":1748439887426},{"_id":"public/archives/2022/index.html","hash":"39cddcd8fefa2cf5c7abd5b12e8785cd48586750","modified":1748439887426},{"_id":"public/archives/2022/12/index.html","hash":"99a65bd6ee135f9daaa92a8aa1558bab1d9261eb","modified":1748439887426},{"_id":"public/archives/2021/12/index.html","hash":"9ea9b891ed8b2c8fb2478c73a56171852d1de6d4","modified":1748439887426},{"_id":"public/archives/2023/index.html","hash":"406bba85e06b4a7cd5d88c5712ab02f996a4d485","modified":1748439887426},{"_id":"public/archives/2023/12/index.html","hash":"86829c917298c95e4b25ebab0b05d8655143bebb","modified":1748439887426},{"_id":"public/archives/2024/index.html","hash":"19371e8fa5ace5bd80785a1195ef99c5d2f920cf","modified":1748439887426},{"_id":"public/archives/2024/12/index.html","hash":"784cef413687e8dd92ccb0a76697b7ce6c59e1dd","modified":1748439887426},{"_id":"public/tags/Algorithm/index.html","hash":"b10dfb96c9ea682f62ecd136c4118cedf9effdf5","modified":1748439887426},{"_id":"public/tags/Algorithm/page/2/index.html","hash":"5f4a8c98a162c97c5faea98a6cf0d0ca78adfce7","modified":1748439887426},{"_id":"public/tags/codewars/index.html","hash":"ba67f49a9e6b27632862ac50503be80bbe661cbc","modified":1748439887426},{"_id":"public/tags/codewars/page/2/index.html","hash":"d38f27f225c039d114b43f38400a7a475533aaac","modified":1748439887426},{"_id":"public/tags/Python/index.html","hash":"e3068a631c46b2fba49cb36f4b031c977f5935ca","modified":1748439887426},{"_id":"public/tags/电影/index.html","hash":"448cc035fc5533a1b7cd8a9836dd8bd0a698738d","modified":1748439887426},{"_id":"public/tags/游戏/index.html","hash":"cfaf0a6a2cb07d4be37d60dacc7bbb262469ee3f","modified":1748439887426},{"_id":"public/tags/音乐/index.html","hash":"b0ebc6e3ae05d4034dd3ff429347939e3ab6163a","modified":1748439887426},{"_id":"public/tags/JavaScript/index.html","hash":"3951691205fc6161740f1c99c6952d9f8c97de14","modified":1748439887426},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"9e22254f3430643a204d2977026ec299f586c834","modified":1748439887426},{"_id":"public/tags/Anime/index.html","hash":"1e369003d6fda0f23a98fe8200b3d7464489c951","modified":1748439887426},{"_id":"public/tags/故事/index.html","hash":"bbbb177723c10f8726921113d52c7414b44b4789","modified":1748439887426},{"_id":"public/tags/Front-end/index.html","hash":"f647b7c1ba49072f1413d33de3945aa6c4d20138","modified":1748439887426},{"_id":"public/tags/Node-js/index.html","hash":"3bca67cc378a0f275e7d58fcf754f0b9f76bc6a4","modified":1748439887426},{"_id":"public/images/footer.png","hash":"84887971754777c38043e04921f530ed60c2754f","modified":1735664408742},{"_id":"public/CNAME","hash":"51be50ef18c59721f889cb63e1e8db80108c2cf8","modified":1735664408742},{"_id":"public/favicon180x180.png","hash":"6d3090987005a21f38bea3521a7622d7159349e7","modified":1735664408742},{"_id":"public/images/logo.png","hash":"ced8adad841411d31c1ec54306fe3a2942bab292","modified":1735664408742},{"_id":"public/images/Reward.png","hash":"a980a79cd0ccd89b39208669682a2c47d7c2aeba","modified":1735664408742},{"_id":"public/images/exp.png","hash":"32c2b5b7467f3a03dbdd8733b2565551ef61c471","modified":1735664408742},{"_id":"public/images/iOS13 tab 3.png","hash":"6b75b314c28ecfc45d2b832259987ba6a920bac9","modified":1735664408742},{"_id":"public/images/intro.jpg","hash":"a0a366851bda70575031ee76cfae55f93244bdac","modified":1735664408742},{"_id":"public/images/value2.png","hash":"3efcd3cbf3be76a7ed3ec2f4d500472946bf344d","modified":1735664408742},{"_id":"public/images/value1.png","hash":"bfd1e8b2d2dbe6694501341fa35198df13b8b7f6","modified":1735664408742},{"_id":"public/favicon.ico","hash":"a6e0f72689bd896eb0e1f1d30c08b8adce8ece87","modified":1735664408742},{"_id":"public/favicon.png","hash":"f2f39eb11c01ef692750ec368caaca57920db238","modified":1735664408742},{"_id":"public/images/iOS13 tab 2.png","hash":"703b5536e2174ed7a78eebe965f33dda5675c25b","modified":1735664408742},{"_id":"public/images/Game/Lara Go 2.jpg","hash":"1ea205bfae83e482404d40e76f7c31b83e2a0699","modified":1735664408742},{"_id":"public/js/highlightjs-line-numbers.js","hash":"eb08de1981d754e58b5a686e1f9a523def180872","modified":1735664408742},{"_id":"public/css/highlight.css","hash":"019aad2812e8bc119513d43890ac2cefa70d73a6","modified":1735664408742},{"_id":"public/css/main.css","hash":"53b3b2a47c842819971145de691d9d69efe62a25","modified":1735664408742},{"_id":"public/js/highlight.min.js","hash":"fbaec451eb5541f7d0e8c6910af13977043d478a","modified":1735664408742},{"_id":"public/js/main.js","hash":"013069d1fb4adcf881e51a4328898c825f456591","modified":1735664408742},{"_id":"public/js/jquery-3.3.1.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1735664408742},{"_id":"public/images/zelda-botw.jpg","hash":"851f70bcf16d6dcb04373398ea94c6cc8f4bffad","modified":1735664408742},{"_id":"public/images/Game/Lara Go 1.jpg","hash":"5dba652d113f7f0fa7b48254606c9bde9ca899e0","modified":1735664408742},{"_id":"public/images/Game/Lara Go .jpg","hash":"c17900027e77df34a81a13f5ab3948e4373cbeaa","modified":1735664408742},{"_id":"public/images/Game/Lara Go 3.jpg","hash":"2567302a73dec4d5c3b03ff2600c4681a5cd3633","modified":1735664408742},{"_id":"public/2023/12/30/2023-summary/first-game.jpg","hash":"9b869313948a63e7be84d6c7e0c79fdf6b89bd32","modified":1735664408742},{"_id":"public/images/Mocha_test.png","hash":"36c377ae7299ed69d1b9990a56ec0b3601e946db","modified":1735664408742},{"_id":"public/images/eva-1.png","hash":"15b35531416ff47dc9f44bf9d266ef6eb87fd503","modified":1735664408742},{"_id":"public/images/long division.png","hash":"561f9f3c89d91315c00403881736c518191fe7f3","modified":1735664408742},{"_id":"public/2024/12/31/2024-summary/night.jpeg","hash":"d95ee87dc878a0efc78f65f958617a5e6f29d3e7","modified":1748439887426},{"_id":"public/images/eva-2.png","hash":"304e34656ffa19ec3b96929be1640a7d1ad55a5e","modified":1735664408742},{"_id":"public/images/Game/devotion.png","hash":"1ce892fbbcfea86c01424e9027657d68253a9ed1","modified":1735664408742},{"_id":"public/images/metroid.png","hash":"4b66a75f79cfa8bb4ab556b698165bc9a1e81635","modified":1735664408742},{"_id":"public/images/repl.png","hash":"bc4902a6e8fdb2ab25c3cfd4348baf865d25baaf","modified":1735664408742},{"_id":"public/images/eva-4.png","hash":"9381ed3fa21243386fb8dff287977b409135657d","modified":1735664408742},{"_id":"public/images/eva-3.png","hash":"00bae73078c2b4bd9bea43657e6cc1f84e3d08b8","modified":1735664408742},{"_id":"public/images/iOS13 tab 1.png","hash":"92d1b1254ce8c15aa3d770a51b45c42292cd7ed4","modified":1735664408742},{"_id":"public/images/koa_routing.png","hash":"a4f7addd2d15c2b32866b4205b79d41c99c85b27","modified":1735664408742},{"_id":"public/images/shin-megami-tensei-v.png","hash":"c16a9e6446b049285e07f1202d715bece8dec2ed","modified":1735664408742},{"_id":"public/images/Game/Go-Trilogy.png","hash":"1747482cc270f4f3f21e2a5d9b37b4e609dcfbc3","modified":1735664408742},{"_id":"public/images/p5r-ending.png","hash":"e55e78ad115a6a06bbbf46bea1c89197cca651f0","modified":1735664408742},{"_id":"public/images/iPad files bug.png","hash":"f9eaa62c84a4b3af32bc5d1d435a301515356195","modified":1735664408742},{"_id":"public/2023/12/30/2023-summary/rye.jpeg","hash":"802005c29e1157eaf3afc4e554e65c4e78952efd","modified":1735664408742},{"_id":"public/2022/12/31/热病/tlou.jpeg","hash":"c4455a7fd664adbd16f6805b01f2f04eb5a35382","modified":1735664408742},{"_id":"public/2022/12/31/热病/drive-my-car.jpeg","hash":"5b8fb3afd81bf59f23dee752df7109aff8045bd7","modified":1735664408742},{"_id":"public/images/auth02.png","hash":"2ecbc6d438a85fe20fbe3b5fb3e6da970ae21e7f","modified":1735664408742},{"_id":"public/images/Promise.png","hash":"88e474127a492e3fa065480d66c9f7a944c71fbf","modified":1735664408742},{"_id":"public/images/knex.png","hash":"a1084185fc9edcf099c2dfe74fc6e80946dd982e","modified":1735664408742},{"_id":"public/images/IMG_1578.JPG","hash":"860b41f6f6accaad3bce7acc23e4957b2487e452","modified":1735664408742},{"_id":"public/2023/12/30/2023-summary/zelda.png","hash":"1e8ad214fdebdfd619e8eb18e1ca4b1301428c7b","modified":1735664408742},{"_id":"public/images/auto01.png","hash":"fefa86b78f54e2a3cf2c7b553d59209c5580efe7","modified":1735664408742},{"_id":"public/images/eventLoop.png","hash":"65dd2790e47a13b1338f0cbd56e6dcff0abc6066","modified":1735664408742},{"_id":"public/images/movies_2020.PNG","hash":"28a2cd9b6c154c458a9259e1d5992ede6cbbf5c7","modified":1735664408742},{"_id":"public/images/switch_2020.png","hash":"ead8b0ab6ef824289c24cdf9cbdeb60b2b9030e3","modified":1735664408742},{"_id":"public/images/舞！舞！舞！.png","hash":"7fffa1202a4c4ab72ea106c87e22064a598889f0","modified":1735664408742}],"Category":[{"name":"Coding","_id":"cm5cprx210004rg1v9o6fftos"},{"name":"I/O","_id":"cm5cprx230009rg1vgi8ba7zg"}],"Data":[],"Page":[{"title":"categories","date":"2017-03-11T09:11:04.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-11 17:11:04\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-11-03T14:35:28.000Z","path":"categories/index.html","layout":"page","_id":"cm5cprx1y0000rg1v7hk7hu2s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","date":"2017-03-11T12:01:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ndate: 2017-03-11 20:01:25\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-11-03T14:35:28.000Z","path":"tags/index.html","layout":"page","_id":"cm5cprx200002rg1v2guufl7o","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"1/n- Cycle | 6kyu","date":"2019-01-23T01:31:08.000Z","_content":"\n## Details\n\nLet be `n` an integer prime with `10` e.g. `7`. \n\n`1/7 = 0.142857 142857 142857 ...`.\n\nWe see that the decimal part has a cycle: `142857`. The length of this cycle is `6`. In the same way:\n\n`1/11 = 0.09 09 09 ...`. Cycle length is `2`.\n\n**Task**\n\nGiven an integer n (n > 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.\n\n**Exemples:**\n\n```python\ncycle(5) = -1\ncycle(13) = 6 -> 0.076923 076923 0769\ncycle(21) = 6 -> 0.047619 047619 0476\ncycle(27) = 3 -> 0.037 037 037 037 0370\ncycle(33) = 2 -> 0.03 03 03 03 03 03 03 03\ncycle(37) = 3 -> 0.027 027 027 027 027 0\ncycle(94) = -1 \n\ncycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...\n```\n\nNote\n\n- Translators are welcome for all languages.\n\n<!--more-->\n\n## My Solution\n\n```python\nimport math\nimport fractions\n\ndef cycle(n) :\n    if n==2 or n==5 :\n        return -1\n    t = phi(n)\n    p = primes(t)\n    divisor = []\n    for i in p:\n        x = i\n        while t % i == 0:\n            divisor.append(i)\n            t //= i\n        if isprime(t):\n            divisor.append(t)\n            break\n    divisor.sort()\n    print(divisor)\n    for i in divisor:\n        if 10**i % n == 1:\n            break\n    return i\n\ndef phi(n):\n    '''compute Euler's totient function values.'''\n    amount = 0\n    for k in range(1, n + 1):\n        if math.gcd(n, k) == 1:\n            amount += 1\n    return amount\n\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef primes(limit):\n    D = {}\n    q = 2\n    while q <= limit:\n        if q not in D:\n            yield q\n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n        q += 1\n\nprint(cycle(219199))\n```\n\n这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：\n\n```python\n10**p % n == 1\n```\n\n其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。\n\n但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 `219199`，它的循环位数是 `36180`。暴力写循环根本就行不通！\n\n\n\n## Other Solutions\n\n [lechevalier](https://www.codewars.com/users/lechevalier)\n\n```python\ndef cycle(n):\n    if not n % 2 or not n % 5:\n        return -1\n    x, mods = 1, set()\n    while x not in mods:\n        mods.add(x)\n        x = 10 * x % n\n    return len(mods)\n```\n\nlechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，`mods` 长度刚好是循环的位数？\n\n方法类似这里给出的答案：[How to Calculate Recurring Digits?](https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits)\n\n> You can calculate the decimal representation of `a / b` using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by `b`, and find the next dividend as the remainder multiplied by 10 (\"bringing down a 0\"). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.\n\n明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。\n\n![long division](/images/long division.png)\n\n那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 \n\n\n\n参考文章：\n\n- [Calculating Euler's totient function values.](https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values)\n- [How to Calculate Recurring Digits?](https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits)","source":"_posts/1n- Cycle | 6kyu.md","raw":"---\ntitle: '1/n- Cycle | 6kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- Python\ncategories: \n- Coding\n---\n\n## Details\n\nLet be `n` an integer prime with `10` e.g. `7`. \n\n`1/7 = 0.142857 142857 142857 ...`.\n\nWe see that the decimal part has a cycle: `142857`. The length of this cycle is `6`. In the same way:\n\n`1/11 = 0.09 09 09 ...`. Cycle length is `2`.\n\n**Task**\n\nGiven an integer n (n > 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.\n\n**Exemples:**\n\n```python\ncycle(5) = -1\ncycle(13) = 6 -> 0.076923 076923 0769\ncycle(21) = 6 -> 0.047619 047619 0476\ncycle(27) = 3 -> 0.037 037 037 037 0370\ncycle(33) = 2 -> 0.03 03 03 03 03 03 03 03\ncycle(37) = 3 -> 0.027 027 027 027 027 0\ncycle(94) = -1 \n\ncycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...\n```\n\nNote\n\n- Translators are welcome for all languages.\n\n<!--more-->\n\n## My Solution\n\n```python\nimport math\nimport fractions\n\ndef cycle(n) :\n    if n==2 or n==5 :\n        return -1\n    t = phi(n)\n    p = primes(t)\n    divisor = []\n    for i in p:\n        x = i\n        while t % i == 0:\n            divisor.append(i)\n            t //= i\n        if isprime(t):\n            divisor.append(t)\n            break\n    divisor.sort()\n    print(divisor)\n    for i in divisor:\n        if 10**i % n == 1:\n            break\n    return i\n\ndef phi(n):\n    '''compute Euler's totient function values.'''\n    amount = 0\n    for k in range(1, n + 1):\n        if math.gcd(n, k) == 1:\n            amount += 1\n    return amount\n\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef primes(limit):\n    D = {}\n    q = 2\n    while q <= limit:\n        if q not in D:\n            yield q\n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n        q += 1\n\nprint(cycle(219199))\n```\n\n这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：\n\n```python\n10**p % n == 1\n```\n\n其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。\n\n但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 `219199`，它的循环位数是 `36180`。暴力写循环根本就行不通！\n\n\n\n## Other Solutions\n\n [lechevalier](https://www.codewars.com/users/lechevalier)\n\n```python\ndef cycle(n):\n    if not n % 2 or not n % 5:\n        return -1\n    x, mods = 1, set()\n    while x not in mods:\n        mods.add(x)\n        x = 10 * x % n\n    return len(mods)\n```\n\nlechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，`mods` 长度刚好是循环的位数？\n\n方法类似这里给出的答案：[How to Calculate Recurring Digits?](https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits)\n\n> You can calculate the decimal representation of `a / b` using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by `b`, and find the next dividend as the remainder multiplied by 10 (\"bringing down a 0\"). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.\n\n明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。\n\n![long division](/images/long division.png)\n\n那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 \n\n\n\n参考文章：\n\n- [Calculating Euler's totient function values.](https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values)\n- [How to Calculate Recurring Digits?](https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits)","slug":"1n- Cycle | 6kyu","published":1,"updated":"2019-01-23T01:31:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx1z0001rg1v5716ayb2","content":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Let be <code>n</code> an integer prime with <code>10</code> e.g. <code>7</code>. </p>\n<p><code>1/7 = 0.142857 142857 142857 ...</code>.</p>\n<p>We see that the decimal part has a cycle: <code>142857</code>. The length of this cycle is <code>6</code>. In the same way:</p>\n<p><code>1/11 = 0.09 09 09 ...</code>. Cycle length is <code>2</code>.</p>\n<p><strong>Task</strong></p>\n<p>Given an integer n (n &gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.</p>\n<p><strong>Exemples:</strong></p>\n<pre><code class=\"python\">cycle(5) = -1\ncycle(13) = 6 -&gt; 0.076923 076923 0769\ncycle(21) = 6 -&gt; 0.047619 047619 0476\ncycle(27) = 3 -&gt; 0.037 037 037 037 0370\ncycle(33) = 2 -&gt; 0.03 03 03 03 03 03 03 03\ncycle(37) = 3 -&gt; 0.027 027 027 027 027 0\ncycle(94) = -1 \n\ncycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...\n</code></pre>\n<p>Note</p>\n<ul>\n<li>Translators are welcome for all languages.</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">import math\nimport fractions\n\ndef cycle(n) :\n    if n==2 or n==5 :\n        return -1\n    t = phi(n)\n    p = primes(t)\n    divisor = []\n    for i in p:\n        x = i\n        while t % i == 0:\n            divisor.append(i)\n            t //= i\n        if isprime(t):\n            divisor.append(t)\n            break\n    divisor.sort()\n    print(divisor)\n    for i in divisor:\n        if 10**i % n == 1:\n            break\n    return i\n\ndef phi(n):\n    &#39;&#39;&#39;compute Euler&#39;s totient function values.&#39;&#39;&#39;\n    amount = 0\n    for k in range(1, n + 1):\n        if math.gcd(n, k) == 1:\n            amount += 1\n    return amount\n\n\ndef isprime(n):\n    &quot;&quot;&quot;Returns True if n is prime.&quot;&quot;&quot;\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i &lt;= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef primes(limit):\n    D = &#123;&#125;\n    q = 2\n    while q &lt;= limit:\n        if q not in D:\n            yield q\n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n        q += 1\n\nprint(cycle(219199))\n</code></pre>\n<p>这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：</p>\n<pre><code class=\"python\">10**p % n == 1\n</code></pre>\n<p>其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。</p>\n<p>但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 <code>219199</code>，它的循环位数是 <code>36180</code>。暴力写循环根本就行不通！</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/lechevalier\">lechevalier</a></p>\n<pre><code class=\"python\">def cycle(n):\n    if not n % 2 or not n % 5:\n        return -1\n    x, mods = 1, set()\n    while x not in mods:\n        mods.add(x)\n        x = 10 * x % n\n    return len(mods)\n</code></pre>\n<p>lechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，<code>mods</code> 长度刚好是循环的位数？</p>\n<p>方法类似这里给出的答案：<a href=\"https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits\">How to Calculate Recurring Digits?</a></p>\n<blockquote>\n<p>You can calculate the decimal representation of <code>a / b</code> using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by <code>b</code>, and find the next dividend as the remainder multiplied by 10 (“bringing down a 0”). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.</p>\n</blockquote>\n<p>明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。</p>\n<p>![long division](/images/long division.png)</p>\n<p>那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 </p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values\">Calculating Euler’s totient function values.</a></li>\n<li><a href=\"https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits\">How to Calculate Recurring Digits?</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Let be <code>n</code> an integer prime with <code>10</code> e.g. <code>7</code>. </p>\n<p><code>1/7 = 0.142857 142857 142857 ...</code>.</p>\n<p>We see that the decimal part has a cycle: <code>142857</code>. The length of this cycle is <code>6</code>. In the same way:</p>\n<p><code>1/11 = 0.09 09 09 ...</code>. Cycle length is <code>2</code>.</p>\n<p><strong>Task</strong></p>\n<p>Given an integer n (n &gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.</p>\n<p><strong>Exemples:</strong></p>\n<pre><code class=\"python\">cycle(5) = -1\ncycle(13) = 6 -&gt; 0.076923 076923 0769\ncycle(21) = 6 -&gt; 0.047619 047619 0476\ncycle(27) = 3 -&gt; 0.037 037 037 037 0370\ncycle(33) = 2 -&gt; 0.03 03 03 03 03 03 03 03\ncycle(37) = 3 -&gt; 0.027 027 027 027 027 0\ncycle(94) = -1 \n\ncycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...\n</code></pre>\n<p>Note</p>\n<ul>\n<li>Translators are welcome for all languages.</li>\n</ul>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">import math\nimport fractions\n\ndef cycle(n) :\n    if n==2 or n==5 :\n        return -1\n    t = phi(n)\n    p = primes(t)\n    divisor = []\n    for i in p:\n        x = i\n        while t % i == 0:\n            divisor.append(i)\n            t //= i\n        if isprime(t):\n            divisor.append(t)\n            break\n    divisor.sort()\n    print(divisor)\n    for i in divisor:\n        if 10**i % n == 1:\n            break\n    return i\n\ndef phi(n):\n    &#39;&#39;&#39;compute Euler&#39;s totient function values.&#39;&#39;&#39;\n    amount = 0\n    for k in range(1, n + 1):\n        if math.gcd(n, k) == 1:\n            amount += 1\n    return amount\n\n\ndef isprime(n):\n    &quot;&quot;&quot;Returns True if n is prime.&quot;&quot;&quot;\n    if n == 2:\n        return True\n    if n == 3:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i &lt;= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef primes(limit):\n    D = &#123;&#125;\n    q = 2\n    while q &lt;= limit:\n        if q not in D:\n            yield q\n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n        q += 1\n\nprint(cycle(219199))\n</code></pre>\n<p>这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：</p>\n<pre><code class=\"python\">10**p % n == 1\n</code></pre>\n<p>其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。</p>\n<p>但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 <code>219199</code>，它的循环位数是 <code>36180</code>。暴力写循环根本就行不通！</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/lechevalier\">lechevalier</a></p>\n<pre><code class=\"python\">def cycle(n):\n    if not n % 2 or not n % 5:\n        return -1\n    x, mods = 1, set()\n    while x not in mods:\n        mods.add(x)\n        x = 10 * x % n\n    return len(mods)\n</code></pre>\n<p>lechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，<code>mods</code> 长度刚好是循环的位数？</p>\n<p>方法类似这里给出的答案：<a href=\"https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits\">How to Calculate Recurring Digits?</a></p>\n<blockquote>\n<p>You can calculate the decimal representation of <code>a / b</code> using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by <code>b</code>, and find the next dividend as the remainder multiplied by 10 (“bringing down a 0”). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.</p>\n</blockquote>\n<p>明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。</p>\n<p>![long division](/images/long division.png)</p>\n<p>那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 </p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values\">Calculating Euler’s totient function values.</a></li>\n<li><a href=\"https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits\">How to Calculate Recurring Digits?</a></li>\n</ul>"},{"title":"『別れの予感』","date":"2023-12-30T03:46:14.000Z","_content":"\n今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。\n\n> 「说到邓丽君的代表作」\n> 「很多粉丝会说〈何日君再来〉」\n> 「〈再见我的爱人〉或〈我只在乎你〉」\n> 「不瞒大家，其实我最喜欢这首」\n> \\- 老爸啊，到底想干什么呢？\n> \\- 干什么？\n> 「请听邓丽君的〈别离的预感〉」\n> \\- 他自己的人生啊\n> \\- 我不知道，到最后还是搞不懂他\n> \\- 他很多事无法心想事成吧，都怪时代不好\n> \\- 他把自己的缺点都怪在时代上\n> \\- 你干嘛感慨良多\n> \\- 没有\n> \\- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。\n> \\- 我知道\n> \\- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐\n> \\- 也许吧\n> \\- 其实幸福这种东西，没有牺牲就无法入手\n> 「比海还深，比天还蓝」\n> \\- 我到这把年纪了，还没有爱过谁比海还深的\n> \\- 别说这种孤僻话\n> \\- 你有吗？\n> \\- 我？\n> \\- 还算有吧\n> \\- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐\n> \\- 真复杂\n> \\- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊\n> \\- 不用啦  - 不然会忘记的\n> \\- 不用抄啦，我记住了\n> \n> \\-\\- 『比海更深』\n\n<!--more-->\n\n## 「死亡是一种解脱」\n\n「死亡是一种解脱」，是炉石传说中 Lord Godfrey 高弗雷勋爵的登场语音，尽管炉石传说已经退出中国一年了，可是我时常会想起这句话。以及，还时常在微博上检索「离灯_冬眠mode关闭失败」这个关键词。\n\n姥爷是三月份离开的。准确的时间是二〇二三年三月十七日。我是三月十日离开的深圳。\n\n决定离开深圳，对自己而言并没有花太多时间。当时二月底离职，房屋面临到期，继续待下去，无疑要面对一边要找工作，一边要找房子的处境。姥爷从去年开始身体一直都不是很好， 二〇二二年底放开之后，又得了一次新冠，从那开始就一直卧病在床。\n\n二〇一九年三月份来的深圳，在深圳待了有四年，下决定离开不过是一瞬间的事情。在网上购买几个大号的打包箱，胶带，泡沫。花一周的时间，把行李一点一点的寄回家。上一次这样做，还是二〇一六年大学毕业的时候。订了三月十日的机票，确定衣物啊，显示器啊，游戏机啊这些都寄走准备完毕，三月十日那天很早起床，收拾房间，背起背包，和室友在微信上说明原因并告别，然后一个人返乡。\n\n回到家的第二天，我和妈妈回老家农村去照顾姥爷。那个时候，姥爷整日都只能躺在床上，床被放置在了客厅，上面盖了两层棉被，旁边开着电热风扇。三月份，农村依然很冷。那天我回到老家，姥爷咳嗽得厉害，我问姥爷是不是嘴里有痰，想吐出来，姥爷睁大眼睛看着我，然后摇摇头。姥爷以前就是这样，不太喜欢给我们小辈找麻烦，什么事情他都要亲力亲为。那天我看到姥爷的眼神，我很清楚，姥爷什么都明白，什么都知道，只是没有力气，声音沙哑说不上话，也坐不起来。我和妈妈从三月十日待到了三月十五日。每晚我妈妈都是睡在姥爷旁别小床上，我舅舅睡在里屋的一个小硬板床上，两个人轮班照顾。那个小床后来我也睡了一晚，整晚都能听到姥爷咳嗽的声音，半夜两三点的时候，我听到姥姥也起来了，姥姥心疼不下姥爷一直咳嗽难受的样子，半夜起来看望姥爷，问姥爷哪里难受，帮姥爷揉肚子。两位老人都八十多岁了，那一晚我躺在偏里屋的小床上，整晚都没睡着，心里很难过。\n\n**有时候，你会特别惧怕明天到来。**\n\n姥爷的葬礼持续了三天，农村，红白喜事都特别复杂。葬礼结束那天我开始发烧。发烧持续了四天才好，那几天我一直在睡觉，做各种各样光怪陆离，魑魅魍魉的梦。\n\n## 2018 vs 2023\n\n2018 年我刚从德国回来的时候，计划着转行，也没有着急出去找工作，那会儿一整年都在家，看电影，打篮球，看书，写代码。\n\n2023 年离开深圳再次回到家乡，熟悉的场景有些相似，又有些不同。只能说我对这种 gap year 的处境驾轻就熟，有着足够的经验去应对。之后的整个四月一直到五月中旬，自己的大部分时间都投入到了自己的个人项目中，偶尔时间出去打打篮球，偶尔放松的时候玩几局 splatoon，zelda: tears of the kingdom。\n\n当你花上一周时间，解决了一些技术难题，把心中的想法实现出来的时候，不工作的焦虑感也会稍微消解，但这种消解总是暂时的，焦虑感却总会随着时间的推移越来越大。每晚都要熬到两三点钟才能睡着，在 live stream 中看几局 splatoon，有次还不小心听到某位 splatoon steamer 抱怨已经很久都没有去工作了。\n\n## Bump Version\n\n七月初面试确定，然后决定动身前往上海。\n\n在家里待了接近四个月，经历了「清明」，「五一」，「端午」，线上观看了六月份 Apple WWDC，去了一次北京。\n\n宝可梦系列中，小智每次在前往下一个新的区域的时候，都只是带上皮卡丘，把其他的宝可梦留在家里。\n\n![rye](rye.jpeg)\n\n决定动身前往上海，做一次超大规模的「断舍离」，只带上一些必要的生活用品，电脑，平板，不必要的物件都暂时安置在家中。这样的场景，像极了购买了一款游戏续作，主角还是前作的主角，没有改变，只是这一次需要前往崭新的区域去冒险，去面对此前没有见过的，新的敌人。\n\n在上海确定好工作事宜，花上周末两天时间去医院做体检，找房子。网络上下单必备的生活用品，纸巾，洗衣液，衣撑，枕芯等等。一切安置妥当不需要花太久的时间。晚间时分在住的地方附近逛一逛，熟悉一下周边的环境和风景。我在 IM 软件中联系在上海的同学，告诉他们我从深圳换到上海这边工作了，有时间可以出来见一面，叙叙旧。\n\n自己以前总是对未来有着明确的期许，有着可能划分到每一天的明确的计划。但我现在不这样，很多事情并不是事先计划好的，无论是当初去到深圳，离开深圳，还是再次去上海，我都没有明确的规划。只是刚好有什么东西在推着我，好吧，去那里看看吧，去那里也不差。\n\n二〇二三年的下半年，七月到十二月，时间过得很快。自己又回到了之前那个，周一至周五，挤地铁上班，写代码，周末以及下班回家写写个人项目，或是玩一玩游戏的生活状态。和友人开玩笑，如果周末一直宅在家里，甚至都没有自己是生活在上海的感知，很多大体上的事情都和深圳其实差别不大，其他可感知的区别可能在于饮食，文化。上海这边每个月都有好多的展览可以逛。\n\n今年自己经历了蛮多的事情的，姥爷的去世其实自己心里早有预期，但还是内心会有些恍惚。因为这不是在看电影，看电影的时候总会安慰自己，一个角色总会在某个时候展现人物弧光和升华。但现实不是拍电影演电影讲故事，现实就是现实，没有来自导演意志的因果叙事逻辑。心里的难过情绪，在姥爷葬礼被我自己压制着的。但这种压抑，会在以后生活中某个不经意的细节，因为某些不经意的片段，会让我突然想到过去一些回忆，然后就突然止不住的，怎么也停不下来的大哭。\n\n> - Wait... what happened?\n> - \\[*sadly*\\] He's been forgotten. When there's no one left in the living world who remembers you, you disappear from this world. We call it the Final Death.\n> - Where did he go?\n> - No one knows.\n>\n> -- Coco\n\n我忽然理解，为什么侯孝贤导演安排聂隐娘哭泣的时候，需要用布遮住面部。\n\n以下是按照惯例的盘点内容。\n\n## 游戏\n\n### PlayStation\n\n- The Last of Us™ Part II Remastered - 2023.01.30\n- Baldur's Gate 3 - 109 hours\n- It Takes Two\n\n### Switch\n\n- Splatoon™ 3\n- ゼルダの伝説 ティアーズ オブ ザ キングダム\n- Persona 4 Golden\n\n二月末三月初离职的那段时间，自己每天一边打包行李，一边把 The Last of Us™ Part II 通关了。这部作品在网络上有着很大的争议，但我总想，一部游戏，至少需要我亲自玩过，我才有资格去评价它。 The Last of Us Part I 主题是很普世价值的「爱」，讲 Joel 和 Ellie 在末世之中，从相互陌生到互相信任，这个叙事逻辑是安全的，玩家也很容易接受。Part II 的主题却是「恨」。它在叙事上走得太超前了，至少我在玩过以后，我认为它是目前迄今为止在玩过的所有游戏中，叙事最超前最先锋的。我始终认为，不管是听音乐的听众，还是看电影的观众，或是玩游戏的玩家，审美品味都是需要一点一点训练和培养的。几十年前的电影观众可能还只是陶醉在正反对立的二元叙事语境，然后电影叙事在不断进化，开始模糊，反讽，辩证，蒙太奇。观众在这个过程也是在不断地训练和品鉴。我认为作为第九艺术的游戏也是这样。The Last of Us Part II 遭受的巨大争议，专业媒体评论者和普通玩家的巨大分歧，是大多数玩家思考游戏叙事还停留在「勇者斗恶龙」的体系下。\n\nThe Last of Us Part II 的双线视角叙事，真的只有亲自玩过才能体会游戏和电影不同媒介叙事的巨大差异。电影始终是以第三者的角度去审视故事，而游戏需要玩家去交互，去操作，去亲自做出选择。强制完全控制带入一个陌生的，让很多人第一眼开始就讨厌的角色，是很困难的。我自己也是，所以我在第一次控制 Abby 的时候，故意让她摔下悬崖好几次。等到玩完整个 Abby 线的时候，我对 Abby 的看法已经改变了好多，这种体会，亲自游玩和在网络上看别人剪辑过的游玩过程会有很大区别，因为当你亲自游玩时，你会在很多地方卡关，你控制 Abby 角色会一遍遍的死亡重新来过，这些内容都会慢慢消解对于 Abby 角色的恨。而如果是在网络上看别人游玩，因为是剪辑过的内容，就没有这种感受了。\n\n<img src=\"first-game.jpg\" width=\"300px\" style=\"display: block;margin: 0 auto;\">\n\nPersona 4 Golden 中能看出很多 P5 的影子，有几首音乐特别好听，另外就是「久慈川理世」这个角色设定太有魅力了。\n\n五月份自己心心念念的 『ゼルダの伝説 ティアーズ オブ ザ キングダム』（ 薩爾達傳說 王國之淚 ）发售了。有两周的时间，自己除了吃饭就是在玩塞尔达。很多人评论这一作神庙的谜题难度降低了，但其实我想一个原因是这作的能力「通天术」和「倒转乾坤」相比上一部都强了不少，另外就是这一作把很多的谜题都设置在了大地图上。我现在还能记得自己不看攻略再一次成功抵达迷雾森林，推理出格鲁德小镇的壁画谜题。半夜两三点，自己躺在被窝中，摸着黑下到地底，朝着远处的一个光亮一点点探索，那种对整片海拉鲁大陆熟悉又陌生，每处地方都能激发出很强的探索欲，这样的感受是很难得的。\n\n![zelda](zelda.png)\n\n八月份的时候大家都开始讨论 Baldur's Gate 3，都在讲它太惊艳了。我是等到十月份才开始玩这款游戏。CRPG 的游戏是有一定的门槛，有很多的专业术语，眼花缭乱的技能设定，专项，魔法，机制等等。好在游戏的引导设计足够好，了解这些内容并不会很吃力。目前我 Baldur's Gate 3 玩了 109 个小时，进度还停留在一周目的第三章。我理解这游戏好玩的点在哪，但是因为剧情自由度太高了，总是不经意就错过好多内容。（ 一周目因为第一章没有招威尔入队，导致丢失了后面所有的威尔相关剧情 ）。\n\n## 音乐\n\n今年听到的好听的音乐依旧大多数来自于游戏原声（ 因为今年依旧看很少的电影 ）\n\n[Replay 2023 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2023/pl.rp-kDD5sedLQbl)\n\n- Song of Balduran - Borislav Slavov\n- Can't Take My Eyes Off You - Joytastic Sarah\n- SNOWFLAKES ( powder snow mix ) - Shihoko Hirata\n\n## 电影\n\n- 『天国大魔境』\n- 『名侦探柯南：黑铁的鱼影』\n\n『天国大魔境』，动漫和漫画都强烈推荐，叙述性诡计，伏笔布局都相当精彩。\n\n六月份的时候由于太过焦虑，花了一周的时间，就重新把整部『柯南』漫画重新看了一遍。我对这部作品有着很强的情感滤镜，因为小时候真的特别特别喜欢。现在随着阅历的加深，我也很清楚这部作品叙事还是人物塑造上存在的问题，但有时候关注一些相关的内容，**会有一种逃离现实的安全感**。\n\n另外值得一提的是，终于搞定了 Netflix 订阅，之前付款总是失败，然后今年不清楚又试了一次竟然就付款成功了。目前在 Netflix 只是补了 『黑镜』。\n\n## 书\n\n又是没怎么系统性看完完整一本书的一年（ 想到了 2021 年 ）。去年闲暇时开始看『金瓶梅』，只是看了前二十个章节。又重新去读村上的『一九七三年弹子球』也是读到一半，没有读完。\n\n技术类书籍也没怎么去读，不过倒是看了不少 third library 的源码，web 和 iOS 都有包括。\n\n## 时刻\n\n今年很多值得铭记的时刻，是自己花了很大精力解决了一些技术难题，包括但不限于\n\n- iOS Page Sheet 多段式动画实现\n- twitter-like profile page ( tabs with sticky header )\n- Transition Component in React\n- fragment shader 实现无限网格\n- Infinite canvas, zooming and dragging\n- 3d line geometry 优化 ( 更少的 vertices )\n\n### 推导 Quaternion\n\n花了一个晚上的时间，按照论文上的步骤，一步一步在 iPad 手写演算进行推导。其中涉及到了一些点乘，叉乘的化简运算，叉乘运算又极其繁琐，加之论文其实省略了一些推导步骤的。不过好在自己最后算对了，算出结果那一刻真的好开心，又感叹发明 Quaternion 来进行 3d 旋转运算的人，真的好厉害！\n\n### 拯救暗夜之歌\n\n我认为 Baldur‘s Gate 3 整个第二章都特别精彩，高潮部分在「拯救暗夜之歌」，演出相当震撼。\n\n### 横宮七海\n\nR.I.P.\n\n可能是大多数人都不怎么认识和关注的一个人，但是看到消息还是感到很难过。更残酷的是，商业上并不会因为一个人的身故而停止发售她生前已经拍好的作品。\n\n# 结语\n\n新的城市，新的工作，新的同事。对未来没有太多期许。每周二或周三工作日的晚上去打一场篮球，大汗淋漓之后喝上一杯冰镇的可乐。回到家里再冲上一个热水澡。生活相比以前，有了一些细微的改变。我不清楚，也不去想，不去期许五年十年后的事情，仅以这些文字，纪念即将过去的二〇二三。\n\n\n\n🌻\n","source":"_posts/2023-summary.md","raw":"---\ntitle: 『別れの予感』\ndate: 2023-12-30 11:46:14\ntags:\n- 电影\n- 游戏\n- 音乐\ncategories: 'I/O'\n---\n\n今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。\n\n> 「说到邓丽君的代表作」\n> 「很多粉丝会说〈何日君再来〉」\n> 「〈再见我的爱人〉或〈我只在乎你〉」\n> 「不瞒大家，其实我最喜欢这首」\n> \\- 老爸啊，到底想干什么呢？\n> \\- 干什么？\n> 「请听邓丽君的〈别离的预感〉」\n> \\- 他自己的人生啊\n> \\- 我不知道，到最后还是搞不懂他\n> \\- 他很多事无法心想事成吧，都怪时代不好\n> \\- 他把自己的缺点都怪在时代上\n> \\- 你干嘛感慨良多\n> \\- 没有\n> \\- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。\n> \\- 我知道\n> \\- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐\n> \\- 也许吧\n> \\- 其实幸福这种东西，没有牺牲就无法入手\n> 「比海还深，比天还蓝」\n> \\- 我到这把年纪了，还没有爱过谁比海还深的\n> \\- 别说这种孤僻话\n> \\- 你有吗？\n> \\- 我？\n> \\- 还算有吧\n> \\- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐\n> \\- 真复杂\n> \\- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊\n> \\- 不用啦  - 不然会忘记的\n> \\- 不用抄啦，我记住了\n> \n> \\-\\- 『比海更深』\n\n<!--more-->\n\n## 「死亡是一种解脱」\n\n「死亡是一种解脱」，是炉石传说中 Lord Godfrey 高弗雷勋爵的登场语音，尽管炉石传说已经退出中国一年了，可是我时常会想起这句话。以及，还时常在微博上检索「离灯_冬眠mode关闭失败」这个关键词。\n\n姥爷是三月份离开的。准确的时间是二〇二三年三月十七日。我是三月十日离开的深圳。\n\n决定离开深圳，对自己而言并没有花太多时间。当时二月底离职，房屋面临到期，继续待下去，无疑要面对一边要找工作，一边要找房子的处境。姥爷从去年开始身体一直都不是很好， 二〇二二年底放开之后，又得了一次新冠，从那开始就一直卧病在床。\n\n二〇一九年三月份来的深圳，在深圳待了有四年，下决定离开不过是一瞬间的事情。在网上购买几个大号的打包箱，胶带，泡沫。花一周的时间，把行李一点一点的寄回家。上一次这样做，还是二〇一六年大学毕业的时候。订了三月十日的机票，确定衣物啊，显示器啊，游戏机啊这些都寄走准备完毕，三月十日那天很早起床，收拾房间，背起背包，和室友在微信上说明原因并告别，然后一个人返乡。\n\n回到家的第二天，我和妈妈回老家农村去照顾姥爷。那个时候，姥爷整日都只能躺在床上，床被放置在了客厅，上面盖了两层棉被，旁边开着电热风扇。三月份，农村依然很冷。那天我回到老家，姥爷咳嗽得厉害，我问姥爷是不是嘴里有痰，想吐出来，姥爷睁大眼睛看着我，然后摇摇头。姥爷以前就是这样，不太喜欢给我们小辈找麻烦，什么事情他都要亲力亲为。那天我看到姥爷的眼神，我很清楚，姥爷什么都明白，什么都知道，只是没有力气，声音沙哑说不上话，也坐不起来。我和妈妈从三月十日待到了三月十五日。每晚我妈妈都是睡在姥爷旁别小床上，我舅舅睡在里屋的一个小硬板床上，两个人轮班照顾。那个小床后来我也睡了一晚，整晚都能听到姥爷咳嗽的声音，半夜两三点的时候，我听到姥姥也起来了，姥姥心疼不下姥爷一直咳嗽难受的样子，半夜起来看望姥爷，问姥爷哪里难受，帮姥爷揉肚子。两位老人都八十多岁了，那一晚我躺在偏里屋的小床上，整晚都没睡着，心里很难过。\n\n**有时候，你会特别惧怕明天到来。**\n\n姥爷的葬礼持续了三天，农村，红白喜事都特别复杂。葬礼结束那天我开始发烧。发烧持续了四天才好，那几天我一直在睡觉，做各种各样光怪陆离，魑魅魍魉的梦。\n\n## 2018 vs 2023\n\n2018 年我刚从德国回来的时候，计划着转行，也没有着急出去找工作，那会儿一整年都在家，看电影，打篮球，看书，写代码。\n\n2023 年离开深圳再次回到家乡，熟悉的场景有些相似，又有些不同。只能说我对这种 gap year 的处境驾轻就熟，有着足够的经验去应对。之后的整个四月一直到五月中旬，自己的大部分时间都投入到了自己的个人项目中，偶尔时间出去打打篮球，偶尔放松的时候玩几局 splatoon，zelda: tears of the kingdom。\n\n当你花上一周时间，解决了一些技术难题，把心中的想法实现出来的时候，不工作的焦虑感也会稍微消解，但这种消解总是暂时的，焦虑感却总会随着时间的推移越来越大。每晚都要熬到两三点钟才能睡着，在 live stream 中看几局 splatoon，有次还不小心听到某位 splatoon steamer 抱怨已经很久都没有去工作了。\n\n## Bump Version\n\n七月初面试确定，然后决定动身前往上海。\n\n在家里待了接近四个月，经历了「清明」，「五一」，「端午」，线上观看了六月份 Apple WWDC，去了一次北京。\n\n宝可梦系列中，小智每次在前往下一个新的区域的时候，都只是带上皮卡丘，把其他的宝可梦留在家里。\n\n![rye](rye.jpeg)\n\n决定动身前往上海，做一次超大规模的「断舍离」，只带上一些必要的生活用品，电脑，平板，不必要的物件都暂时安置在家中。这样的场景，像极了购买了一款游戏续作，主角还是前作的主角，没有改变，只是这一次需要前往崭新的区域去冒险，去面对此前没有见过的，新的敌人。\n\n在上海确定好工作事宜，花上周末两天时间去医院做体检，找房子。网络上下单必备的生活用品，纸巾，洗衣液，衣撑，枕芯等等。一切安置妥当不需要花太久的时间。晚间时分在住的地方附近逛一逛，熟悉一下周边的环境和风景。我在 IM 软件中联系在上海的同学，告诉他们我从深圳换到上海这边工作了，有时间可以出来见一面，叙叙旧。\n\n自己以前总是对未来有着明确的期许，有着可能划分到每一天的明确的计划。但我现在不这样，很多事情并不是事先计划好的，无论是当初去到深圳，离开深圳，还是再次去上海，我都没有明确的规划。只是刚好有什么东西在推着我，好吧，去那里看看吧，去那里也不差。\n\n二〇二三年的下半年，七月到十二月，时间过得很快。自己又回到了之前那个，周一至周五，挤地铁上班，写代码，周末以及下班回家写写个人项目，或是玩一玩游戏的生活状态。和友人开玩笑，如果周末一直宅在家里，甚至都没有自己是生活在上海的感知，很多大体上的事情都和深圳其实差别不大，其他可感知的区别可能在于饮食，文化。上海这边每个月都有好多的展览可以逛。\n\n今年自己经历了蛮多的事情的，姥爷的去世其实自己心里早有预期，但还是内心会有些恍惚。因为这不是在看电影，看电影的时候总会安慰自己，一个角色总会在某个时候展现人物弧光和升华。但现实不是拍电影演电影讲故事，现实就是现实，没有来自导演意志的因果叙事逻辑。心里的难过情绪，在姥爷葬礼被我自己压制着的。但这种压抑，会在以后生活中某个不经意的细节，因为某些不经意的片段，会让我突然想到过去一些回忆，然后就突然止不住的，怎么也停不下来的大哭。\n\n> - Wait... what happened?\n> - \\[*sadly*\\] He's been forgotten. When there's no one left in the living world who remembers you, you disappear from this world. We call it the Final Death.\n> - Where did he go?\n> - No one knows.\n>\n> -- Coco\n\n我忽然理解，为什么侯孝贤导演安排聂隐娘哭泣的时候，需要用布遮住面部。\n\n以下是按照惯例的盘点内容。\n\n## 游戏\n\n### PlayStation\n\n- The Last of Us™ Part II Remastered - 2023.01.30\n- Baldur's Gate 3 - 109 hours\n- It Takes Two\n\n### Switch\n\n- Splatoon™ 3\n- ゼルダの伝説 ティアーズ オブ ザ キングダム\n- Persona 4 Golden\n\n二月末三月初离职的那段时间，自己每天一边打包行李，一边把 The Last of Us™ Part II 通关了。这部作品在网络上有着很大的争议，但我总想，一部游戏，至少需要我亲自玩过，我才有资格去评价它。 The Last of Us Part I 主题是很普世价值的「爱」，讲 Joel 和 Ellie 在末世之中，从相互陌生到互相信任，这个叙事逻辑是安全的，玩家也很容易接受。Part II 的主题却是「恨」。它在叙事上走得太超前了，至少我在玩过以后，我认为它是目前迄今为止在玩过的所有游戏中，叙事最超前最先锋的。我始终认为，不管是听音乐的听众，还是看电影的观众，或是玩游戏的玩家，审美品味都是需要一点一点训练和培养的。几十年前的电影观众可能还只是陶醉在正反对立的二元叙事语境，然后电影叙事在不断进化，开始模糊，反讽，辩证，蒙太奇。观众在这个过程也是在不断地训练和品鉴。我认为作为第九艺术的游戏也是这样。The Last of Us Part II 遭受的巨大争议，专业媒体评论者和普通玩家的巨大分歧，是大多数玩家思考游戏叙事还停留在「勇者斗恶龙」的体系下。\n\nThe Last of Us Part II 的双线视角叙事，真的只有亲自玩过才能体会游戏和电影不同媒介叙事的巨大差异。电影始终是以第三者的角度去审视故事，而游戏需要玩家去交互，去操作，去亲自做出选择。强制完全控制带入一个陌生的，让很多人第一眼开始就讨厌的角色，是很困难的。我自己也是，所以我在第一次控制 Abby 的时候，故意让她摔下悬崖好几次。等到玩完整个 Abby 线的时候，我对 Abby 的看法已经改变了好多，这种体会，亲自游玩和在网络上看别人剪辑过的游玩过程会有很大区别，因为当你亲自游玩时，你会在很多地方卡关，你控制 Abby 角色会一遍遍的死亡重新来过，这些内容都会慢慢消解对于 Abby 角色的恨。而如果是在网络上看别人游玩，因为是剪辑过的内容，就没有这种感受了。\n\n<img src=\"first-game.jpg\" width=\"300px\" style=\"display: block;margin: 0 auto;\">\n\nPersona 4 Golden 中能看出很多 P5 的影子，有几首音乐特别好听，另外就是「久慈川理世」这个角色设定太有魅力了。\n\n五月份自己心心念念的 『ゼルダの伝説 ティアーズ オブ ザ キングダム』（ 薩爾達傳說 王國之淚 ）发售了。有两周的时间，自己除了吃饭就是在玩塞尔达。很多人评论这一作神庙的谜题难度降低了，但其实我想一个原因是这作的能力「通天术」和「倒转乾坤」相比上一部都强了不少，另外就是这一作把很多的谜题都设置在了大地图上。我现在还能记得自己不看攻略再一次成功抵达迷雾森林，推理出格鲁德小镇的壁画谜题。半夜两三点，自己躺在被窝中，摸着黑下到地底，朝着远处的一个光亮一点点探索，那种对整片海拉鲁大陆熟悉又陌生，每处地方都能激发出很强的探索欲，这样的感受是很难得的。\n\n![zelda](zelda.png)\n\n八月份的时候大家都开始讨论 Baldur's Gate 3，都在讲它太惊艳了。我是等到十月份才开始玩这款游戏。CRPG 的游戏是有一定的门槛，有很多的专业术语，眼花缭乱的技能设定，专项，魔法，机制等等。好在游戏的引导设计足够好，了解这些内容并不会很吃力。目前我 Baldur's Gate 3 玩了 109 个小时，进度还停留在一周目的第三章。我理解这游戏好玩的点在哪，但是因为剧情自由度太高了，总是不经意就错过好多内容。（ 一周目因为第一章没有招威尔入队，导致丢失了后面所有的威尔相关剧情 ）。\n\n## 音乐\n\n今年听到的好听的音乐依旧大多数来自于游戏原声（ 因为今年依旧看很少的电影 ）\n\n[Replay 2023 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2023/pl.rp-kDD5sedLQbl)\n\n- Song of Balduran - Borislav Slavov\n- Can't Take My Eyes Off You - Joytastic Sarah\n- SNOWFLAKES ( powder snow mix ) - Shihoko Hirata\n\n## 电影\n\n- 『天国大魔境』\n- 『名侦探柯南：黑铁的鱼影』\n\n『天国大魔境』，动漫和漫画都强烈推荐，叙述性诡计，伏笔布局都相当精彩。\n\n六月份的时候由于太过焦虑，花了一周的时间，就重新把整部『柯南』漫画重新看了一遍。我对这部作品有着很强的情感滤镜，因为小时候真的特别特别喜欢。现在随着阅历的加深，我也很清楚这部作品叙事还是人物塑造上存在的问题，但有时候关注一些相关的内容，**会有一种逃离现实的安全感**。\n\n另外值得一提的是，终于搞定了 Netflix 订阅，之前付款总是失败，然后今年不清楚又试了一次竟然就付款成功了。目前在 Netflix 只是补了 『黑镜』。\n\n## 书\n\n又是没怎么系统性看完完整一本书的一年（ 想到了 2021 年 ）。去年闲暇时开始看『金瓶梅』，只是看了前二十个章节。又重新去读村上的『一九七三年弹子球』也是读到一半，没有读完。\n\n技术类书籍也没怎么去读，不过倒是看了不少 third library 的源码，web 和 iOS 都有包括。\n\n## 时刻\n\n今年很多值得铭记的时刻，是自己花了很大精力解决了一些技术难题，包括但不限于\n\n- iOS Page Sheet 多段式动画实现\n- twitter-like profile page ( tabs with sticky header )\n- Transition Component in React\n- fragment shader 实现无限网格\n- Infinite canvas, zooming and dragging\n- 3d line geometry 优化 ( 更少的 vertices )\n\n### 推导 Quaternion\n\n花了一个晚上的时间，按照论文上的步骤，一步一步在 iPad 手写演算进行推导。其中涉及到了一些点乘，叉乘的化简运算，叉乘运算又极其繁琐，加之论文其实省略了一些推导步骤的。不过好在自己最后算对了，算出结果那一刻真的好开心，又感叹发明 Quaternion 来进行 3d 旋转运算的人，真的好厉害！\n\n### 拯救暗夜之歌\n\n我认为 Baldur‘s Gate 3 整个第二章都特别精彩，高潮部分在「拯救暗夜之歌」，演出相当震撼。\n\n### 横宮七海\n\nR.I.P.\n\n可能是大多数人都不怎么认识和关注的一个人，但是看到消息还是感到很难过。更残酷的是，商业上并不会因为一个人的身故而停止发售她生前已经拍好的作品。\n\n# 结语\n\n新的城市，新的工作，新的同事。对未来没有太多期许。每周二或周三工作日的晚上去打一场篮球，大汗淋漓之后喝上一杯冰镇的可乐。回到家里再冲上一个热水澡。生活相比以前，有了一些细微的改变。我不清楚，也不去想，不去期许五年十年后的事情，仅以这些文字，纪念即将过去的二〇二三。\n\n\n\n🌻\n","slug":"2023-summary","published":1,"updated":"2024-02-09T13:15:35.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx210003rg1v7b0fcbqv","content":"<p>今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。</p>\n<blockquote>\n<p>「说到邓丽君的代表作」<br>「很多粉丝会说〈何日君再来〉」<br>「〈再见我的爱人〉或〈我只在乎你〉」<br>「不瞒大家，其实我最喜欢这首」<br>- 老爸啊，到底想干什么呢？<br>- 干什么？<br>「请听邓丽君的〈别离的预感〉」<br>- 他自己的人生啊<br>- 我不知道，到最后还是搞不懂他<br>- 他很多事无法心想事成吧，都怪时代不好<br>- 他把自己的缺点都怪在时代上<br>- 你干嘛感慨良多<br>- 没有<br>- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。<br>- 我知道<br>- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐<br>- 也许吧<br>- 其实幸福这种东西，没有牺牲就无法入手<br>「比海还深，比天还蓝」<br>- 我到这把年纪了，还没有爱过谁比海还深的<br>- 别说这种孤僻话<br>- 你有吗？<br>- 我？<br>- 还算有吧<br>- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐<br>- 真复杂<br>- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊<br>- 不用啦  - 不然会忘记的<br>- 不用抄啦，我记住了</p>\n<p>-- 『比海更深』</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"「死亡是一种解脱」\"><a href=\"#「死亡是一种解脱」\" class=\"headerlink\" title=\"「死亡是一种解脱」\"></a>「死亡是一种解脱」</h2><p>「死亡是一种解脱」，是炉石传说中 Lord Godfrey 高弗雷勋爵的登场语音，尽管炉石传说已经退出中国一年了，可是我时常会想起这句话。以及，还时常在微博上检索「离灯_冬眠mode关闭失败」这个关键词。</p>\n<p>姥爷是三月份离开的。准确的时间是二〇二三年三月十七日。我是三月十日离开的深圳。</p>\n<p>决定离开深圳，对自己而言并没有花太多时间。当时二月底离职，房屋面临到期，继续待下去，无疑要面对一边要找工作，一边要找房子的处境。姥爷从去年开始身体一直都不是很好， 二〇二二年底放开之后，又得了一次新冠，从那开始就一直卧病在床。</p>\n<p>二〇一九年三月份来的深圳，在深圳待了有四年，下决定离开不过是一瞬间的事情。在网上购买几个大号的打包箱，胶带，泡沫。花一周的时间，把行李一点一点的寄回家。上一次这样做，还是二〇一六年大学毕业的时候。订了三月十日的机票，确定衣物啊，显示器啊，游戏机啊这些都寄走准备完毕，三月十日那天很早起床，收拾房间，背起背包，和室友在微信上说明原因并告别，然后一个人返乡。</p>\n<p>回到家的第二天，我和妈妈回老家农村去照顾姥爷。那个时候，姥爷整日都只能躺在床上，床被放置在了客厅，上面盖了两层棉被，旁边开着电热风扇。三月份，农村依然很冷。那天我回到老家，姥爷咳嗽得厉害，我问姥爷是不是嘴里有痰，想吐出来，姥爷睁大眼睛看着我，然后摇摇头。姥爷以前就是这样，不太喜欢给我们小辈找麻烦，什么事情他都要亲力亲为。那天我看到姥爷的眼神，我很清楚，姥爷什么都明白，什么都知道，只是没有力气，声音沙哑说不上话，也坐不起来。我和妈妈从三月十日待到了三月十五日。每晚我妈妈都是睡在姥爷旁别小床上，我舅舅睡在里屋的一个小硬板床上，两个人轮班照顾。那个小床后来我也睡了一晚，整晚都能听到姥爷咳嗽的声音，半夜两三点的时候，我听到姥姥也起来了，姥姥心疼不下姥爷一直咳嗽难受的样子，半夜起来看望姥爷，问姥爷哪里难受，帮姥爷揉肚子。两位老人都八十多岁了，那一晚我躺在偏里屋的小床上，整晚都没睡着，心里很难过。</p>\n<p><strong>有时候，你会特别惧怕明天到来。</strong></p>\n<p>姥爷的葬礼持续了三天，农村，红白喜事都特别复杂。葬礼结束那天我开始发烧。发烧持续了四天才好，那几天我一直在睡觉，做各种各样光怪陆离，魑魅魍魉的梦。</p>\n<h2 id=\"2018-vs-2023\"><a href=\"#2018-vs-2023\" class=\"headerlink\" title=\"2018 vs 2023\"></a>2018 vs 2023</h2><p>2018 年我刚从德国回来的时候，计划着转行，也没有着急出去找工作，那会儿一整年都在家，看电影，打篮球，看书，写代码。</p>\n<p>2023 年离开深圳再次回到家乡，熟悉的场景有些相似，又有些不同。只能说我对这种 gap year 的处境驾轻就熟，有着足够的经验去应对。之后的整个四月一直到五月中旬，自己的大部分时间都投入到了自己的个人项目中，偶尔时间出去打打篮球，偶尔放松的时候玩几局 splatoon，zelda: tears of the kingdom。</p>\n<p>当你花上一周时间，解决了一些技术难题，把心中的想法实现出来的时候，不工作的焦虑感也会稍微消解，但这种消解总是暂时的，焦虑感却总会随着时间的推移越来越大。每晚都要熬到两三点钟才能睡着，在 live stream 中看几局 splatoon，有次还不小心听到某位 splatoon steamer 抱怨已经很久都没有去工作了。</p>\n<h2 id=\"Bump-Version\"><a href=\"#Bump-Version\" class=\"headerlink\" title=\"Bump Version\"></a>Bump Version</h2><p>七月初面试确定，然后决定动身前往上海。</p>\n<p>在家里待了接近四个月，经历了「清明」，「五一」，「端午」，线上观看了六月份 Apple WWDC，去了一次北京。</p>\n<p>宝可梦系列中，小智每次在前往下一个新的区域的时候，都只是带上皮卡丘，把其他的宝可梦留在家里。</p>\n<p><img src=\"rye.jpeg\" alt=\"rye\"></p>\n<p>决定动身前往上海，做一次超大规模的「断舍离」，只带上一些必要的生活用品，电脑，平板，不必要的物件都暂时安置在家中。这样的场景，像极了购买了一款游戏续作，主角还是前作的主角，没有改变，只是这一次需要前往崭新的区域去冒险，去面对此前没有见过的，新的敌人。</p>\n<p>在上海确定好工作事宜，花上周末两天时间去医院做体检，找房子。网络上下单必备的生活用品，纸巾，洗衣液，衣撑，枕芯等等。一切安置妥当不需要花太久的时间。晚间时分在住的地方附近逛一逛，熟悉一下周边的环境和风景。我在 IM 软件中联系在上海的同学，告诉他们我从深圳换到上海这边工作了，有时间可以出来见一面，叙叙旧。</p>\n<p>自己以前总是对未来有着明确的期许，有着可能划分到每一天的明确的计划。但我现在不这样，很多事情并不是事先计划好的，无论是当初去到深圳，离开深圳，还是再次去上海，我都没有明确的规划。只是刚好有什么东西在推着我，好吧，去那里看看吧，去那里也不差。</p>\n<p>二〇二三年的下半年，七月到十二月，时间过得很快。自己又回到了之前那个，周一至周五，挤地铁上班，写代码，周末以及下班回家写写个人项目，或是玩一玩游戏的生活状态。和友人开玩笑，如果周末一直宅在家里，甚至都没有自己是生活在上海的感知，很多大体上的事情都和深圳其实差别不大，其他可感知的区别可能在于饮食，文化。上海这边每个月都有好多的展览可以逛。</p>\n<p>今年自己经历了蛮多的事情的，姥爷的去世其实自己心里早有预期，但还是内心会有些恍惚。因为这不是在看电影，看电影的时候总会安慰自己，一个角色总会在某个时候展现人物弧光和升华。但现实不是拍电影演电影讲故事，现实就是现实，没有来自导演意志的因果叙事逻辑。心里的难过情绪，在姥爷葬礼被我自己压制着的。但这种压抑，会在以后生活中某个不经意的细节，因为某些不经意的片段，会让我突然想到过去一些回忆，然后就突然止不住的，怎么也停不下来的大哭。</p>\n<blockquote>\n<ul>\n<li>Wait… what happened?</li>\n<li>[<em>sadly</em>] He’s been forgotten. When there’s no one left in the living world who remembers you, you disappear from this world. We call it the Final Death.</li>\n<li>Where did he go?</li>\n<li>No one knows.</li>\n</ul>\n<p>– Coco</p>\n</blockquote>\n<p>我忽然理解，为什么侯孝贤导演安排聂隐娘哭泣的时候，需要用布遮住面部。</p>\n<p>以下是按照惯例的盘点内容。</p>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><h3 id=\"PlayStation\"><a href=\"#PlayStation\" class=\"headerlink\" title=\"PlayStation\"></a>PlayStation</h3><ul>\n<li>The Last of Us™ Part II Remastered - 2023.01.30</li>\n<li>Baldur’s Gate 3 - 109 hours</li>\n<li>It Takes Two</li>\n</ul>\n<h3 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h3><ul>\n<li>Splatoon™ 3</li>\n<li>ゼルダの伝説 ティアーズ オブ ザ キングダム</li>\n<li>Persona 4 Golden</li>\n</ul>\n<p>二月末三月初离职的那段时间，自己每天一边打包行李，一边把 The Last of Us™ Part II 通关了。这部作品在网络上有着很大的争议，但我总想，一部游戏，至少需要我亲自玩过，我才有资格去评价它。 The Last of Us Part I 主题是很普世价值的「爱」，讲 Joel 和 Ellie 在末世之中，从相互陌生到互相信任，这个叙事逻辑是安全的，玩家也很容易接受。Part II 的主题却是「恨」。它在叙事上走得太超前了，至少我在玩过以后，我认为它是目前迄今为止在玩过的所有游戏中，叙事最超前最先锋的。我始终认为，不管是听音乐的听众，还是看电影的观众，或是玩游戏的玩家，审美品味都是需要一点一点训练和培养的。几十年前的电影观众可能还只是陶醉在正反对立的二元叙事语境，然后电影叙事在不断进化，开始模糊，反讽，辩证，蒙太奇。观众在这个过程也是在不断地训练和品鉴。我认为作为第九艺术的游戏也是这样。The Last of Us Part II 遭受的巨大争议，专业媒体评论者和普通玩家的巨大分歧，是大多数玩家思考游戏叙事还停留在「勇者斗恶龙」的体系下。</p>\n<p>The Last of Us Part II 的双线视角叙事，真的只有亲自玩过才能体会游戏和电影不同媒介叙事的巨大差异。电影始终是以第三者的角度去审视故事，而游戏需要玩家去交互，去操作，去亲自做出选择。强制完全控制带入一个陌生的，让很多人第一眼开始就讨厌的角色，是很困难的。我自己也是，所以我在第一次控制 Abby 的时候，故意让她摔下悬崖好几次。等到玩完整个 Abby 线的时候，我对 Abby 的看法已经改变了好多，这种体会，亲自游玩和在网络上看别人剪辑过的游玩过程会有很大区别，因为当你亲自游玩时，你会在很多地方卡关，你控制 Abby 角色会一遍遍的死亡重新来过，这些内容都会慢慢消解对于 Abby 角色的恨。而如果是在网络上看别人游玩，因为是剪辑过的内容，就没有这种感受了。</p>\n<img src=\"first-game.jpg\" width=\"300px\" style=\"display: block;margin: 0 auto;\">\n\n<p>Persona 4 Golden 中能看出很多 P5 的影子，有几首音乐特别好听，另外就是「久慈川理世」这个角色设定太有魅力了。</p>\n<p>五月份自己心心念念的 『ゼルダの伝説 ティアーズ オブ ザ キングダム』（ 薩爾達傳說 王國之淚 ）发售了。有两周的时间，自己除了吃饭就是在玩塞尔达。很多人评论这一作神庙的谜题难度降低了，但其实我想一个原因是这作的能力「通天术」和「倒转乾坤」相比上一部都强了不少，另外就是这一作把很多的谜题都设置在了大地图上。我现在还能记得自己不看攻略再一次成功抵达迷雾森林，推理出格鲁德小镇的壁画谜题。半夜两三点，自己躺在被窝中，摸着黑下到地底，朝着远处的一个光亮一点点探索，那种对整片海拉鲁大陆熟悉又陌生，每处地方都能激发出很强的探索欲，这样的感受是很难得的。</p>\n<p><img src=\"zelda.png\" alt=\"zelda\"></p>\n<p>八月份的时候大家都开始讨论 Baldur’s Gate 3，都在讲它太惊艳了。我是等到十月份才开始玩这款游戏。CRPG 的游戏是有一定的门槛，有很多的专业术语，眼花缭乱的技能设定，专项，魔法，机制等等。好在游戏的引导设计足够好，了解这些内容并不会很吃力。目前我 Baldur’s Gate 3 玩了 109 个小时，进度还停留在一周目的第三章。我理解这游戏好玩的点在哪，但是因为剧情自由度太高了，总是不经意就错过好多内容。（ 一周目因为第一章没有招威尔入队，导致丢失了后面所有的威尔相关剧情 ）。</p>\n<h2 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h2><p>今年听到的好听的音乐依旧大多数来自于游戏原声（ 因为今年依旧看很少的电影 ）</p>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2023/pl.rp-kDD5sedLQbl\">Replay 2023 - Apple Music for Reyshawn</a></p>\n<ul>\n<li>Song of Balduran - Borislav Slavov</li>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>SNOWFLAKES ( powder snow mix ) - Shihoko Hirata</li>\n</ul>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><ul>\n<li>『天国大魔境』</li>\n<li>『名侦探柯南：黑铁的鱼影』</li>\n</ul>\n<p>『天国大魔境』，动漫和漫画都强烈推荐，叙述性诡计，伏笔布局都相当精彩。</p>\n<p>六月份的时候由于太过焦虑，花了一周的时间，就重新把整部『柯南』漫画重新看了一遍。我对这部作品有着很强的情感滤镜，因为小时候真的特别特别喜欢。现在随着阅历的加深，我也很清楚这部作品叙事还是人物塑造上存在的问题，但有时候关注一些相关的内容，<strong>会有一种逃离现实的安全感</strong>。</p>\n<p>另外值得一提的是，终于搞定了 Netflix 订阅，之前付款总是失败，然后今年不清楚又试了一次竟然就付款成功了。目前在 Netflix 只是补了 『黑镜』。</p>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><p>又是没怎么系统性看完完整一本书的一年（ 想到了 2021 年 ）。去年闲暇时开始看『金瓶梅』，只是看了前二十个章节。又重新去读村上的『一九七三年弹子球』也是读到一半，没有读完。</p>\n<p>技术类书籍也没怎么去读，不过倒是看了不少 third library 的源码，web 和 iOS 都有包括。</p>\n<h2 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h2><p>今年很多值得铭记的时刻，是自己花了很大精力解决了一些技术难题，包括但不限于</p>\n<ul>\n<li>iOS Page Sheet 多段式动画实现</li>\n<li>twitter-like profile page ( tabs with sticky header )</li>\n<li>Transition Component in React</li>\n<li>fragment shader 实现无限网格</li>\n<li>Infinite canvas, zooming and dragging</li>\n<li>3d line geometry 优化 ( 更少的 vertices )</li>\n</ul>\n<h3 id=\"推导-Quaternion\"><a href=\"#推导-Quaternion\" class=\"headerlink\" title=\"推导 Quaternion\"></a>推导 Quaternion</h3><p>花了一个晚上的时间，按照论文上的步骤，一步一步在 iPad 手写演算进行推导。其中涉及到了一些点乘，叉乘的化简运算，叉乘运算又极其繁琐，加之论文其实省略了一些推导步骤的。不过好在自己最后算对了，算出结果那一刻真的好开心，又感叹发明 Quaternion 来进行 3d 旋转运算的人，真的好厉害！</p>\n<h3 id=\"拯救暗夜之歌\"><a href=\"#拯救暗夜之歌\" class=\"headerlink\" title=\"拯救暗夜之歌\"></a>拯救暗夜之歌</h3><p>我认为 Baldur‘s Gate 3 整个第二章都特别精彩，高潮部分在「拯救暗夜之歌」，演出相当震撼。</p>\n<h3 id=\"横宮七海\"><a href=\"#横宮七海\" class=\"headerlink\" title=\"横宮七海\"></a>横宮七海</h3><p>R.I.P.</p>\n<p>可能是大多数人都不怎么认识和关注的一个人，但是看到消息还是感到很难过。更残酷的是，商业上并不会因为一个人的身故而停止发售她生前已经拍好的作品。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>新的城市，新的工作，新的同事。对未来没有太多期许。每周二或周三工作日的晚上去打一场篮球，大汗淋漓之后喝上一杯冰镇的可乐。回到家里再冲上一个热水澡。生活相比以前，有了一些细微的改变。我不清楚，也不去想，不去期许五年十年后的事情，仅以这些文字，纪念即将过去的二〇二三。</p>\n<p>🌻</p>\n","site":{"data":{}},"excerpt":"<p>今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。</p>\n<blockquote>\n<p>「说到邓丽君的代表作」<br>「很多粉丝会说〈何日君再来〉」<br>「〈再见我的爱人〉或〈我只在乎你〉」<br>「不瞒大家，其实我最喜欢这首」<br>- 老爸啊，到底想干什么呢？<br>- 干什么？<br>「请听邓丽君的〈别离的预感〉」<br>- 他自己的人生啊<br>- 我不知道，到最后还是搞不懂他<br>- 他很多事无法心想事成吧，都怪时代不好<br>- 他把自己的缺点都怪在时代上<br>- 你干嘛感慨良多<br>- 没有<br>- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。<br>- 我知道<br>- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐<br>- 也许吧<br>- 其实幸福这种东西，没有牺牲就无法入手<br>「比海还深，比天还蓝」<br>- 我到这把年纪了，还没有爱过谁比海还深的<br>- 别说这种孤僻话<br>- 你有吗？<br>- 我？<br>- 还算有吧<br>- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐<br>- 真复杂<br>- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊<br>- 不用啦  - 不然会忘记的<br>- 不用抄啦，我记住了</p>\n<p>-- 『比海更深』</p>\n</blockquote>","more":"<h2 id=\"「死亡是一种解脱」\"><a href=\"#「死亡是一种解脱」\" class=\"headerlink\" title=\"「死亡是一种解脱」\"></a>「死亡是一种解脱」</h2><p>「死亡是一种解脱」，是炉石传说中 Lord Godfrey 高弗雷勋爵的登场语音，尽管炉石传说已经退出中国一年了，可是我时常会想起这句话。以及，还时常在微博上检索「离灯_冬眠mode关闭失败」这个关键词。</p>\n<p>姥爷是三月份离开的。准确的时间是二〇二三年三月十七日。我是三月十日离开的深圳。</p>\n<p>决定离开深圳，对自己而言并没有花太多时间。当时二月底离职，房屋面临到期，继续待下去，无疑要面对一边要找工作，一边要找房子的处境。姥爷从去年开始身体一直都不是很好， 二〇二二年底放开之后，又得了一次新冠，从那开始就一直卧病在床。</p>\n<p>二〇一九年三月份来的深圳，在深圳待了有四年，下决定离开不过是一瞬间的事情。在网上购买几个大号的打包箱，胶带，泡沫。花一周的时间，把行李一点一点的寄回家。上一次这样做，还是二〇一六年大学毕业的时候。订了三月十日的机票，确定衣物啊，显示器啊，游戏机啊这些都寄走准备完毕，三月十日那天很早起床，收拾房间，背起背包，和室友在微信上说明原因并告别，然后一个人返乡。</p>\n<p>回到家的第二天，我和妈妈回老家农村去照顾姥爷。那个时候，姥爷整日都只能躺在床上，床被放置在了客厅，上面盖了两层棉被，旁边开着电热风扇。三月份，农村依然很冷。那天我回到老家，姥爷咳嗽得厉害，我问姥爷是不是嘴里有痰，想吐出来，姥爷睁大眼睛看着我，然后摇摇头。姥爷以前就是这样，不太喜欢给我们小辈找麻烦，什么事情他都要亲力亲为。那天我看到姥爷的眼神，我很清楚，姥爷什么都明白，什么都知道，只是没有力气，声音沙哑说不上话，也坐不起来。我和妈妈从三月十日待到了三月十五日。每晚我妈妈都是睡在姥爷旁别小床上，我舅舅睡在里屋的一个小硬板床上，两个人轮班照顾。那个小床后来我也睡了一晚，整晚都能听到姥爷咳嗽的声音，半夜两三点的时候，我听到姥姥也起来了，姥姥心疼不下姥爷一直咳嗽难受的样子，半夜起来看望姥爷，问姥爷哪里难受，帮姥爷揉肚子。两位老人都八十多岁了，那一晚我躺在偏里屋的小床上，整晚都没睡着，心里很难过。</p>\n<p><strong>有时候，你会特别惧怕明天到来。</strong></p>\n<p>姥爷的葬礼持续了三天，农村，红白喜事都特别复杂。葬礼结束那天我开始发烧。发烧持续了四天才好，那几天我一直在睡觉，做各种各样光怪陆离，魑魅魍魉的梦。</p>\n<h2 id=\"2018-vs-2023\"><a href=\"#2018-vs-2023\" class=\"headerlink\" title=\"2018 vs 2023\"></a>2018 vs 2023</h2><p>2018 年我刚从德国回来的时候，计划着转行，也没有着急出去找工作，那会儿一整年都在家，看电影，打篮球，看书，写代码。</p>\n<p>2023 年离开深圳再次回到家乡，熟悉的场景有些相似，又有些不同。只能说我对这种 gap year 的处境驾轻就熟，有着足够的经验去应对。之后的整个四月一直到五月中旬，自己的大部分时间都投入到了自己的个人项目中，偶尔时间出去打打篮球，偶尔放松的时候玩几局 splatoon，zelda: tears of the kingdom。</p>\n<p>当你花上一周时间，解决了一些技术难题，把心中的想法实现出来的时候，不工作的焦虑感也会稍微消解，但这种消解总是暂时的，焦虑感却总会随着时间的推移越来越大。每晚都要熬到两三点钟才能睡着，在 live stream 中看几局 splatoon，有次还不小心听到某位 splatoon steamer 抱怨已经很久都没有去工作了。</p>\n<h2 id=\"Bump-Version\"><a href=\"#Bump-Version\" class=\"headerlink\" title=\"Bump Version\"></a>Bump Version</h2><p>七月初面试确定，然后决定动身前往上海。</p>\n<p>在家里待了接近四个月，经历了「清明」，「五一」，「端午」，线上观看了六月份 Apple WWDC，去了一次北京。</p>\n<p>宝可梦系列中，小智每次在前往下一个新的区域的时候，都只是带上皮卡丘，把其他的宝可梦留在家里。</p>\n<p><img src=\"rye.jpeg\" alt=\"rye\"></p>\n<p>决定动身前往上海，做一次超大规模的「断舍离」，只带上一些必要的生活用品，电脑，平板，不必要的物件都暂时安置在家中。这样的场景，像极了购买了一款游戏续作，主角还是前作的主角，没有改变，只是这一次需要前往崭新的区域去冒险，去面对此前没有见过的，新的敌人。</p>\n<p>在上海确定好工作事宜，花上周末两天时间去医院做体检，找房子。网络上下单必备的生活用品，纸巾，洗衣液，衣撑，枕芯等等。一切安置妥当不需要花太久的时间。晚间时分在住的地方附近逛一逛，熟悉一下周边的环境和风景。我在 IM 软件中联系在上海的同学，告诉他们我从深圳换到上海这边工作了，有时间可以出来见一面，叙叙旧。</p>\n<p>自己以前总是对未来有着明确的期许，有着可能划分到每一天的明确的计划。但我现在不这样，很多事情并不是事先计划好的，无论是当初去到深圳，离开深圳，还是再次去上海，我都没有明确的规划。只是刚好有什么东西在推着我，好吧，去那里看看吧，去那里也不差。</p>\n<p>二〇二三年的下半年，七月到十二月，时间过得很快。自己又回到了之前那个，周一至周五，挤地铁上班，写代码，周末以及下班回家写写个人项目，或是玩一玩游戏的生活状态。和友人开玩笑，如果周末一直宅在家里，甚至都没有自己是生活在上海的感知，很多大体上的事情都和深圳其实差别不大，其他可感知的区别可能在于饮食，文化。上海这边每个月都有好多的展览可以逛。</p>\n<p>今年自己经历了蛮多的事情的，姥爷的去世其实自己心里早有预期，但还是内心会有些恍惚。因为这不是在看电影，看电影的时候总会安慰自己，一个角色总会在某个时候展现人物弧光和升华。但现实不是拍电影演电影讲故事，现实就是现实，没有来自导演意志的因果叙事逻辑。心里的难过情绪，在姥爷葬礼被我自己压制着的。但这种压抑，会在以后生活中某个不经意的细节，因为某些不经意的片段，会让我突然想到过去一些回忆，然后就突然止不住的，怎么也停不下来的大哭。</p>\n<blockquote>\n<ul>\n<li>Wait… what happened?</li>\n<li>[<em>sadly</em>] He’s been forgotten. When there’s no one left in the living world who remembers you, you disappear from this world. We call it the Final Death.</li>\n<li>Where did he go?</li>\n<li>No one knows.</li>\n</ul>\n<p>– Coco</p>\n</blockquote>\n<p>我忽然理解，为什么侯孝贤导演安排聂隐娘哭泣的时候，需要用布遮住面部。</p>\n<p>以下是按照惯例的盘点内容。</p>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><h3 id=\"PlayStation\"><a href=\"#PlayStation\" class=\"headerlink\" title=\"PlayStation\"></a>PlayStation</h3><ul>\n<li>The Last of Us™ Part II Remastered - 2023.01.30</li>\n<li>Baldur’s Gate 3 - 109 hours</li>\n<li>It Takes Two</li>\n</ul>\n<h3 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h3><ul>\n<li>Splatoon™ 3</li>\n<li>ゼルダの伝説 ティアーズ オブ ザ キングダム</li>\n<li>Persona 4 Golden</li>\n</ul>\n<p>二月末三月初离职的那段时间，自己每天一边打包行李，一边把 The Last of Us™ Part II 通关了。这部作品在网络上有着很大的争议，但我总想，一部游戏，至少需要我亲自玩过，我才有资格去评价它。 The Last of Us Part I 主题是很普世价值的「爱」，讲 Joel 和 Ellie 在末世之中，从相互陌生到互相信任，这个叙事逻辑是安全的，玩家也很容易接受。Part II 的主题却是「恨」。它在叙事上走得太超前了，至少我在玩过以后，我认为它是目前迄今为止在玩过的所有游戏中，叙事最超前最先锋的。我始终认为，不管是听音乐的听众，还是看电影的观众，或是玩游戏的玩家，审美品味都是需要一点一点训练和培养的。几十年前的电影观众可能还只是陶醉在正反对立的二元叙事语境，然后电影叙事在不断进化，开始模糊，反讽，辩证，蒙太奇。观众在这个过程也是在不断地训练和品鉴。我认为作为第九艺术的游戏也是这样。The Last of Us Part II 遭受的巨大争议，专业媒体评论者和普通玩家的巨大分歧，是大多数玩家思考游戏叙事还停留在「勇者斗恶龙」的体系下。</p>\n<p>The Last of Us Part II 的双线视角叙事，真的只有亲自玩过才能体会游戏和电影不同媒介叙事的巨大差异。电影始终是以第三者的角度去审视故事，而游戏需要玩家去交互，去操作，去亲自做出选择。强制完全控制带入一个陌生的，让很多人第一眼开始就讨厌的角色，是很困难的。我自己也是，所以我在第一次控制 Abby 的时候，故意让她摔下悬崖好几次。等到玩完整个 Abby 线的时候，我对 Abby 的看法已经改变了好多，这种体会，亲自游玩和在网络上看别人剪辑过的游玩过程会有很大区别，因为当你亲自游玩时，你会在很多地方卡关，你控制 Abby 角色会一遍遍的死亡重新来过，这些内容都会慢慢消解对于 Abby 角色的恨。而如果是在网络上看别人游玩，因为是剪辑过的内容，就没有这种感受了。</p>\n<img src=\"first-game.jpg\" width=\"300px\" style=\"display: block;margin: 0 auto;\">\n\n<p>Persona 4 Golden 中能看出很多 P5 的影子，有几首音乐特别好听，另外就是「久慈川理世」这个角色设定太有魅力了。</p>\n<p>五月份自己心心念念的 『ゼルダの伝説 ティアーズ オブ ザ キングダム』（ 薩爾達傳說 王國之淚 ）发售了。有两周的时间，自己除了吃饭就是在玩塞尔达。很多人评论这一作神庙的谜题难度降低了，但其实我想一个原因是这作的能力「通天术」和「倒转乾坤」相比上一部都强了不少，另外就是这一作把很多的谜题都设置在了大地图上。我现在还能记得自己不看攻略再一次成功抵达迷雾森林，推理出格鲁德小镇的壁画谜题。半夜两三点，自己躺在被窝中，摸着黑下到地底，朝着远处的一个光亮一点点探索，那种对整片海拉鲁大陆熟悉又陌生，每处地方都能激发出很强的探索欲，这样的感受是很难得的。</p>\n<p><img src=\"zelda.png\" alt=\"zelda\"></p>\n<p>八月份的时候大家都开始讨论 Baldur’s Gate 3，都在讲它太惊艳了。我是等到十月份才开始玩这款游戏。CRPG 的游戏是有一定的门槛，有很多的专业术语，眼花缭乱的技能设定，专项，魔法，机制等等。好在游戏的引导设计足够好，了解这些内容并不会很吃力。目前我 Baldur’s Gate 3 玩了 109 个小时，进度还停留在一周目的第三章。我理解这游戏好玩的点在哪，但是因为剧情自由度太高了，总是不经意就错过好多内容。（ 一周目因为第一章没有招威尔入队，导致丢失了后面所有的威尔相关剧情 ）。</p>\n<h2 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h2><p>今年听到的好听的音乐依旧大多数来自于游戏原声（ 因为今年依旧看很少的电影 ）</p>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2023/pl.rp-kDD5sedLQbl\">Replay 2023 - Apple Music for Reyshawn</a></p>\n<ul>\n<li>Song of Balduran - Borislav Slavov</li>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>SNOWFLAKES ( powder snow mix ) - Shihoko Hirata</li>\n</ul>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><ul>\n<li>『天国大魔境』</li>\n<li>『名侦探柯南：黑铁的鱼影』</li>\n</ul>\n<p>『天国大魔境』，动漫和漫画都强烈推荐，叙述性诡计，伏笔布局都相当精彩。</p>\n<p>六月份的时候由于太过焦虑，花了一周的时间，就重新把整部『柯南』漫画重新看了一遍。我对这部作品有着很强的情感滤镜，因为小时候真的特别特别喜欢。现在随着阅历的加深，我也很清楚这部作品叙事还是人物塑造上存在的问题，但有时候关注一些相关的内容，<strong>会有一种逃离现实的安全感</strong>。</p>\n<p>另外值得一提的是，终于搞定了 Netflix 订阅，之前付款总是失败，然后今年不清楚又试了一次竟然就付款成功了。目前在 Netflix 只是补了 『黑镜』。</p>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><p>又是没怎么系统性看完完整一本书的一年（ 想到了 2021 年 ）。去年闲暇时开始看『金瓶梅』，只是看了前二十个章节。又重新去读村上的『一九七三年弹子球』也是读到一半，没有读完。</p>\n<p>技术类书籍也没怎么去读，不过倒是看了不少 third library 的源码，web 和 iOS 都有包括。</p>\n<h2 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h2><p>今年很多值得铭记的时刻，是自己花了很大精力解决了一些技术难题，包括但不限于</p>\n<ul>\n<li>iOS Page Sheet 多段式动画实现</li>\n<li>twitter-like profile page ( tabs with sticky header )</li>\n<li>Transition Component in React</li>\n<li>fragment shader 实现无限网格</li>\n<li>Infinite canvas, zooming and dragging</li>\n<li>3d line geometry 优化 ( 更少的 vertices )</li>\n</ul>\n<h3 id=\"推导-Quaternion\"><a href=\"#推导-Quaternion\" class=\"headerlink\" title=\"推导 Quaternion\"></a>推导 Quaternion</h3><p>花了一个晚上的时间，按照论文上的步骤，一步一步在 iPad 手写演算进行推导。其中涉及到了一些点乘，叉乘的化简运算，叉乘运算又极其繁琐，加之论文其实省略了一些推导步骤的。不过好在自己最后算对了，算出结果那一刻真的好开心，又感叹发明 Quaternion 来进行 3d 旋转运算的人，真的好厉害！</p>\n<h3 id=\"拯救暗夜之歌\"><a href=\"#拯救暗夜之歌\" class=\"headerlink\" title=\"拯救暗夜之歌\"></a>拯救暗夜之歌</h3><p>我认为 Baldur‘s Gate 3 整个第二章都特别精彩，高潮部分在「拯救暗夜之歌」，演出相当震撼。</p>\n<h3 id=\"横宮七海\"><a href=\"#横宮七海\" class=\"headerlink\" title=\"横宮七海\"></a>横宮七海</h3><p>R.I.P.</p>\n<p>可能是大多数人都不怎么认识和关注的一个人，但是看到消息还是感到很难过。更残酷的是，商业上并不会因为一个人的身故而停止发售她生前已经拍好的作品。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>新的城市，新的工作，新的同事。对未来没有太多期许。每周二或周三工作日的晚上去打一场篮球，大汗淋漓之后喝上一杯冰镇的可乐。回到家里再冲上一个热水澡。生活相比以前，有了一些细微的改变。我不清楚，也不去想，不去期许五年十年后的事情，仅以这些文字，纪念即将过去的二〇二三。</p>\n<p>🌻</p>"},{"title":"墨菲定律","date":"2024-12-31T03:19:27.000Z","_content":"\n最近几年，自己都会经常拍照。吃饭的时候，与好友聚会的时候，理发的时候，背起背包远行的时候，登上飞机、登上高铁的时候。不仅拍自己，也拍周围的友人，周围的景色。朋友有时候看到我拿出手机，被我记录到露出讶异的表情，有时会欣然来一张合照。妈妈看到总是嗔怪一句，「怎么啥都要拍？」奶奶看到也会被我记录到看向镜头讶异的神情。\n\n量子场论告诉我们，光是由光子组成，光子是一个又一个不可再分的小的波包，在真空中总是以恒定速度 c 进行传播。我们对周遭世界的观测，对宇宙的观测，很大程度都要仰仗于我们眼睛对特定波长电磁波的感知，对光的感知。因为光被相机捕获，才得以被照片记录下来。因为光到达了我们眼睛，才在我们心底里铭刻出有画面的记忆。\n\n今年年初过年那会儿，我在网上购买了一台照片扫描仪，花了几天时间，把家里的所有老照片都扫描下来。时间跨度是 1981 - 2024。这样自己的照片库就更加完整了！\n\n<!--more-->\n\n九月底的时候，决定回一趟家，休整一下。那段时间一系列的事情搞得自己很疲惫，公司倒闭，失业，仲裁，搬家，换房子。那时就想找个东西把自己完全包裹起来，不想和任何人交流。于是自己开始整日看动漫，看了很多老动漫。经常看到凌晨四点到五点，然后一觉睡到第二天的中午或是下午。日复一日，日夜颠倒。\n\n十月三日回到家。回到家第四天，爸爸外出旅行归来，当天晚上七点钟。我和爸爸开车去县城，接奶奶到我家来住。自从爷爷二〇一七年过世以后，奶奶就是在几个儿女间交替居住。晚上八点半左右到达县城，爸爸已经提前和奶奶打过电话了。我们到的时候，奶奶坐在轮椅上等着我们，旁边是收拾好的行李。奶奶今年八十六岁，腿脚不是很方便。\n\n我在家待了有三周的时间，每天就是对着电脑看书，看一本 LLDB 相关的书籍。不过在家的时间，算是把自己之前混乱的作息调整过来了。我是十月底离开的。然后在十一月十六日上午九点，我躺在床上刚睁开眼睛，看到手机里的好多的未接来电，然后得知了奶奶病故的噩耗。于是又匆匆订车票回家。心里喃喃着，我走的时候不是都还好好的么。\n\n这两年每年都有对我来说很亲的人离开。去年姥爷是一点点不可逆的生病衰老，姥爷的离开是有预见和心理准备的。奶奶的事情却非常突然。明明我上个月还都在和奶奶一起生活，奶奶还说自己身体特别好，吃饭每次也都吃的特别多。奶奶她老说我吃饭还没有她一个老人家吃得多，让我多吃点。手机里还保存着我十月份在家时拍的很多照片。\n\n奶奶的葬礼过后，我在家又待了一段时间，每晚开始会和爸爸妈妈一起去散步。在这件事之前，他们喊我去散步，我一次都没有去过。冬天的十一月份，走在小河沟旁边的人行道，旁边是高大环绕的松柏树，没有路灯，晴朗的天空有时候依稀能看到星星。对！能看到星星！那几天抬头总能看到木星。\n\n去年待在农村那几天，每晚都能看到很多星星。从那时起手机里就提前下载了观星 APP，这样在能看到星星的时候，就知道是哪一颗星星发出来的光芒。\n\n长期失业的焦虑，周遭事情的变故，亲人的离去，让我越来越关注当下，关注当下能完成的每一件小事。然后在每个晴朗的夜晚，带着哪怕四五百度的眼镜也要尽力凝视深空。现代人们的注意力在不断地被各种人造光源剥夺。到最后最震慑人心的，依然是无垠的宇宙和广袤的繁星。\n\n人类实在是太渺小了。\n\n「生命实在是太脆弱了。」\n\n妈妈谈起奶奶时说到。就像是小猫小狗一样，说不动就不动了。\n\n后来的故事都是听爸爸妈妈讲的。但我想要把事情的经历在此处记录下来。我想要尽可能地把关于奶奶的回忆都保存起来，如果可以。\n\n我是十月二十三号离开家的，在此之前，奶奶一直在我家生活。她每天生活很规律，天气晴朗的时候，上午下午都会出门，和小区里其他年纪相仿的老人坐在一起聊天，或是走一走。奶奶出门时总会带着一个帽子，拿一个小袋子，里面装着钥匙或其他一些杂物，然后轻轻打开门，按下电梯键。开门和关门都很轻，所以我在屋里，仅凭声音，就大概能判断出是谁回来了。我离开家不久，奶奶身体感觉不舒服，就拜托爸爸妈妈去医院做了一下检查，结果是肺部栓塞，需要手术治疗。因为奶奶年纪很大了，最后选择了保守治疗，在医院住了一个星期，医院是不会让你持续住下去的，就回家了。那会儿奶奶刚出院，我往家里打视频电话，奶奶都在连忙说着「没啥事，没啥事」。奶奶总是这样，她哪怕这么大年纪，都不希望让别人操心。\n\n十一月十六日凌晨两点到三点左右，妈妈被奶奶声音吵醒，奶奶大概是难受得厉害，甚至下了床，站在了爸爸妈妈房门口喊我妈妈的名字。那会儿估计爸爸妈妈都急坏了，赶紧拨打120，倒水，然后搀扶奶奶躺在床上。听我爸爸妈妈说，奶奶躺在床上时表情还很狰狞难受，不久就像是睡着了一样，手垂了下来。爸爸在旁边半裸着上身，一直喊着「娘！」，妈妈在旁边联系急救车，不时张望着看急救车是否来到了。医院的急救车大概半个小时左右到的，那会儿奶奶整个肺部隆起。送到医院后做了一些基本检查，接下来就是一系列麻烦的后事。\n\n两年时间，去了同一家火葬场两次，和亲人作别。奶奶被推进焚化炉的时刻，我看到老爸在回头凝望，老爸那时心里也一定划过了他，从小到大许许多多的回忆。后来爸爸说，事情过后总觉得心里空荡荡的，像是完成了什么任务一样，没有了什么挂念。\n\n我在二〇二四年上半年，一如去年一样工作，在写一个看起来很复杂的 EDA 软件。五月份的时候，趁着假期去了一趟香港，莫名其妙在中环碰到了五月天的演唱会。七月的时候，公司宣布上海分公司关闭，我和我的一众同事就突然失了业，同时也遭遇了一个月的欠薪。于是和前同事们一起进行了一场劳动仲裁，最后由于无法执行到任何财产而被宣布结案。\n\n七月份的我开启久违的「暑假」生活，玩游戏，看动漫，以此修复我被工作摧残的身体。八九月份开始投简历，因为薪资问题拒掉了一个 offer 后，发现市场比我想象的要糟糕得多。十月份回家休整。十一月份家里变故。十二月份把自己的精力重新聚焦在当下的事情中。\n\n以上，便是整个匆忙又仓皇失措的二〇二四年。\n\n## 书\n\n- Advanced Apple Debugging & Reverse Engineering\n\n这本书是我十月份在家休养时阅读的。讲了一些 LLDB 的进阶用法，有例子。其中最有收获的还是讲如何分析一个 binary。\n\n村上春树出了新书『小城与不确定性的墙』，但自己一直没有去读，看来只能留到二〇二五年去读这本书了。\n\n## 影视\n\n- 『Id: Invaded』( 异度侵入ID:INVADED )\n- 『Steins;Gate 命运石之门』系列\n- 『中二病也要谈恋爱！』系列\n- 『psycho-pass』系列\n\n七八月份的时候看了不少动漫，有一些很是惊喜，其中最惊喜的便是『Id: Invaded』( 异度侵入ID:INVADED )，整个观看过程很像当年在看『盗梦空间』。\n\n## 游戏\n\n下半年一桩又一桩的糟心事情，让我没有什么心情沉下心来去体验单机游戏。刚开始还是偶尔玩一玩 splatoon。后来暂停了 Nintendo Online 的订阅。接着国服『炉石传说』的回归，算是自己为数不多可以得到放松的时刻。\n\n## 时刻\n\n今年让我值得铭记的时刻并不太多。Apple 每年重复提高相机参数，都已经不太想每次熬夜看苹果发布会了。恰逢 Nintendo Switch 的生命末期，今年任天堂也没有什么大作。（ 『智慧的再现』我还一直没有购买 ）。\n\n### 开始炒美股\n\n### 香港偶遇五月天演唱会\n\n### 拍摄到昴宿星团！\n\n### 拍摄仙女座星系！\n\n我不确定是不是仙女座星系，因为只是一个点，但根据位置和亮度应该就是它了。\n\n![night](night.jpeg)\n\n## 结语\n\n失业依然在继续。不过自己目前的状态还算好，自己每天专注在自己的项目中，专注在能够进行的每一个下一步行动 next action。要相信，遇到的任何问题，一定会有解决办法。要使劲儿去找解决办法，然后进行下一步行动，这是我目前唯一能做的事情。\n\n\n\n🌻\n","source":"_posts/2024-summary.md","raw":"---\ntitle: 墨菲定律\ndate: 2024-12-31 11:19:27\ntags:\n- 电影\n- 游戏\n- 音乐\ncategories: 'I/O'\n---\n\n最近几年，自己都会经常拍照。吃饭的时候，与好友聚会的时候，理发的时候，背起背包远行的时候，登上飞机、登上高铁的时候。不仅拍自己，也拍周围的友人，周围的景色。朋友有时候看到我拿出手机，被我记录到露出讶异的表情，有时会欣然来一张合照。妈妈看到总是嗔怪一句，「怎么啥都要拍？」奶奶看到也会被我记录到看向镜头讶异的神情。\n\n量子场论告诉我们，光是由光子组成，光子是一个又一个不可再分的小的波包，在真空中总是以恒定速度 c 进行传播。我们对周遭世界的观测，对宇宙的观测，很大程度都要仰仗于我们眼睛对特定波长电磁波的感知，对光的感知。因为光被相机捕获，才得以被照片记录下来。因为光到达了我们眼睛，才在我们心底里铭刻出有画面的记忆。\n\n今年年初过年那会儿，我在网上购买了一台照片扫描仪，花了几天时间，把家里的所有老照片都扫描下来。时间跨度是 1981 - 2024。这样自己的照片库就更加完整了！\n\n<!--more-->\n\n九月底的时候，决定回一趟家，休整一下。那段时间一系列的事情搞得自己很疲惫，公司倒闭，失业，仲裁，搬家，换房子。那时就想找个东西把自己完全包裹起来，不想和任何人交流。于是自己开始整日看动漫，看了很多老动漫。经常看到凌晨四点到五点，然后一觉睡到第二天的中午或是下午。日复一日，日夜颠倒。\n\n十月三日回到家。回到家第四天，爸爸外出旅行归来，当天晚上七点钟。我和爸爸开车去县城，接奶奶到我家来住。自从爷爷二〇一七年过世以后，奶奶就是在几个儿女间交替居住。晚上八点半左右到达县城，爸爸已经提前和奶奶打过电话了。我们到的时候，奶奶坐在轮椅上等着我们，旁边是收拾好的行李。奶奶今年八十六岁，腿脚不是很方便。\n\n我在家待了有三周的时间，每天就是对着电脑看书，看一本 LLDB 相关的书籍。不过在家的时间，算是把自己之前混乱的作息调整过来了。我是十月底离开的。然后在十一月十六日上午九点，我躺在床上刚睁开眼睛，看到手机里的好多的未接来电，然后得知了奶奶病故的噩耗。于是又匆匆订车票回家。心里喃喃着，我走的时候不是都还好好的么。\n\n这两年每年都有对我来说很亲的人离开。去年姥爷是一点点不可逆的生病衰老，姥爷的离开是有预见和心理准备的。奶奶的事情却非常突然。明明我上个月还都在和奶奶一起生活，奶奶还说自己身体特别好，吃饭每次也都吃的特别多。奶奶她老说我吃饭还没有她一个老人家吃得多，让我多吃点。手机里还保存着我十月份在家时拍的很多照片。\n\n奶奶的葬礼过后，我在家又待了一段时间，每晚开始会和爸爸妈妈一起去散步。在这件事之前，他们喊我去散步，我一次都没有去过。冬天的十一月份，走在小河沟旁边的人行道，旁边是高大环绕的松柏树，没有路灯，晴朗的天空有时候依稀能看到星星。对！能看到星星！那几天抬头总能看到木星。\n\n去年待在农村那几天，每晚都能看到很多星星。从那时起手机里就提前下载了观星 APP，这样在能看到星星的时候，就知道是哪一颗星星发出来的光芒。\n\n长期失业的焦虑，周遭事情的变故，亲人的离去，让我越来越关注当下，关注当下能完成的每一件小事。然后在每个晴朗的夜晚，带着哪怕四五百度的眼镜也要尽力凝视深空。现代人们的注意力在不断地被各种人造光源剥夺。到最后最震慑人心的，依然是无垠的宇宙和广袤的繁星。\n\n人类实在是太渺小了。\n\n「生命实在是太脆弱了。」\n\n妈妈谈起奶奶时说到。就像是小猫小狗一样，说不动就不动了。\n\n后来的故事都是听爸爸妈妈讲的。但我想要把事情的经历在此处记录下来。我想要尽可能地把关于奶奶的回忆都保存起来，如果可以。\n\n我是十月二十三号离开家的，在此之前，奶奶一直在我家生活。她每天生活很规律，天气晴朗的时候，上午下午都会出门，和小区里其他年纪相仿的老人坐在一起聊天，或是走一走。奶奶出门时总会带着一个帽子，拿一个小袋子，里面装着钥匙或其他一些杂物，然后轻轻打开门，按下电梯键。开门和关门都很轻，所以我在屋里，仅凭声音，就大概能判断出是谁回来了。我离开家不久，奶奶身体感觉不舒服，就拜托爸爸妈妈去医院做了一下检查，结果是肺部栓塞，需要手术治疗。因为奶奶年纪很大了，最后选择了保守治疗，在医院住了一个星期，医院是不会让你持续住下去的，就回家了。那会儿奶奶刚出院，我往家里打视频电话，奶奶都在连忙说着「没啥事，没啥事」。奶奶总是这样，她哪怕这么大年纪，都不希望让别人操心。\n\n十一月十六日凌晨两点到三点左右，妈妈被奶奶声音吵醒，奶奶大概是难受得厉害，甚至下了床，站在了爸爸妈妈房门口喊我妈妈的名字。那会儿估计爸爸妈妈都急坏了，赶紧拨打120，倒水，然后搀扶奶奶躺在床上。听我爸爸妈妈说，奶奶躺在床上时表情还很狰狞难受，不久就像是睡着了一样，手垂了下来。爸爸在旁边半裸着上身，一直喊着「娘！」，妈妈在旁边联系急救车，不时张望着看急救车是否来到了。医院的急救车大概半个小时左右到的，那会儿奶奶整个肺部隆起。送到医院后做了一些基本检查，接下来就是一系列麻烦的后事。\n\n两年时间，去了同一家火葬场两次，和亲人作别。奶奶被推进焚化炉的时刻，我看到老爸在回头凝望，老爸那时心里也一定划过了他，从小到大许许多多的回忆。后来爸爸说，事情过后总觉得心里空荡荡的，像是完成了什么任务一样，没有了什么挂念。\n\n我在二〇二四年上半年，一如去年一样工作，在写一个看起来很复杂的 EDA 软件。五月份的时候，趁着假期去了一趟香港，莫名其妙在中环碰到了五月天的演唱会。七月的时候，公司宣布上海分公司关闭，我和我的一众同事就突然失了业，同时也遭遇了一个月的欠薪。于是和前同事们一起进行了一场劳动仲裁，最后由于无法执行到任何财产而被宣布结案。\n\n七月份的我开启久违的「暑假」生活，玩游戏，看动漫，以此修复我被工作摧残的身体。八九月份开始投简历，因为薪资问题拒掉了一个 offer 后，发现市场比我想象的要糟糕得多。十月份回家休整。十一月份家里变故。十二月份把自己的精力重新聚焦在当下的事情中。\n\n以上，便是整个匆忙又仓皇失措的二〇二四年。\n\n## 书\n\n- Advanced Apple Debugging & Reverse Engineering\n\n这本书是我十月份在家休养时阅读的。讲了一些 LLDB 的进阶用法，有例子。其中最有收获的还是讲如何分析一个 binary。\n\n村上春树出了新书『小城与不确定性的墙』，但自己一直没有去读，看来只能留到二〇二五年去读这本书了。\n\n## 影视\n\n- 『Id: Invaded』( 异度侵入ID:INVADED )\n- 『Steins;Gate 命运石之门』系列\n- 『中二病也要谈恋爱！』系列\n- 『psycho-pass』系列\n\n七八月份的时候看了不少动漫，有一些很是惊喜，其中最惊喜的便是『Id: Invaded』( 异度侵入ID:INVADED )，整个观看过程很像当年在看『盗梦空间』。\n\n## 游戏\n\n下半年一桩又一桩的糟心事情，让我没有什么心情沉下心来去体验单机游戏。刚开始还是偶尔玩一玩 splatoon。后来暂停了 Nintendo Online 的订阅。接着国服『炉石传说』的回归，算是自己为数不多可以得到放松的时刻。\n\n## 时刻\n\n今年让我值得铭记的时刻并不太多。Apple 每年重复提高相机参数，都已经不太想每次熬夜看苹果发布会了。恰逢 Nintendo Switch 的生命末期，今年任天堂也没有什么大作。（ 『智慧的再现』我还一直没有购买 ）。\n\n### 开始炒美股\n\n### 香港偶遇五月天演唱会\n\n### 拍摄到昴宿星团！\n\n### 拍摄仙女座星系！\n\n我不确定是不是仙女座星系，因为只是一个点，但根据位置和亮度应该就是它了。\n\n![night](night.jpeg)\n\n## 结语\n\n失业依然在继续。不过自己目前的状态还算好，自己每天专注在自己的项目中，专注在能够进行的每一个下一步行动 next action。要相信，遇到的任何问题，一定会有解决办法。要使劲儿去找解决办法，然后进行下一步行动，这是我目前唯一能做的事情。\n\n\n\n🌻\n","slug":"2024-summary","published":1,"updated":"2024-12-31T16:59:46.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx220006rg1v9x489ph5","content":"<p>最近几年，自己都会经常拍照。吃饭的时候，与好友聚会的时候，理发的时候，背起背包远行的时候，登上飞机、登上高铁的时候。不仅拍自己，也拍周围的友人，周围的景色。朋友有时候看到我拿出手机，被我记录到露出讶异的表情，有时会欣然来一张合照。妈妈看到总是嗔怪一句，「怎么啥都要拍？」奶奶看到也会被我记录到看向镜头讶异的神情。</p>\n<p>量子场论告诉我们，光是由光子组成，光子是一个又一个不可再分的小的波包，在真空中总是以恒定速度 c 进行传播。我们对周遭世界的观测，对宇宙的观测，很大程度都要仰仗于我们眼睛对特定波长电磁波的感知，对光的感知。因为光被相机捕获，才得以被照片记录下来。因为光到达了我们眼睛，才在我们心底里铭刻出有画面的记忆。</p>\n<p>今年年初过年那会儿，我在网上购买了一台照片扫描仪，花了几天时间，把家里的所有老照片都扫描下来。时间跨度是 1981 - 2024。这样自己的照片库就更加完整了！</p>\n<span id=\"more\"></span>\n\n<p>九月底的时候，决定回一趟家，休整一下。那段时间一系列的事情搞得自己很疲惫，公司倒闭，失业，仲裁，搬家，换房子。那时就想找个东西把自己完全包裹起来，不想和任何人交流。于是自己开始整日看动漫，看了很多老动漫。经常看到凌晨四点到五点，然后一觉睡到第二天的中午或是下午。日复一日，日夜颠倒。</p>\n<p>十月三日回到家。回到家第四天，爸爸外出旅行归来，当天晚上七点钟。我和爸爸开车去县城，接奶奶到我家来住。自从爷爷二〇一七年过世以后，奶奶就是在几个儿女间交替居住。晚上八点半左右到达县城，爸爸已经提前和奶奶打过电话了。我们到的时候，奶奶坐在轮椅上等着我们，旁边是收拾好的行李。奶奶今年八十六岁，腿脚不是很方便。</p>\n<p>我在家待了有三周的时间，每天就是对着电脑看书，看一本 LLDB 相关的书籍。不过在家的时间，算是把自己之前混乱的作息调整过来了。我是十月底离开的。然后在十一月十六日上午九点，我躺在床上刚睁开眼睛，看到手机里的好多的未接来电，然后得知了奶奶病故的噩耗。于是又匆匆订车票回家。心里喃喃着，我走的时候不是都还好好的么。</p>\n<p>这两年每年都有对我来说很亲的人离开。去年姥爷是一点点不可逆的生病衰老，姥爷的离开是有预见和心理准备的。奶奶的事情却非常突然。明明我上个月还都在和奶奶一起生活，奶奶还说自己身体特别好，吃饭每次也都吃的特别多。奶奶她老说我吃饭还没有她一个老人家吃得多，让我多吃点。手机里还保存着我十月份在家时拍的很多照片。</p>\n<p>奶奶的葬礼过后，我在家又待了一段时间，每晚开始会和爸爸妈妈一起去散步。在这件事之前，他们喊我去散步，我一次都没有去过。冬天的十一月份，走在小河沟旁边的人行道，旁边是高大环绕的松柏树，没有路灯，晴朗的天空有时候依稀能看到星星。对！能看到星星！那几天抬头总能看到木星。</p>\n<p>去年待在农村那几天，每晚都能看到很多星星。从那时起手机里就提前下载了观星 APP，这样在能看到星星的时候，就知道是哪一颗星星发出来的光芒。</p>\n<p>长期失业的焦虑，周遭事情的变故，亲人的离去，让我越来越关注当下，关注当下能完成的每一件小事。然后在每个晴朗的夜晚，带着哪怕四五百度的眼镜也要尽力凝视深空。现代人们的注意力在不断地被各种人造光源剥夺。到最后最震慑人心的，依然是无垠的宇宙和广袤的繁星。</p>\n<p>人类实在是太渺小了。</p>\n<p>「生命实在是太脆弱了。」</p>\n<p>妈妈谈起奶奶时说到。就像是小猫小狗一样，说不动就不动了。</p>\n<p>后来的故事都是听爸爸妈妈讲的。但我想要把事情的经历在此处记录下来。我想要尽可能地把关于奶奶的回忆都保存起来，如果可以。</p>\n<p>我是十月二十三号离开家的，在此之前，奶奶一直在我家生活。她每天生活很规律，天气晴朗的时候，上午下午都会出门，和小区里其他年纪相仿的老人坐在一起聊天，或是走一走。奶奶出门时总会带着一个帽子，拿一个小袋子，里面装着钥匙或其他一些杂物，然后轻轻打开门，按下电梯键。开门和关门都很轻，所以我在屋里，仅凭声音，就大概能判断出是谁回来了。我离开家不久，奶奶身体感觉不舒服，就拜托爸爸妈妈去医院做了一下检查，结果是肺部栓塞，需要手术治疗。因为奶奶年纪很大了，最后选择了保守治疗，在医院住了一个星期，医院是不会让你持续住下去的，就回家了。那会儿奶奶刚出院，我往家里打视频电话，奶奶都在连忙说着「没啥事，没啥事」。奶奶总是这样，她哪怕这么大年纪，都不希望让别人操心。</p>\n<p>十一月十六日凌晨两点到三点左右，妈妈被奶奶声音吵醒，奶奶大概是难受得厉害，甚至下了床，站在了爸爸妈妈房门口喊我妈妈的名字。那会儿估计爸爸妈妈都急坏了，赶紧拨打120，倒水，然后搀扶奶奶躺在床上。听我爸爸妈妈说，奶奶躺在床上时表情还很狰狞难受，不久就像是睡着了一样，手垂了下来。爸爸在旁边半裸着上身，一直喊着「娘！」，妈妈在旁边联系急救车，不时张望着看急救车是否来到了。医院的急救车大概半个小时左右到的，那会儿奶奶整个肺部隆起。送到医院后做了一些基本检查，接下来就是一系列麻烦的后事。</p>\n<p>两年时间，去了同一家火葬场两次，和亲人作别。奶奶被推进焚化炉的时刻，我看到老爸在回头凝望，老爸那时心里也一定划过了他，从小到大许许多多的回忆。后来爸爸说，事情过后总觉得心里空荡荡的，像是完成了什么任务一样，没有了什么挂念。</p>\n<p>我在二〇二四年上半年，一如去年一样工作，在写一个看起来很复杂的 EDA 软件。五月份的时候，趁着假期去了一趟香港，莫名其妙在中环碰到了五月天的演唱会。七月的时候，公司宣布上海分公司关闭，我和我的一众同事就突然失了业，同时也遭遇了一个月的欠薪。于是和前同事们一起进行了一场劳动仲裁，最后由于无法执行到任何财产而被宣布结案。</p>\n<p>七月份的我开启久违的「暑假」生活，玩游戏，看动漫，以此修复我被工作摧残的身体。八九月份开始投简历，因为薪资问题拒掉了一个 offer 后，发现市场比我想象的要糟糕得多。十月份回家休整。十一月份家里变故。十二月份把自己的精力重新聚焦在当下的事情中。</p>\n<p>以上，便是整个匆忙又仓皇失措的二〇二四年。</p>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><ul>\n<li>Advanced Apple Debugging &amp; Reverse Engineering</li>\n</ul>\n<p>这本书是我十月份在家休养时阅读的。讲了一些 LLDB 的进阶用法，有例子。其中最有收获的还是讲如何分析一个 binary。</p>\n<p>村上春树出了新书『小城与不确定性的墙』，但自己一直没有去读，看来只能留到二〇二五年去读这本书了。</p>\n<h2 id=\"影视\"><a href=\"#影视\" class=\"headerlink\" title=\"影视\"></a>影视</h2><ul>\n<li>『Id: Invaded』( 异度侵入ID:INVADED )</li>\n<li>『Steins;Gate 命运石之门』系列</li>\n<li>『中二病也要谈恋爱！』系列</li>\n<li>『psycho-pass』系列</li>\n</ul>\n<p>七八月份的时候看了不少动漫，有一些很是惊喜，其中最惊喜的便是『Id: Invaded』( 异度侵入ID:INVADED )，整个观看过程很像当年在看『盗梦空间』。</p>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><p>下半年一桩又一桩的糟心事情，让我没有什么心情沉下心来去体验单机游戏。刚开始还是偶尔玩一玩 splatoon。后来暂停了 Nintendo Online 的订阅。接着国服『炉石传说』的回归，算是自己为数不多可以得到放松的时刻。</p>\n<h2 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h2><p>今年让我值得铭记的时刻并不太多。Apple 每年重复提高相机参数，都已经不太想每次熬夜看苹果发布会了。恰逢 Nintendo Switch 的生命末期，今年任天堂也没有什么大作。（ 『智慧的再现』我还一直没有购买 ）。</p>\n<h3 id=\"开始炒美股\"><a href=\"#开始炒美股\" class=\"headerlink\" title=\"开始炒美股\"></a>开始炒美股</h3><h3 id=\"香港偶遇五月天演唱会\"><a href=\"#香港偶遇五月天演唱会\" class=\"headerlink\" title=\"香港偶遇五月天演唱会\"></a>香港偶遇五月天演唱会</h3><h3 id=\"拍摄到昴宿星团！\"><a href=\"#拍摄到昴宿星团！\" class=\"headerlink\" title=\"拍摄到昴宿星团！\"></a>拍摄到昴宿星团！</h3><h3 id=\"拍摄仙女座星系！\"><a href=\"#拍摄仙女座星系！\" class=\"headerlink\" title=\"拍摄仙女座星系！\"></a>拍摄仙女座星系！</h3><p>我不确定是不是仙女座星系，因为只是一个点，但根据位置和亮度应该就是它了。</p>\n<p><img src=\"night.jpeg\" alt=\"night\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>失业依然在继续。不过自己目前的状态还算好，自己每天专注在自己的项目中，专注在能够进行的每一个下一步行动 next action。要相信，遇到的任何问题，一定会有解决办法。要使劲儿去找解决办法，然后进行下一步行动，这是我目前唯一能做的事情。</p>\n<p>🌻</p>\n","site":{"data":{}},"excerpt":"<p>最近几年，自己都会经常拍照。吃饭的时候，与好友聚会的时候，理发的时候，背起背包远行的时候，登上飞机、登上高铁的时候。不仅拍自己，也拍周围的友人，周围的景色。朋友有时候看到我拿出手机，被我记录到露出讶异的表情，有时会欣然来一张合照。妈妈看到总是嗔怪一句，「怎么啥都要拍？」奶奶看到也会被我记录到看向镜头讶异的神情。</p>\n<p>量子场论告诉我们，光是由光子组成，光子是一个又一个不可再分的小的波包，在真空中总是以恒定速度 c 进行传播。我们对周遭世界的观测，对宇宙的观测，很大程度都要仰仗于我们眼睛对特定波长电磁波的感知，对光的感知。因为光被相机捕获，才得以被照片记录下来。因为光到达了我们眼睛，才在我们心底里铭刻出有画面的记忆。</p>\n<p>今年年初过年那会儿，我在网上购买了一台照片扫描仪，花了几天时间，把家里的所有老照片都扫描下来。时间跨度是 1981 - 2024。这样自己的照片库就更加完整了！</p>","more":"<p>九月底的时候，决定回一趟家，休整一下。那段时间一系列的事情搞得自己很疲惫，公司倒闭，失业，仲裁，搬家，换房子。那时就想找个东西把自己完全包裹起来，不想和任何人交流。于是自己开始整日看动漫，看了很多老动漫。经常看到凌晨四点到五点，然后一觉睡到第二天的中午或是下午。日复一日，日夜颠倒。</p>\n<p>十月三日回到家。回到家第四天，爸爸外出旅行归来，当天晚上七点钟。我和爸爸开车去县城，接奶奶到我家来住。自从爷爷二〇一七年过世以后，奶奶就是在几个儿女间交替居住。晚上八点半左右到达县城，爸爸已经提前和奶奶打过电话了。我们到的时候，奶奶坐在轮椅上等着我们，旁边是收拾好的行李。奶奶今年八十六岁，腿脚不是很方便。</p>\n<p>我在家待了有三周的时间，每天就是对着电脑看书，看一本 LLDB 相关的书籍。不过在家的时间，算是把自己之前混乱的作息调整过来了。我是十月底离开的。然后在十一月十六日上午九点，我躺在床上刚睁开眼睛，看到手机里的好多的未接来电，然后得知了奶奶病故的噩耗。于是又匆匆订车票回家。心里喃喃着，我走的时候不是都还好好的么。</p>\n<p>这两年每年都有对我来说很亲的人离开。去年姥爷是一点点不可逆的生病衰老，姥爷的离开是有预见和心理准备的。奶奶的事情却非常突然。明明我上个月还都在和奶奶一起生活，奶奶还说自己身体特别好，吃饭每次也都吃的特别多。奶奶她老说我吃饭还没有她一个老人家吃得多，让我多吃点。手机里还保存着我十月份在家时拍的很多照片。</p>\n<p>奶奶的葬礼过后，我在家又待了一段时间，每晚开始会和爸爸妈妈一起去散步。在这件事之前，他们喊我去散步，我一次都没有去过。冬天的十一月份，走在小河沟旁边的人行道，旁边是高大环绕的松柏树，没有路灯，晴朗的天空有时候依稀能看到星星。对！能看到星星！那几天抬头总能看到木星。</p>\n<p>去年待在农村那几天，每晚都能看到很多星星。从那时起手机里就提前下载了观星 APP，这样在能看到星星的时候，就知道是哪一颗星星发出来的光芒。</p>\n<p>长期失业的焦虑，周遭事情的变故，亲人的离去，让我越来越关注当下，关注当下能完成的每一件小事。然后在每个晴朗的夜晚，带着哪怕四五百度的眼镜也要尽力凝视深空。现代人们的注意力在不断地被各种人造光源剥夺。到最后最震慑人心的，依然是无垠的宇宙和广袤的繁星。</p>\n<p>人类实在是太渺小了。</p>\n<p>「生命实在是太脆弱了。」</p>\n<p>妈妈谈起奶奶时说到。就像是小猫小狗一样，说不动就不动了。</p>\n<p>后来的故事都是听爸爸妈妈讲的。但我想要把事情的经历在此处记录下来。我想要尽可能地把关于奶奶的回忆都保存起来，如果可以。</p>\n<p>我是十月二十三号离开家的，在此之前，奶奶一直在我家生活。她每天生活很规律，天气晴朗的时候，上午下午都会出门，和小区里其他年纪相仿的老人坐在一起聊天，或是走一走。奶奶出门时总会带着一个帽子，拿一个小袋子，里面装着钥匙或其他一些杂物，然后轻轻打开门，按下电梯键。开门和关门都很轻，所以我在屋里，仅凭声音，就大概能判断出是谁回来了。我离开家不久，奶奶身体感觉不舒服，就拜托爸爸妈妈去医院做了一下检查，结果是肺部栓塞，需要手术治疗。因为奶奶年纪很大了，最后选择了保守治疗，在医院住了一个星期，医院是不会让你持续住下去的，就回家了。那会儿奶奶刚出院，我往家里打视频电话，奶奶都在连忙说着「没啥事，没啥事」。奶奶总是这样，她哪怕这么大年纪，都不希望让别人操心。</p>\n<p>十一月十六日凌晨两点到三点左右，妈妈被奶奶声音吵醒，奶奶大概是难受得厉害，甚至下了床，站在了爸爸妈妈房门口喊我妈妈的名字。那会儿估计爸爸妈妈都急坏了，赶紧拨打120，倒水，然后搀扶奶奶躺在床上。听我爸爸妈妈说，奶奶躺在床上时表情还很狰狞难受，不久就像是睡着了一样，手垂了下来。爸爸在旁边半裸着上身，一直喊着「娘！」，妈妈在旁边联系急救车，不时张望着看急救车是否来到了。医院的急救车大概半个小时左右到的，那会儿奶奶整个肺部隆起。送到医院后做了一些基本检查，接下来就是一系列麻烦的后事。</p>\n<p>两年时间，去了同一家火葬场两次，和亲人作别。奶奶被推进焚化炉的时刻，我看到老爸在回头凝望，老爸那时心里也一定划过了他，从小到大许许多多的回忆。后来爸爸说，事情过后总觉得心里空荡荡的，像是完成了什么任务一样，没有了什么挂念。</p>\n<p>我在二〇二四年上半年，一如去年一样工作，在写一个看起来很复杂的 EDA 软件。五月份的时候，趁着假期去了一趟香港，莫名其妙在中环碰到了五月天的演唱会。七月的时候，公司宣布上海分公司关闭，我和我的一众同事就突然失了业，同时也遭遇了一个月的欠薪。于是和前同事们一起进行了一场劳动仲裁，最后由于无法执行到任何财产而被宣布结案。</p>\n<p>七月份的我开启久违的「暑假」生活，玩游戏，看动漫，以此修复我被工作摧残的身体。八九月份开始投简历，因为薪资问题拒掉了一个 offer 后，发现市场比我想象的要糟糕得多。十月份回家休整。十一月份家里变故。十二月份把自己的精力重新聚焦在当下的事情中。</p>\n<p>以上，便是整个匆忙又仓皇失措的二〇二四年。</p>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><ul>\n<li>Advanced Apple Debugging &amp; Reverse Engineering</li>\n</ul>\n<p>这本书是我十月份在家休养时阅读的。讲了一些 LLDB 的进阶用法，有例子。其中最有收获的还是讲如何分析一个 binary。</p>\n<p>村上春树出了新书『小城与不确定性的墙』，但自己一直没有去读，看来只能留到二〇二五年去读这本书了。</p>\n<h2 id=\"影视\"><a href=\"#影视\" class=\"headerlink\" title=\"影视\"></a>影视</h2><ul>\n<li>『Id: Invaded』( 异度侵入ID:INVADED )</li>\n<li>『Steins;Gate 命运石之门』系列</li>\n<li>『中二病也要谈恋爱！』系列</li>\n<li>『psycho-pass』系列</li>\n</ul>\n<p>七八月份的时候看了不少动漫，有一些很是惊喜，其中最惊喜的便是『Id: Invaded』( 异度侵入ID:INVADED )，整个观看过程很像当年在看『盗梦空间』。</p>\n<h2 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h2><p>下半年一桩又一桩的糟心事情，让我没有什么心情沉下心来去体验单机游戏。刚开始还是偶尔玩一玩 splatoon。后来暂停了 Nintendo Online 的订阅。接着国服『炉石传说』的回归，算是自己为数不多可以得到放松的时刻。</p>\n<h2 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h2><p>今年让我值得铭记的时刻并不太多。Apple 每年重复提高相机参数，都已经不太想每次熬夜看苹果发布会了。恰逢 Nintendo Switch 的生命末期，今年任天堂也没有什么大作。（ 『智慧的再现』我还一直没有购买 ）。</p>\n<h3 id=\"开始炒美股\"><a href=\"#开始炒美股\" class=\"headerlink\" title=\"开始炒美股\"></a>开始炒美股</h3><h3 id=\"香港偶遇五月天演唱会\"><a href=\"#香港偶遇五月天演唱会\" class=\"headerlink\" title=\"香港偶遇五月天演唱会\"></a>香港偶遇五月天演唱会</h3><h3 id=\"拍摄到昴宿星团！\"><a href=\"#拍摄到昴宿星团！\" class=\"headerlink\" title=\"拍摄到昴宿星团！\"></a>拍摄到昴宿星团！</h3><h3 id=\"拍摄仙女座星系！\"><a href=\"#拍摄仙女座星系！\" class=\"headerlink\" title=\"拍摄仙女座星系！\"></a>拍摄仙女座星系！</h3><p>我不确定是不是仙女座星系，因为只是一个点，但根据位置和亮度应该就是它了。</p>\n<p><img src=\"night.jpeg\" alt=\"night\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>失业依然在继续。不过自己目前的状态还算好，自己每天专注在自己的项目中，专注在能够进行的每一个下一步行动 next action。要相信，遇到的任何问题，一定会有解决办法。要使劲儿去找解决办法，然后进行下一步行动，这是我目前唯一能做的事情。</p>\n<p>🌻</p>"},{"title":"@wraps | 6kyu","date":"2019-01-22T15:14:53.000Z","_content":"\n## 要点\n\n- `decorator` 装饰器用法\n- `try`...`except`... `else` control flow\n- `getattr()` 和 `setattr()`\n- `__dict__.update()`\n\n## Details\n\nImplement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here's an example :\n\n```python\ndef identity(func):\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    \"\"\"Wraps func\"\"\"\n    return func(*args, **kwargs)\n  return wrapper\n\n@identity\ndef return_one():\n  \"\"\"Return one\"\"\"\n  return 1\n\nreturn_one.__name__ == 'return_one' # If wraps hadn't been used, __name__ would be equal to 'wrapper'\nreturn_one.__doc__ == 'Return one' # If wraps hadn't been used, __doc__ would be equal to 'Wraps func'\n```\n\n**Note: of course, you may not use the functools module for this kata.**\n\n题目要求，经过一次二重的装饰器，保留原来函数的 `__name__` 和 `__doc__`。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 `__name__` 和 `__doc__`  得到保留，及为原函数的值。\n\n依照题目给的例子，就是输出是被 decorator wraps 修饰过的 `wrapper` 函数，即函数主体和功能还是 `wrapper`，但因为被 `wraps` 装饰了，输出的 `wrapper` 函数的  `__name__` 和 `__doc__`  值为原函数 `return_one` 的值。\n\n<!--more-->\n\n## My Solution\n\n```python\ndef wraps(func):\n    def first(wrapper):\n        return func\n    return first\n```\n\n我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 `wrapper` 函数的。\n\n## Other Solution\n\n [siebenschlaefer](https://www.codewars.com/users/siebenschlaefer)\n\n```python\ndef wraps(wrapped):\n    def wrapper(func):\n        for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                pass\n            else:\n                setattr(func, attr, value)\n        func.__dict__.update(getattr(wrapped, attr, {}))\n        func.__wrapped__ = wrapped\n        return func\n    return wrapper\n```\n\n首先注意一下对应关系。经过一次二重的装饰后，\n`wrapped` ➡️ `return_one`\n`func` ➡️ `wrapper`\n\n目标是输出 `func` ，但要把 `func` 的 `__name__` 和 `__doc__` 进行修改。修改这些 built-in 的值用到了 `getattr()` 和 `setattr()`。\n\n>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.\n>\n>There's no reason to do `getattr(x, 'foobar')`, but you might have a variable called `attr` that could be set to \"foobar\" or \"otherAttr\", and then do `getattr(x, attr)`.\n\n`try`…`except`… `else`，`else` 后面是当 `try` 中的内容无错误时才执行的，否则时执行 `except` 中的内容。\n\n>`try`:\n>\tNormal execution block\n>`except` A:\n>\tException A handle\n>`except` B:\n>\tException B handle\n>`except`:\n>\tOther exception handleelse:\n>`else`:\n>\tif no exception,get here\n>`finally`:\n>\tprint(\"finally\")   \n\n [Voile](https://www.codewars.com/users/Voile)\n\n```python\ndef wraps(func):\n    def f(g):\n        g.__name__ = func.__name__\n        g.__doc__ = func.__doc__\n        return g\n    return f\n```\n\nVoile 的解法更简洁。\n\n参考文章：\n\n- [Why use setattr() and getattr() built-ins?](https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins)","source":"_posts/@wraps | 6kyu.md","raw":"---\ntitle: '@wraps | 6kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## 要点\n\n- `decorator` 装饰器用法\n- `try`...`except`... `else` control flow\n- `getattr()` 和 `setattr()`\n- `__dict__.update()`\n\n## Details\n\nImplement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here's an example :\n\n```python\ndef identity(func):\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    \"\"\"Wraps func\"\"\"\n    return func(*args, **kwargs)\n  return wrapper\n\n@identity\ndef return_one():\n  \"\"\"Return one\"\"\"\n  return 1\n\nreturn_one.__name__ == 'return_one' # If wraps hadn't been used, __name__ would be equal to 'wrapper'\nreturn_one.__doc__ == 'Return one' # If wraps hadn't been used, __doc__ would be equal to 'Wraps func'\n```\n\n**Note: of course, you may not use the functools module for this kata.**\n\n题目要求，经过一次二重的装饰器，保留原来函数的 `__name__` 和 `__doc__`。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 `__name__` 和 `__doc__`  得到保留，及为原函数的值。\n\n依照题目给的例子，就是输出是被 decorator wraps 修饰过的 `wrapper` 函数，即函数主体和功能还是 `wrapper`，但因为被 `wraps` 装饰了，输出的 `wrapper` 函数的  `__name__` 和 `__doc__`  值为原函数 `return_one` 的值。\n\n<!--more-->\n\n## My Solution\n\n```python\ndef wraps(func):\n    def first(wrapper):\n        return func\n    return first\n```\n\n我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 `wrapper` 函数的。\n\n## Other Solution\n\n [siebenschlaefer](https://www.codewars.com/users/siebenschlaefer)\n\n```python\ndef wraps(wrapped):\n    def wrapper(func):\n        for attr in ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'):\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                pass\n            else:\n                setattr(func, attr, value)\n        func.__dict__.update(getattr(wrapped, attr, {}))\n        func.__wrapped__ = wrapped\n        return func\n    return wrapper\n```\n\n首先注意一下对应关系。经过一次二重的装饰后，\n`wrapped` ➡️ `return_one`\n`func` ➡️ `wrapper`\n\n目标是输出 `func` ，但要把 `func` 的 `__name__` 和 `__doc__` 进行修改。修改这些 built-in 的值用到了 `getattr()` 和 `setattr()`。\n\n>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.\n>\n>There's no reason to do `getattr(x, 'foobar')`, but you might have a variable called `attr` that could be set to \"foobar\" or \"otherAttr\", and then do `getattr(x, attr)`.\n\n`try`…`except`… `else`，`else` 后面是当 `try` 中的内容无错误时才执行的，否则时执行 `except` 中的内容。\n\n>`try`:\n>\tNormal execution block\n>`except` A:\n>\tException A handle\n>`except` B:\n>\tException B handle\n>`except`:\n>\tOther exception handleelse:\n>`else`:\n>\tif no exception,get here\n>`finally`:\n>\tprint(\"finally\")   \n\n [Voile](https://www.codewars.com/users/Voile)\n\n```python\ndef wraps(func):\n    def f(g):\n        g.__name__ = func.__name__\n        g.__doc__ = func.__doc__\n        return g\n    return f\n```\n\nVoile 的解法更简洁。\n\n参考文章：\n\n- [Why use setattr() and getattr() built-ins?](https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins)","slug":"@wraps | 6kyu","published":1,"updated":"2019-01-22T15:14:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx220007rg1vaqug11qj","content":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li><code>decorator</code> 装饰器用法</li>\n<li><code>try</code>…<code>except</code>… <code>else</code> control flow</li>\n<li><code>getattr()</code> 和 <code>setattr()</code></li>\n<li><code>__dict__.update()</code></li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :</p>\n<pre><code class=\"python\">def identity(func):\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    &quot;&quot;&quot;Wraps func&quot;&quot;&quot;\n    return func(*args, **kwargs)\n  return wrapper\n\n@identity\ndef return_one():\n  &quot;&quot;&quot;Return one&quot;&quot;&quot;\n  return 1\n\nreturn_one.__name__ == &#39;return_one&#39; # If wraps hadn&#39;t been used, __name__ would be equal to &#39;wrapper&#39;\nreturn_one.__doc__ == &#39;Return one&#39; # If wraps hadn&#39;t been used, __doc__ would be equal to &#39;Wraps func&#39;\n</code></pre>\n<p><strong>Note: of course, you may not use the functools module for this kata.</strong></p>\n<p>题目要求，经过一次二重的装饰器，保留原来函数的 <code>__name__</code> 和 <code>__doc__</code>。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 <code>__name__</code> 和 <code>__doc__</code>  得到保留，及为原函数的值。</p>\n<p>依照题目给的例子，就是输出是被 decorator wraps 修饰过的 <code>wrapper</code> 函数，即函数主体和功能还是 <code>wrapper</code>，但因为被 <code>wraps</code> 装饰了，输出的 <code>wrapper</code> 函数的  <code>__name__</code> 和 <code>__doc__</code>  值为原函数 <code>return_one</code> 的值。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">def wraps(func):\n    def first(wrapper):\n        return func\n    return first\n</code></pre>\n<p>我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 <code>wrapper</code> 函数的。</p>\n<h2 id=\"Other-Solution\"><a href=\"#Other-Solution\" class=\"headerlink\" title=\"Other Solution\"></a>Other Solution</h2><p> <a href=\"https://www.codewars.com/users/siebenschlaefer\">siebenschlaefer</a></p>\n<pre><code class=\"python\">def wraps(wrapped):\n    def wrapper(func):\n        for attr in (&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;):\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                pass\n            else:\n                setattr(func, attr, value)\n        func.__dict__.update(getattr(wrapped, attr, &#123;&#125;))\n        func.__wrapped__ = wrapped\n        return func\n    return wrapper\n</code></pre>\n<p>首先注意一下对应关系。经过一次二重的装饰后，<br><code>wrapped</code> ➡️ <code>return_one</code><br><code>func</code> ➡️ <code>wrapper</code></p>\n<p>目标是输出 <code>func</code> ，但要把 <code>func</code> 的 <code>__name__</code> 和 <code>__doc__</code> 进行修改。修改这些 built-in 的值用到了 <code>getattr()</code> 和 <code>setattr()</code>。</p>\n<blockquote>\n<p>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.</p>\n<p>There’s no reason to do <code>getattr(x, &#39;foobar&#39;)</code>, but you might have a variable called <code>attr</code> that could be set to “foobar” or “otherAttr”, and then do <code>getattr(x, attr)</code>.</p>\n</blockquote>\n<p><code>try</code>…<code>except</code>… <code>else</code>，<code>else</code> 后面是当 <code>try</code> 中的内容无错误时才执行的，否则时执行 <code>except</code> 中的内容。</p>\n<blockquote>\n<p><code>try</code>:<br>   Normal execution block<br><code>except</code> A:<br>   Exception A handle<br><code>except</code> B:<br>   Exception B handle<br><code>except</code>:<br>   Other exception handleelse:<br><code>else</code>:<br>   if no exception,get here<br><code>finally</code>:<br>   print(“finally”)   </p>\n</blockquote>\n<p> <a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"python\">def wraps(func):\n    def f(g):\n        g.__name__ = func.__name__\n        g.__doc__ = func.__doc__\n        return g\n    return f\n</code></pre>\n<p>Voile 的解法更简洁。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins\">Why use setattr() and getattr() built-ins?</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li><code>decorator</code> 装饰器用法</li>\n<li><code>try</code>…<code>except</code>… <code>else</code> control flow</li>\n<li><code>getattr()</code> 和 <code>setattr()</code></li>\n<li><code>__dict__.update()</code></li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :</p>\n<pre><code class=\"python\">def identity(func):\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    &quot;&quot;&quot;Wraps func&quot;&quot;&quot;\n    return func(*args, **kwargs)\n  return wrapper\n\n@identity\ndef return_one():\n  &quot;&quot;&quot;Return one&quot;&quot;&quot;\n  return 1\n\nreturn_one.__name__ == &#39;return_one&#39; # If wraps hadn&#39;t been used, __name__ would be equal to &#39;wrapper&#39;\nreturn_one.__doc__ == &#39;Return one&#39; # If wraps hadn&#39;t been used, __doc__ would be equal to &#39;Wraps func&#39;\n</code></pre>\n<p><strong>Note: of course, you may not use the functools module for this kata.</strong></p>\n<p>题目要求，经过一次二重的装饰器，保留原来函数的 <code>__name__</code> 和 <code>__doc__</code>。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 <code>__name__</code> 和 <code>__doc__</code>  得到保留，及为原函数的值。</p>\n<p>依照题目给的例子，就是输出是被 decorator wraps 修饰过的 <code>wrapper</code> 函数，即函数主体和功能还是 <code>wrapper</code>，但因为被 <code>wraps</code> 装饰了，输出的 <code>wrapper</code> 函数的  <code>__name__</code> 和 <code>__doc__</code>  值为原函数 <code>return_one</code> 的值。</p>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">def wraps(func):\n    def first(wrapper):\n        return func\n    return first\n</code></pre>\n<p>我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 <code>wrapper</code> 函数的。</p>\n<h2 id=\"Other-Solution\"><a href=\"#Other-Solution\" class=\"headerlink\" title=\"Other Solution\"></a>Other Solution</h2><p> <a href=\"https://www.codewars.com/users/siebenschlaefer\">siebenschlaefer</a></p>\n<pre><code class=\"python\">def wraps(wrapped):\n    def wrapper(func):\n        for attr in (&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;):\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                pass\n            else:\n                setattr(func, attr, value)\n        func.__dict__.update(getattr(wrapped, attr, &#123;&#125;))\n        func.__wrapped__ = wrapped\n        return func\n    return wrapper\n</code></pre>\n<p>首先注意一下对应关系。经过一次二重的装饰后，<br><code>wrapped</code> ➡️ <code>return_one</code><br><code>func</code> ➡️ <code>wrapper</code></p>\n<p>目标是输出 <code>func</code> ，但要把 <code>func</code> 的 <code>__name__</code> 和 <code>__doc__</code> 进行修改。修改这些 built-in 的值用到了 <code>getattr()</code> 和 <code>setattr()</code>。</p>\n<blockquote>\n<p>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.</p>\n<p>There’s no reason to do <code>getattr(x, &#39;foobar&#39;)</code>, but you might have a variable called <code>attr</code> that could be set to “foobar” or “otherAttr”, and then do <code>getattr(x, attr)</code>.</p>\n</blockquote>\n<p><code>try</code>…<code>except</code>… <code>else</code>，<code>else</code> 后面是当 <code>try</code> 中的内容无错误时才执行的，否则时执行 <code>except</code> 中的内容。</p>\n<blockquote>\n<p><code>try</code>:<br>   Normal execution block<br><code>except</code> A:<br>   Exception A handle<br><code>except</code> B:<br>   Exception B handle<br><code>except</code>:<br>   Other exception handleelse:<br><code>else</code>:<br>   if no exception,get here<br><code>finally</code>:<br>   print(“finally”)   </p>\n</blockquote>\n<p> <a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"python\">def wraps(func):\n    def f(g):\n        g.__name__ = func.__name__\n        g.__doc__ = func.__doc__\n        return g\n    return f\n</code></pre>\n<p>Voile 的解法更简洁。</p>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins\">Why use setattr() and getattr() built-ins?</a></li>\n</ul>"},{"title":"Argument Mapper | 5kyu","date":"2019-01-22T15:15:24.000Z","_content":"\n## Details\n\nAs part of a broader functionality you need to develop an argument mapper.\n\nThe function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.\n\nThe usage is:\n\n```javascript\nfunction func1(arg1, arg2) { ... }\n\nvar map = createArgumentMap(func1,'valueOfArg1', 'valueOfArg2');\nconsole.log(map['arg1']);  // writes 'valueOfArg1'\nconsole.log(map['arg2']);  // writes 'valueOfArg2'\n```\n\nThe passed values are in the same order as they appear in the function object.\n\nInvalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.\n\nHajime!\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction createArgumentMap(func) {\n    // create an argument map and return it\n    let args = Array.prototype.slice.call(arguments,1);\n    let res = {};\n    for (var i = 1; i <= args.length; i++) {\n        res['a' + i] = args[i-1]\n    }\n    return res\n  }\n```\n\n关于 JavaScript 中 arguments 的性质参看：[Arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\n\n`res['a'+i]` 是为了契合 test 中都是用形如 map[a1] map[a2] 等来 check 答案的。这里我的方法有些取巧。实际上需要得到的是实际定义函数时使用的参数名称，就像上次 review 中那样，要用到 `.toString()` 和正则表达式。\n\n## Other Solutions\n\n[colbydauph](https://www.codewars.com/users/colbydauph)\n\n```javascript\nfunction createArgumentMap(func) {\n  var args = (/function\\s[^(]*\\(([^)]+)\\)/g.exec(func.toString()) || ['']).pop().split(/,/g);\n  return Array.prototype.slice.call(arguments, 1).reduce(function(p, c, i){ return p[args[i]] = c, p }, {});\n}\n```\n\n`reduce()` 中 callback 函数的三个参数，依次分别是 `accumulator`, `currentValue`, `currentIndex`。对应代码中的 `function(p, c, i){...}`\n\n正则表达式分析：\n\n`/function\\s[^(]*\\(([^)]+)\\)/g`\n\n- `/…/g` : 表明正则表达式 global 模式，找到所有可能的 match，而不是仅仅是找到第一个 mathc 就停下来。\n- `function\\s` : 以 function 开头，紧接着是一个 space 空格 `\\s`。\n- `[^(]*` : 0 个或多个非 `(` 的字符。\n- `\\(`: 匹配左括号 `(`。\n- `([^)]+)`: 1个或多个非 `)` 的字符。注意这里用括号括住，那么输出匹配结果时也会把这个括号括住的匹配输出来。\n- `\\)`: 匹配右括号 `)`。\n\n```javascript\n>(/function\\s[^(]*\\(([^)]+)\\)/g.exec(func1.toString()))\n[ 'function func1(arg1, arg2)',\n  'arg1, arg2',\n  index: 0,\n  input: 'function func1(arg1, arg2) { console.log(arg1, arg2) }' ]\n>(/function\\s[^(]*\\([^)]+\\)/g.exec(func1.toString()))\n[ 'function func1(arg1, arg2)',\n  index: 0,\n  input: 'function func1(arg1, arg2) { console.log(arg1, arg2) }' ]\n>\n```\n\n上述展示了加中间那对括号，和不加括号时的区别。\n\n另外注意这里的 `.split(/,/g)` 方法的参数。这里的参数并不是两个。而是一个，一个正则表达式，global 模式匹配单字符 `,`，用正则表达式的 `/.../g` 扩起来。同理也可以写成 `.split(',')`。\n\n`.reduce()`方法使用及参数说明：[Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n关于最后在 reduce 的 callback 函数中，return 那里出现的 comma，`return p[args[i]] = c, p`，其实就是多个语句的简写，先进行赋值，然后输出 `p`。参见 stack overflow 上的解释：[return statement with multiple comma separated values](https://stackoverflow.com/questions/10284536/return-statement-with-multiple-comma-separated-values)\n\n> It's the [comma operator](http://es5.github.com/#x11.14). It runs a series of expressions, in order, and then returns the result of the *last* of them.  \n\n[stnever](https://www.codewars.com/users/stnever)\n\n```javascript\nfunction createArgumentMap(func) {\n  var argumentNames = getArgumentNames(func);\n  var argumentValues = arguments;\n  var result = {};\n  argumentNames.forEach(function(key, index) {\n    result[key] = argumentValues[index+1];    \n  });\n  return result;\n}\n\n// shamelessly copied from http://stackoverflow.com/questions/1007981\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getArgumentNames(func) {\n  var fnStr = func.toString().replace(STRIP_COMMENTS, '')\n  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)\n  if(result === null)\n     result = []\n  return result\n}\n```\n\n","source":"_posts/Argument Mapper | 5kyu.md","raw":"---\ntitle: 'Argument Mapper | 5kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## Details\n\nAs part of a broader functionality you need to develop an argument mapper.\n\nThe function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.\n\nThe usage is:\n\n```javascript\nfunction func1(arg1, arg2) { ... }\n\nvar map = createArgumentMap(func1,'valueOfArg1', 'valueOfArg2');\nconsole.log(map['arg1']);  // writes 'valueOfArg1'\nconsole.log(map['arg2']);  // writes 'valueOfArg2'\n```\n\nThe passed values are in the same order as they appear in the function object.\n\nInvalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.\n\nHajime!\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction createArgumentMap(func) {\n    // create an argument map and return it\n    let args = Array.prototype.slice.call(arguments,1);\n    let res = {};\n    for (var i = 1; i <= args.length; i++) {\n        res['a' + i] = args[i-1]\n    }\n    return res\n  }\n```\n\n关于 JavaScript 中 arguments 的性质参看：[Arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\n\n`res['a'+i]` 是为了契合 test 中都是用形如 map[a1] map[a2] 等来 check 答案的。这里我的方法有些取巧。实际上需要得到的是实际定义函数时使用的参数名称，就像上次 review 中那样，要用到 `.toString()` 和正则表达式。\n\n## Other Solutions\n\n[colbydauph](https://www.codewars.com/users/colbydauph)\n\n```javascript\nfunction createArgumentMap(func) {\n  var args = (/function\\s[^(]*\\(([^)]+)\\)/g.exec(func.toString()) || ['']).pop().split(/,/g);\n  return Array.prototype.slice.call(arguments, 1).reduce(function(p, c, i){ return p[args[i]] = c, p }, {});\n}\n```\n\n`reduce()` 中 callback 函数的三个参数，依次分别是 `accumulator`, `currentValue`, `currentIndex`。对应代码中的 `function(p, c, i){...}`\n\n正则表达式分析：\n\n`/function\\s[^(]*\\(([^)]+)\\)/g`\n\n- `/…/g` : 表明正则表达式 global 模式，找到所有可能的 match，而不是仅仅是找到第一个 mathc 就停下来。\n- `function\\s` : 以 function 开头，紧接着是一个 space 空格 `\\s`。\n- `[^(]*` : 0 个或多个非 `(` 的字符。\n- `\\(`: 匹配左括号 `(`。\n- `([^)]+)`: 1个或多个非 `)` 的字符。注意这里用括号括住，那么输出匹配结果时也会把这个括号括住的匹配输出来。\n- `\\)`: 匹配右括号 `)`。\n\n```javascript\n>(/function\\s[^(]*\\(([^)]+)\\)/g.exec(func1.toString()))\n[ 'function func1(arg1, arg2)',\n  'arg1, arg2',\n  index: 0,\n  input: 'function func1(arg1, arg2) { console.log(arg1, arg2) }' ]\n>(/function\\s[^(]*\\([^)]+\\)/g.exec(func1.toString()))\n[ 'function func1(arg1, arg2)',\n  index: 0,\n  input: 'function func1(arg1, arg2) { console.log(arg1, arg2) }' ]\n>\n```\n\n上述展示了加中间那对括号，和不加括号时的区别。\n\n另外注意这里的 `.split(/,/g)` 方法的参数。这里的参数并不是两个。而是一个，一个正则表达式，global 模式匹配单字符 `,`，用正则表达式的 `/.../g` 扩起来。同理也可以写成 `.split(',')`。\n\n`.reduce()`方法使用及参数说明：[Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n关于最后在 reduce 的 callback 函数中，return 那里出现的 comma，`return p[args[i]] = c, p`，其实就是多个语句的简写，先进行赋值，然后输出 `p`。参见 stack overflow 上的解释：[return statement with multiple comma separated values](https://stackoverflow.com/questions/10284536/return-statement-with-multiple-comma-separated-values)\n\n> It's the [comma operator](http://es5.github.com/#x11.14). It runs a series of expressions, in order, and then returns the result of the *last* of them.  \n\n[stnever](https://www.codewars.com/users/stnever)\n\n```javascript\nfunction createArgumentMap(func) {\n  var argumentNames = getArgumentNames(func);\n  var argumentValues = arguments;\n  var result = {};\n  argumentNames.forEach(function(key, index) {\n    result[key] = argumentValues[index+1];    \n  });\n  return result;\n}\n\n// shamelessly copied from http://stackoverflow.com/questions/1007981\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getArgumentNames(func) {\n  var fnStr = func.toString().replace(STRIP_COMMENTS, '')\n  var result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)\n  if(result === null)\n     result = []\n  return result\n}\n```\n\n","slug":"Argument Mapper | 5kyu","published":1,"updated":"2019-01-22T15:15:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx220008rg1vc6b6gsvk","content":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>As part of a broader functionality you need to develop an argument mapper.</p>\n<p>The function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.</p>\n<p>The usage is:</p>\n<pre><code class=\"javascript\">function func1(arg1, arg2) &#123; ... &#125;\n\nvar map = createArgumentMap(func1,&#39;valueOfArg1&#39;, &#39;valueOfArg2&#39;);\nconsole.log(map[&#39;arg1&#39;]);  // writes &#39;valueOfArg1&#39;\nconsole.log(map[&#39;arg2&#39;]);  // writes &#39;valueOfArg2&#39;\n</code></pre>\n<p>The passed values are in the same order as they appear in the function object.</p>\n<p>Invalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.</p>\n<p>Hajime!</p>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n    // create an argument map and return it\n    let args = Array.prototype.slice.call(arguments,1);\n    let res = &#123;&#125;;\n    for (var i = 1; i &lt;= args.length; i++) &#123;\n        res[&#39;a&#39; + i] = args[i-1]\n    &#125;\n    return res\n  &#125;\n</code></pre>\n<p>关于 JavaScript 中 arguments 的性质参看：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\">Arguments object</a></p>\n<p><code>res[&#39;a&#39;+i]</code> 是为了契合 test 中都是用形如 map[a1] map[a2] 等来 check 答案的。这里我的方法有些取巧。实际上需要得到的是实际定义函数时使用的参数名称，就像上次 review 中那样，要用到 <code>.toString()</code> 和正则表达式。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p><a href=\"https://www.codewars.com/users/colbydauph\">colbydauph</a></p>\n<pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n  var args = (/function\\s[^(]*\\(([^)]+)\\)/g.exec(func.toString()) || [&#39;&#39;]).pop().split(/,/g);\n  return Array.prototype.slice.call(arguments, 1).reduce(function(p, c, i)&#123; return p[args[i]] = c, p &#125;, &#123;&#125;);\n&#125;\n</code></pre>\n<p><code>reduce()</code> 中 callback 函数的三个参数，依次分别是 <code>accumulator</code>, <code>currentValue</code>, <code>currentIndex</code>。对应代码中的 <code>function(p, c, i)&#123;...&#125;</code></p>\n<p>正则表达式分析：</p>\n<p><code>/function\\s[^(]*\\(([^)]+)\\)/g</code></p>\n<ul>\n<li><code>/…/g</code> : 表明正则表达式 global 模式，找到所有可能的 match，而不是仅仅是找到第一个 mathc 就停下来。</li>\n<li><code>function\\s</code> : 以 function 开头，紧接着是一个 space 空格 <code>\\s</code>。</li>\n<li><code>[^(]*</code> : 0 个或多个非 <code>(</code> 的字符。</li>\n<li><code>\\(</code>: 匹配左括号 <code>(</code>。</li>\n<li><code>([^)]+)</code>: 1个或多个非 <code>)</code> 的字符。注意这里用括号括住，那么输出匹配结果时也会把这个括号括住的匹配输出来。</li>\n<li><code>\\)</code>: 匹配右括号 <code>)</code>。</li>\n</ul>\n<pre><code class=\"javascript\">&gt;(/function\\s[^(]*\\(([^)]+)\\)/g.exec(func1.toString()))\n[ &#39;function func1(arg1, arg2)&#39;,\n  &#39;arg1, arg2&#39;,\n  index: 0,\n  input: &#39;function func1(arg1, arg2) &#123; console.log(arg1, arg2) &#125;&#39; ]\n&gt;(/function\\s[^(]*\\([^)]+\\)/g.exec(func1.toString()))\n[ &#39;function func1(arg1, arg2)&#39;,\n  index: 0,\n  input: &#39;function func1(arg1, arg2) &#123; console.log(arg1, arg2) &#125;&#39; ]\n&gt;\n</code></pre>\n<p>上述展示了加中间那对括号，和不加括号时的区别。</p>\n<p>另外注意这里的 <code>.split(/,/g)</code> 方法的参数。这里的参数并不是两个。而是一个，一个正则表达式，global 模式匹配单字符 <code>,</code>，用正则表达式的 <code>/.../g</code> 扩起来。同理也可以写成 <code>.split(&#39;,&#39;)</code>。</p>\n<p><code>.reduce()</code>方法使用及参数说明：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\">Array.prototype.reduce()</a></p>\n<p>关于最后在 reduce 的 callback 函数中，return 那里出现的 comma，<code>return p[args[i]] = c, p</code>，其实就是多个语句的简写，先进行赋值，然后输出 <code>p</code>。参见 stack overflow 上的解释：<a href=\"https://stackoverflow.com/questions/10284536/return-statement-with-multiple-comma-separated-values\">return statement with multiple comma separated values</a></p>\n<blockquote>\n<p>It’s the <a href=\"http://es5.github.com/#x11.14\">comma operator</a>. It runs a series of expressions, in order, and then returns the result of the <em>last</em> of them.  </p>\n</blockquote>\n<p><a href=\"https://www.codewars.com/users/stnever\">stnever</a></p>\n<pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n  var argumentNames = getArgumentNames(func);\n  var argumentValues = arguments;\n  var result = &#123;&#125;;\n  argumentNames.forEach(function(key, index) &#123;\n    result[key] = argumentValues[index+1];    \n  &#125;);\n  return result;\n&#125;\n\n// shamelessly copied from http://stackoverflow.com/questions/1007981\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getArgumentNames(func) &#123;\n  var fnStr = func.toString().replace(STRIP_COMMENTS, &#39;&#39;)\n  var result = fnStr.slice(fnStr.indexOf(&#39;(&#39;)+1, fnStr.indexOf(&#39;)&#39;)).match(ARGUMENT_NAMES)\n  if(result === null)\n     result = []\n  return result\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>As part of a broader functionality you need to develop an argument mapper.</p>\n<p>The function receives a function object as first parameter and an unknown number of arguments [zero to many]. You have to return an associative array that maps the name of an argument and its related value.</p>\n<p>The usage is:</p>\n<pre><code class=\"javascript\">function func1(arg1, arg2) &#123; ... &#125;\n\nvar map = createArgumentMap(func1,&#39;valueOfArg1&#39;, &#39;valueOfArg2&#39;);\nconsole.log(map[&#39;arg1&#39;]);  // writes &#39;valueOfArg1&#39;\nconsole.log(map[&#39;arg2&#39;]);  // writes &#39;valueOfArg2&#39;\n</code></pre>\n<p>The passed values are in the same order as they appear in the function object.</p>\n<p>Invalid inputs, e.g. non-function objects, or wrong number of arguments, are not considered.</p>\n<p>Hajime!</p>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n    // create an argument map and return it\n    let args = Array.prototype.slice.call(arguments,1);\n    let res = &#123;&#125;;\n    for (var i = 1; i &lt;= args.length; i++) &#123;\n        res[&#39;a&#39; + i] = args[i-1]\n    &#125;\n    return res\n  &#125;\n</code></pre>\n<p>关于 JavaScript 中 arguments 的性质参看：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\">Arguments object</a></p>\n<p><code>res[&#39;a&#39;+i]</code> 是为了契合 test 中都是用形如 map[a1] map[a2] 等来 check 答案的。这里我的方法有些取巧。实际上需要得到的是实际定义函数时使用的参数名称，就像上次 review 中那样，要用到 <code>.toString()</code> 和正则表达式。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p><a href=\"https://www.codewars.com/users/colbydauph\">colbydauph</a></p>\n<pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n  var args = (/function\\s[^(]*\\(([^)]+)\\)/g.exec(func.toString()) || [&#39;&#39;]).pop().split(/,/g);\n  return Array.prototype.slice.call(arguments, 1).reduce(function(p, c, i)&#123; return p[args[i]] = c, p &#125;, &#123;&#125;);\n&#125;\n</code></pre>\n<p><code>reduce()</code> 中 callback 函数的三个参数，依次分别是 <code>accumulator</code>, <code>currentValue</code>, <code>currentIndex</code>。对应代码中的 <code>function(p, c, i)&#123;...&#125;</code></p>\n<p>正则表达式分析：</p>\n<p><code>/function\\s[^(]*\\(([^)]+)\\)/g</code></p>\n<ul>\n<li><code>/…/g</code> : 表明正则表达式 global 模式，找到所有可能的 match，而不是仅仅是找到第一个 mathc 就停下来。</li>\n<li><code>function\\s</code> : 以 function 开头，紧接着是一个 space 空格 <code>\\s</code>。</li>\n<li><code>[^(]*</code> : 0 个或多个非 <code>(</code> 的字符。</li>\n<li><code>\\(</code>: 匹配左括号 <code>(</code>。</li>\n<li><code>([^)]+)</code>: 1个或多个非 <code>)</code> 的字符。注意这里用括号括住，那么输出匹配结果时也会把这个括号括住的匹配输出来。</li>\n<li><code>\\)</code>: 匹配右括号 <code>)</code>。</li>\n</ul>\n<pre><code class=\"javascript\">&gt;(/function\\s[^(]*\\(([^)]+)\\)/g.exec(func1.toString()))\n[ &#39;function func1(arg1, arg2)&#39;,\n  &#39;arg1, arg2&#39;,\n  index: 0,\n  input: &#39;function func1(arg1, arg2) &#123; console.log(arg1, arg2) &#125;&#39; ]\n&gt;(/function\\s[^(]*\\([^)]+\\)/g.exec(func1.toString()))\n[ &#39;function func1(arg1, arg2)&#39;,\n  index: 0,\n  input: &#39;function func1(arg1, arg2) &#123; console.log(arg1, arg2) &#125;&#39; ]\n&gt;\n</code></pre>\n<p>上述展示了加中间那对括号，和不加括号时的区别。</p>\n<p>另外注意这里的 <code>.split(/,/g)</code> 方法的参数。这里的参数并不是两个。而是一个，一个正则表达式，global 模式匹配单字符 <code>,</code>，用正则表达式的 <code>/.../g</code> 扩起来。同理也可以写成 <code>.split(&#39;,&#39;)</code>。</p>\n<p><code>.reduce()</code>方法使用及参数说明：<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\">Array.prototype.reduce()</a></p>\n<p>关于最后在 reduce 的 callback 函数中，return 那里出现的 comma，<code>return p[args[i]] = c, p</code>，其实就是多个语句的简写，先进行赋值，然后输出 <code>p</code>。参见 stack overflow 上的解释：<a href=\"https://stackoverflow.com/questions/10284536/return-statement-with-multiple-comma-separated-values\">return statement with multiple comma separated values</a></p>\n<blockquote>\n<p>It’s the <a href=\"http://es5.github.com/#x11.14\">comma operator</a>. It runs a series of expressions, in order, and then returns the result of the <em>last</em> of them.  </p>\n</blockquote>\n<p><a href=\"https://www.codewars.com/users/stnever\">stnever</a></p>\n<pre><code class=\"javascript\">function createArgumentMap(func) &#123;\n  var argumentNames = getArgumentNames(func);\n  var argumentValues = arguments;\n  var result = &#123;&#125;;\n  argumentNames.forEach(function(key, index) &#123;\n    result[key] = argumentValues[index+1];    \n  &#125;);\n  return result;\n&#125;\n\n// shamelessly copied from http://stackoverflow.com/questions/1007981\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getArgumentNames(func) &#123;\n  var fnStr = func.toString().replace(STRIP_COMMENTS, &#39;&#39;)\n  var result = fnStr.slice(fnStr.indexOf(&#39;(&#39;)+1, fnStr.indexOf(&#39;)&#39;)).match(ARGUMENT_NAMES)\n  if(result === null)\n     result = []\n  return result\n&#125;\n</code></pre>"},{"title":"Binary Search Trees | 5kyu","date":"2019-01-22T15:15:34.000Z","_content":"\n## 要点\n\n- `__str__()` 的几种定义方法：如  `\"%s\" % value`  和 `'{}'.format()`\n- A `and` B `and` C\n- `if`  … `else` 单行语句\n- `for` … `in` 单行语句\n- `join()` 函数\n- `str()` 函数与 `__str__()` 方法\n\n\n\n## Details\n\nA `Tree` consists of a root, which is of type `Node`, and possibly a left subtree of type `Tree` and possibly a right subtree of type `Tree`. If the left subtree is present, then all its nodes are less than the parent tree's root and if the right tree is present, then all its nodes are greater than the parent tree's root. In this kata, classes `Tree` and `Node` have been provided. However, the methods `__eq__`, `__ne__`, and `__str__` are missing from the `Tree` class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.\n\nAs an illustrative example, here is the string representation of a tree that has two nodes, 'B' at the root and 'C' at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: \n\n```python\n'[_ B [C]]'\n```\n\nThis tree is obtained by evaluating the following expression:\n\n```python\nTree(Node('B'), None, Tree(Node('C'))))\n```\n\nNotice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.\n\n<!--more-->\n\n## My Solution\n\n```python\nclass Tree(object):\n\n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n\n    def is_leaf(self):\n        return not(self.left or self.right)\n\n\n    def __str__(self):\n        rep = '['\n        if self.left is not None:\n            rep += self.left.__str__() + ' '\n        elif self.right is not None:\n            rep += '_ ' + self.root.__str__() + ' ' + self.right.__str__()\n            return rep + ']'\n        rep += self.root.__str__()\n        if self.right is not None:\n            rep += ' ' + self.right.__str__()\n        elif self.left is not None:\n            rep = self.left.__str__() + ' ' + self.root.__str__() + ' _'\n            return rep + ']'\n        return rep + ']'\n\n\n    def __eq__(self, other):\n        if (self is None) and (other is None):\n            return True\n        if self and other and self.root == other.root:\n            return (self.left == other.left) and (self.right == other.right)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self == other\n\n\nclass Node(object):\n\n    def __init__(self, value, weight=1):\n        self.value = value\n        self.weight = weight\n\n    def __str__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __gt__(self, other):\n        return self.value > other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ne__(self, other):\n        return self.value != other.value\n```\n\n## Other Solution\n\n [siebenschlaefer](https://www.codewars.com/users/siebenschlaefer)\n\n```python\nclass Tree(object):\n\t# ... 其余重复部分省略\n    def __str__(self):\n        if self.is_leaf():\n            return \"[%s]\" % self.root\n        return \"[%s %s %s]\" % (\n            self.left if self.left else \"_\",\n            self.root,\n            self.right if self.right else \"_\")\n\n    def __eq__(self, other):\n        if not other:\n            return False\n        return (\n            self.root == other.root and\n            self.left == other.left and\n            self.right == other.right)\n\n    def __ne__(self, other):\n        return not (self == other)\n    \n# ... 其余重复部分省略\n```\n\n这个在 `__str__()` 部分写得异常简洁，并且利用到了 `is_leaf()` 方法。如果  `is_leaf()` 返回值为 `True`，则说明 self 没有 left 和 right。还有 `if` 的单行写法，也要学会使用。\n\n`__eq__()` 方法的 `and` 连续使用，要用括号括起来。\n\n[Voile](https://www.codewars.com/users/Voile)\n\n```python\nclass Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if type(self.left) != Tree and type(self.right) != Tree: return '[{}]'.format(self.root)\n        if type(self.left) == Tree and type(self.right) == Tree: return '[{} {} {}]'.format(self.left, self.root, self.right)\n        return '[{}]'.format(' '.join(str(v) if v else '_' for v in [self.left, self.root, self.right]))\n    \n    def __eq__(self, other):\n        if self.root != other.root: return False\n        if type(self.left) != type(other.left): return False\n        if type(self.right) != type(other.right): return False\n        return self.left == other.left and self.right == other.right\n    \n    def __ne__(self, other):\n        return not self == other\n\n```\n\nVoile 在 `__str__()` 中用的 return 形式是 `'[{}]'.format()`，也是分了三种情况。注意第三种的单行写法，形如：\n\n```python\n>>> ' '.join(str(v) if v else '_' for v in [1, 0, 3])\n'1 _ 3'\n>>> ''.join(str(v) if v else '_' for v in [1, 0, 3])\n'1_3'\n```\n\n`__eq__()` 写法思路和我的写法差不多，都是在保证 `self.root == other.root` 的情况下，输出一个 `and` 并列语句，`self.left == other.left and self.right == other.right`。当然，他这里用 `type` 来判断是否是 Node 还是 None。\n\n [brettso](https://www.codewars.com/users/brettso)\n\n```python\nclass Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if self.is_leaf():\n            return '[' + self.root.value + ']'\n        left = \"_\" if not self.left else self.left.__str__()\n        right = \"_\" if not self.right else self.right.__str__()\n        return '[' + left + ' ' + self.root.value + ' ' + right + ']'    \n        \n    \n    def __eq__(self, other):\n        return self.__str__() == other.__str__()\n\n    \n    def __ne__(self, other):\n        return self.__str__() != other.__str__()\n```\n\n这个 `__eq__()` 的写法很巧妙啊，直接利用了 `__str__()` 来进行判断。","source":"_posts/Binary Search Trees | 5kyu.md","raw":"---\ntitle: 'Binary Search Trees | 5kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- Python\ncategories: \n- Coding\n---\n\n## 要点\n\n- `__str__()` 的几种定义方法：如  `\"%s\" % value`  和 `'{}'.format()`\n- A `and` B `and` C\n- `if`  … `else` 单行语句\n- `for` … `in` 单行语句\n- `join()` 函数\n- `str()` 函数与 `__str__()` 方法\n\n\n\n## Details\n\nA `Tree` consists of a root, which is of type `Node`, and possibly a left subtree of type `Tree` and possibly a right subtree of type `Tree`. If the left subtree is present, then all its nodes are less than the parent tree's root and if the right tree is present, then all its nodes are greater than the parent tree's root. In this kata, classes `Tree` and `Node` have been provided. However, the methods `__eq__`, `__ne__`, and `__str__` are missing from the `Tree` class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.\n\nAs an illustrative example, here is the string representation of a tree that has two nodes, 'B' at the root and 'C' at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: \n\n```python\n'[_ B [C]]'\n```\n\nThis tree is obtained by evaluating the following expression:\n\n```python\nTree(Node('B'), None, Tree(Node('C'))))\n```\n\nNotice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.\n\n<!--more-->\n\n## My Solution\n\n```python\nclass Tree(object):\n\n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n\n    def is_leaf(self):\n        return not(self.left or self.right)\n\n\n    def __str__(self):\n        rep = '['\n        if self.left is not None:\n            rep += self.left.__str__() + ' '\n        elif self.right is not None:\n            rep += '_ ' + self.root.__str__() + ' ' + self.right.__str__()\n            return rep + ']'\n        rep += self.root.__str__()\n        if self.right is not None:\n            rep += ' ' + self.right.__str__()\n        elif self.left is not None:\n            rep = self.left.__str__() + ' ' + self.root.__str__() + ' _'\n            return rep + ']'\n        return rep + ']'\n\n\n    def __eq__(self, other):\n        if (self is None) and (other is None):\n            return True\n        if self and other and self.root == other.root:\n            return (self.left == other.left) and (self.right == other.right)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self == other\n\n\nclass Node(object):\n\n    def __init__(self, value, weight=1):\n        self.value = value\n        self.weight = weight\n\n    def __str__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value < other.value\n\n    def __gt__(self, other):\n        return self.value > other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ne__(self, other):\n        return self.value != other.value\n```\n\n## Other Solution\n\n [siebenschlaefer](https://www.codewars.com/users/siebenschlaefer)\n\n```python\nclass Tree(object):\n\t# ... 其余重复部分省略\n    def __str__(self):\n        if self.is_leaf():\n            return \"[%s]\" % self.root\n        return \"[%s %s %s]\" % (\n            self.left if self.left else \"_\",\n            self.root,\n            self.right if self.right else \"_\")\n\n    def __eq__(self, other):\n        if not other:\n            return False\n        return (\n            self.root == other.root and\n            self.left == other.left and\n            self.right == other.right)\n\n    def __ne__(self, other):\n        return not (self == other)\n    \n# ... 其余重复部分省略\n```\n\n这个在 `__str__()` 部分写得异常简洁，并且利用到了 `is_leaf()` 方法。如果  `is_leaf()` 返回值为 `True`，则说明 self 没有 left 和 right。还有 `if` 的单行写法，也要学会使用。\n\n`__eq__()` 方法的 `and` 连续使用，要用括号括起来。\n\n[Voile](https://www.codewars.com/users/Voile)\n\n```python\nclass Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if type(self.left) != Tree and type(self.right) != Tree: return '[{}]'.format(self.root)\n        if type(self.left) == Tree and type(self.right) == Tree: return '[{} {} {}]'.format(self.left, self.root, self.right)\n        return '[{}]'.format(' '.join(str(v) if v else '_' for v in [self.left, self.root, self.right]))\n    \n    def __eq__(self, other):\n        if self.root != other.root: return False\n        if type(self.left) != type(other.left): return False\n        if type(self.right) != type(other.right): return False\n        return self.left == other.left and self.right == other.right\n    \n    def __ne__(self, other):\n        return not self == other\n\n```\n\nVoile 在 `__str__()` 中用的 return 形式是 `'[{}]'.format()`，也是分了三种情况。注意第三种的单行写法，形如：\n\n```python\n>>> ' '.join(str(v) if v else '_' for v in [1, 0, 3])\n'1 _ 3'\n>>> ''.join(str(v) if v else '_' for v in [1, 0, 3])\n'1_3'\n```\n\n`__eq__()` 写法思路和我的写法差不多，都是在保证 `self.root == other.root` 的情况下，输出一个 `and` 并列语句，`self.left == other.left and self.right == other.right`。当然，他这里用 `type` 来判断是否是 Node 还是 None。\n\n [brettso](https://www.codewars.com/users/brettso)\n\n```python\nclass Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root < root\n        if right: assert type(right) == Tree and root < right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if self.is_leaf():\n            return '[' + self.root.value + ']'\n        left = \"_\" if not self.left else self.left.__str__()\n        right = \"_\" if not self.right else self.right.__str__()\n        return '[' + left + ' ' + self.root.value + ' ' + right + ']'    \n        \n    \n    def __eq__(self, other):\n        return self.__str__() == other.__str__()\n\n    \n    def __ne__(self, other):\n        return self.__str__() != other.__str__()\n```\n\n这个 `__eq__()` 的写法很巧妙啊，直接利用了 `__str__()` 来进行判断。","slug":"Binary Search Trees | 5kyu","published":1,"updated":"2019-01-22T15:15:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx23000brg1v1ycthl09","content":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li><code>__str__()</code> 的几种定义方法：如  <code>&quot;%s&quot; % value</code>  和 <code>&#39;&#123;&#125;&#39;.format()</code></li>\n<li>A <code>and</code> B <code>and</code> C</li>\n<li><code>if</code>  … <code>else</code> 单行语句</li>\n<li><code>for</code> … <code>in</code> 单行语句</li>\n<li><code>join()</code> 函数</li>\n<li><code>str()</code> 函数与 <code>__str__()</code> 方法</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>A <code>Tree</code> consists of a root, which is of type <code>Node</code>, and possibly a left subtree of type <code>Tree</code> and possibly a right subtree of type <code>Tree</code>. If the left subtree is present, then all its nodes are less than the parent tree’s root and if the right tree is present, then all its nodes are greater than the parent tree’s root. In this kata, classes <code>Tree</code> and <code>Node</code> have been provided. However, the methods <code>__eq__</code>, <code>__ne__</code>, and <code>__str__</code> are missing from the <code>Tree</code> class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.</p>\n<p>As an illustrative example, here is the string representation of a tree that has two nodes, ‘B’ at the root and ‘C’ at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: </p>\n<pre><code class=\"python\">&#39;[_ B [C]]&#39;\n</code></pre>\n<p>This tree is obtained by evaluating the following expression:</p>\n<pre><code class=\"python\">Tree(Node(&#39;B&#39;), None, Tree(Node(&#39;C&#39;))))\n</code></pre>\n<p>Notice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">class Tree(object):\n\n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n\n    def is_leaf(self):\n        return not(self.left or self.right)\n\n\n    def __str__(self):\n        rep = &#39;[&#39;\n        if self.left is not None:\n            rep += self.left.__str__() + &#39; &#39;\n        elif self.right is not None:\n            rep += &#39;_ &#39; + self.root.__str__() + &#39; &#39; + self.right.__str__()\n            return rep + &#39;]&#39;\n        rep += self.root.__str__()\n        if self.right is not None:\n            rep += &#39; &#39; + self.right.__str__()\n        elif self.left is not None:\n            rep = self.left.__str__() + &#39; &#39; + self.root.__str__() + &#39; _&#39;\n            return rep + &#39;]&#39;\n        return rep + &#39;]&#39;\n\n\n    def __eq__(self, other):\n        if (self is None) and (other is None):\n            return True\n        if self and other and self.root == other.root:\n            return (self.left == other.left) and (self.right == other.right)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self == other\n\n\nclass Node(object):\n\n    def __init__(self, value, weight=1):\n        self.value = value\n        self.weight = weight\n\n    def __str__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value &lt; other.value\n\n    def __gt__(self, other):\n        return self.value &gt; other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ne__(self, other):\n        return self.value != other.value\n</code></pre>\n<h2 id=\"Other-Solution\"><a href=\"#Other-Solution\" class=\"headerlink\" title=\"Other Solution\"></a>Other Solution</h2><p> <a href=\"https://www.codewars.com/users/siebenschlaefer\">siebenschlaefer</a></p>\n<pre><code class=\"python\">class Tree(object):\n    # ... 其余重复部分省略\n    def __str__(self):\n        if self.is_leaf():\n            return &quot;[%s]&quot; % self.root\n        return &quot;[%s %s %s]&quot; % (\n            self.left if self.left else &quot;_&quot;,\n            self.root,\n            self.right if self.right else &quot;_&quot;)\n\n    def __eq__(self, other):\n        if not other:\n            return False\n        return (\n            self.root == other.root and\n            self.left == other.left and\n            self.right == other.right)\n\n    def __ne__(self, other):\n        return not (self == other)\n    \n# ... 其余重复部分省略\n</code></pre>\n<p>这个在 <code>__str__()</code> 部分写得异常简洁，并且利用到了 <code>is_leaf()</code> 方法。如果  <code>is_leaf()</code> 返回值为 <code>True</code>，则说明 self 没有 left 和 right。还有 <code>if</code> 的单行写法，也要学会使用。</p>\n<p><code>__eq__()</code> 方法的 <code>and</code> 连续使用，要用括号括起来。</p>\n<p><a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"python\">class Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if type(self.left) != Tree and type(self.right) != Tree: return &#39;[&#123;&#125;]&#39;.format(self.root)\n        if type(self.left) == Tree and type(self.right) == Tree: return &#39;[&#123;&#125; &#123;&#125; &#123;&#125;]&#39;.format(self.left, self.root, self.right)\n        return &#39;[&#123;&#125;]&#39;.format(&#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [self.left, self.root, self.right]))\n    \n    def __eq__(self, other):\n        if self.root != other.root: return False\n        if type(self.left) != type(other.left): return False\n        if type(self.right) != type(other.right): return False\n        return self.left == other.left and self.right == other.right\n    \n    def __ne__(self, other):\n        return not self == other\n</code></pre>\n<p>Voile 在 <code>__str__()</code> 中用的 return 形式是 <code>&#39;[&#123;&#125;]&#39;.format()</code>，也是分了三种情况。注意第三种的单行写法，形如：</p>\n<pre><code class=\"python\">&gt;&gt;&gt; &#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])\n&#39;1 _ 3&#39;\n&gt;&gt;&gt; &#39;&#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])\n&#39;1_3&#39;\n</code></pre>\n<p><code>__eq__()</code> 写法思路和我的写法差不多，都是在保证 <code>self.root == other.root</code> 的情况下，输出一个 <code>and</code> 并列语句，<code>self.left == other.left and self.right == other.right</code>。当然，他这里用 <code>type</code> 来判断是否是 Node 还是 None。</p>\n<p> <a href=\"https://www.codewars.com/users/brettso\">brettso</a></p>\n<pre><code class=\"python\">class Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if self.is_leaf():\n            return &#39;[&#39; + self.root.value + &#39;]&#39;\n        left = &quot;_&quot; if not self.left else self.left.__str__()\n        right = &quot;_&quot; if not self.right else self.right.__str__()\n        return &#39;[&#39; + left + &#39; &#39; + self.root.value + &#39; &#39; + right + &#39;]&#39;    \n        \n    \n    def __eq__(self, other):\n        return self.__str__() == other.__str__()\n\n    \n    def __ne__(self, other):\n        return self.__str__() != other.__str__()\n</code></pre>\n<p>这个 <code>__eq__()</code> 的写法很巧妙啊，直接利用了 <code>__str__()</code> 来进行判断。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li><code>__str__()</code> 的几种定义方法：如  <code>&quot;%s&quot; % value</code>  和 <code>&#39;&#123;&#125;&#39;.format()</code></li>\n<li>A <code>and</code> B <code>and</code> C</li>\n<li><code>if</code>  … <code>else</code> 单行语句</li>\n<li><code>for</code> … <code>in</code> 单行语句</li>\n<li><code>join()</code> 函数</li>\n<li><code>str()</code> 函数与 <code>__str__()</code> 方法</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>A <code>Tree</code> consists of a root, which is of type <code>Node</code>, and possibly a left subtree of type <code>Tree</code> and possibly a right subtree of type <code>Tree</code>. If the left subtree is present, then all its nodes are less than the parent tree’s root and if the right tree is present, then all its nodes are greater than the parent tree’s root. In this kata, classes <code>Tree</code> and <code>Node</code> have been provided. However, the methods <code>__eq__</code>, <code>__ne__</code>, and <code>__str__</code> are missing from the <code>Tree</code> class. Your job is to provide the implementation of these methods. The example test cases should provide enough information to implement these methods correctly.</p>\n<p>As an illustrative example, here is the string representation of a tree that has two nodes, ‘B’ at the root and ‘C’ at the root of the right subtree. The left subtree is missing and the right subtree is a leaf, i.e., has no subtrees: </p>\n<pre><code class=\"python\">&#39;[_ B [C]]&#39;\n</code></pre>\n<p>This tree is obtained by evaluating the following expression:</p>\n<pre><code class=\"python\">Tree(Node(&#39;B&#39;), None, Tree(Node(&#39;C&#39;))))\n</code></pre>\n<p>Notice in particular that when one subtree, but not both, is missing, an underscore is in its place, a single space separates the root node from the subtrees, and when both subtrees are missing, the root node is enclosed in brackets.</p>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"python\">class Tree(object):\n\n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n\n    def is_leaf(self):\n        return not(self.left or self.right)\n\n\n    def __str__(self):\n        rep = &#39;[&#39;\n        if self.left is not None:\n            rep += self.left.__str__() + &#39; &#39;\n        elif self.right is not None:\n            rep += &#39;_ &#39; + self.root.__str__() + &#39; &#39; + self.right.__str__()\n            return rep + &#39;]&#39;\n        rep += self.root.__str__()\n        if self.right is not None:\n            rep += &#39; &#39; + self.right.__str__()\n        elif self.left is not None:\n            rep = self.left.__str__() + &#39; &#39; + self.root.__str__() + &#39; _&#39;\n            return rep + &#39;]&#39;\n        return rep + &#39;]&#39;\n\n\n    def __eq__(self, other):\n        if (self is None) and (other is None):\n            return True\n        if self and other and self.root == other.root:\n            return (self.left == other.left) and (self.right == other.right)\n        else:\n            return False\n\n    def __ne__(self, other):\n        return not self == other\n\n\nclass Node(object):\n\n    def __init__(self, value, weight=1):\n        self.value = value\n        self.weight = weight\n\n    def __str__(self):\n        return str(self.value)\n\n    def __lt__(self, other):\n        return self.value &lt; other.value\n\n    def __gt__(self, other):\n        return self.value &gt; other.value\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ne__(self, other):\n        return self.value != other.value\n</code></pre>\n<h2 id=\"Other-Solution\"><a href=\"#Other-Solution\" class=\"headerlink\" title=\"Other Solution\"></a>Other Solution</h2><p> <a href=\"https://www.codewars.com/users/siebenschlaefer\">siebenschlaefer</a></p>\n<pre><code class=\"python\">class Tree(object):\n    # ... 其余重复部分省略\n    def __str__(self):\n        if self.is_leaf():\n            return &quot;[%s]&quot; % self.root\n        return &quot;[%s %s %s]&quot; % (\n            self.left if self.left else &quot;_&quot;,\n            self.root,\n            self.right if self.right else &quot;_&quot;)\n\n    def __eq__(self, other):\n        if not other:\n            return False\n        return (\n            self.root == other.root and\n            self.left == other.left and\n            self.right == other.right)\n\n    def __ne__(self, other):\n        return not (self == other)\n    \n# ... 其余重复部分省略\n</code></pre>\n<p>这个在 <code>__str__()</code> 部分写得异常简洁，并且利用到了 <code>is_leaf()</code> 方法。如果  <code>is_leaf()</code> 返回值为 <code>True</code>，则说明 self 没有 left 和 right。还有 <code>if</code> 的单行写法，也要学会使用。</p>\n<p><code>__eq__()</code> 方法的 <code>and</code> 连续使用，要用括号括起来。</p>\n<p><a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"python\">class Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if type(self.left) != Tree and type(self.right) != Tree: return &#39;[&#123;&#125;]&#39;.format(self.root)\n        if type(self.left) == Tree and type(self.right) == Tree: return &#39;[&#123;&#125; &#123;&#125; &#123;&#125;]&#39;.format(self.left, self.root, self.right)\n        return &#39;[&#123;&#125;]&#39;.format(&#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [self.left, self.root, self.right]))\n    \n    def __eq__(self, other):\n        if self.root != other.root: return False\n        if type(self.left) != type(other.left): return False\n        if type(self.right) != type(other.right): return False\n        return self.left == other.left and self.right == other.right\n    \n    def __ne__(self, other):\n        return not self == other\n</code></pre>\n<p>Voile 在 <code>__str__()</code> 中用的 return 形式是 <code>&#39;[&#123;&#125;]&#39;.format()</code>，也是分了三种情况。注意第三种的单行写法，形如：</p>\n<pre><code class=\"python\">&gt;&gt;&gt; &#39; &#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])\n&#39;1 _ 3&#39;\n&gt;&gt;&gt; &#39;&#39;.join(str(v) if v else &#39;_&#39; for v in [1, 0, 3])\n&#39;1_3&#39;\n</code></pre>\n<p><code>__eq__()</code> 写法思路和我的写法差不多，都是在保证 <code>self.root == other.root</code> 的情况下，输出一个 <code>and</code> 并列语句，<code>self.left == other.left and self.right == other.right</code>。当然，他这里用 <code>type</code> 来判断是否是 Node 还是 None。</p>\n<p> <a href=\"https://www.codewars.com/users/brettso\">brettso</a></p>\n<pre><code class=\"python\">class Tree(object):\n    \n    def __init__(self, root, left=None, right=None):\n        assert root and type(root) == Node\n        if left: assert type(left) == Tree and left.root &lt; root\n        if right: assert type(right) == Tree and root &lt; right.root\n\n        self.left = left\n        self.root = root\n        self.right = right\n        \n    def is_leaf(self):\n        return not(self.left or self.right)\n        \n    \n    def __str__(self):\n        if self.is_leaf():\n            return &#39;[&#39; + self.root.value + &#39;]&#39;\n        left = &quot;_&quot; if not self.left else self.left.__str__()\n        right = &quot;_&quot; if not self.right else self.right.__str__()\n        return &#39;[&#39; + left + &#39; &#39; + self.root.value + &#39; &#39; + right + &#39;]&#39;    \n        \n    \n    def __eq__(self, other):\n        return self.__str__() == other.__str__()\n\n    \n    def __ne__(self, other):\n        return self.__str__() != other.__str__()\n</code></pre>\n<p>这个 <code>__eq__()</code> 的写法很巧妙啊，直接利用了 <code>__str__()</code> 来进行判断。</p>"},{"title":"Born to be chained | 4kyu","date":"2019-01-22T15:15:53.000Z","_content":"\n- 对于 Object 的遍历；\n\n## Details\n\nFunction composition is a powerful technique. For example:\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\n\nfunction double(x) {\n  return sum(x, x);\n}\n\nfunction minus (x, y) {\n  return x - y;\n}\n\nfunction addOne(x) {\n  return sum(x, 1);\n}\n\ndouble(sum(2, 3)); // 10\n```\n\nBut in complex expressions, composition may be difficult to understand. For example:\n\n```javascript\ndouble(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72\n```\n\nIn this kata, we will implement a function that allows us to perform this by applying a fluid style:\n\n```javascript\nc.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72\n```\n\nYour job is implement the `chain` function:\n\n```javascript\nfunction chain(fns) {\n}\n\nvar c = chain({sum: sum, minus: minus, double: double, addOne: addOne});\n```\n\nAs you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the `execute`method.\n\nChained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.\n\nNote that the chain can be reused (the internal state is not stored):\n\n<!--more-->\n\n```javascript\nc.sum(3, 4).execute(); //7\nc.sum(1, 2).execute(); //3\n```\n\nOther examples:\n\n```javascript\nvar c1 = c.sum(1, 2);\nc1.execute(); // == fns.sum(1, 2) == 3\nc1.double().execute(); // == fns.double(fns.sum(1, 2)) == 6\nc1.addOne().execute(); // == fns.addOne(fns.sum(1, 2)) == 4\nc1.execute(); // == fns.sum(1, 2) == 3\n\nvar c2 = c1.sum(5);\nc2.addOne().execute(); // == fns.addOne(fns.sum(fns.sum(1, 2) 5)) == 9\nc2.sum(3).execute(); // == fns.sum(c1.sum(fns.sum(1, 2), 5), 3) == 11\nc2.execute(); // == fns.sum(fns.sum(1, 2), 5) == 8\n\nc1.execute(); // == fns.sum(1, 2) == 3\n```\n\n## Other Solutions\n\n [ooflorent](https://www.codewars.com/users/ooflorent), [ChungGor](https://www.codewars.com/users/ChungGor), [pompeu2004](https://www.codewars.com/users/pompeu2004), [guilhermeconti](https://www.codewars.com/users/guilhermeconti), [lwio](https://www.codewars.com/users/lwio) (plus 2 more warriors)\n\n```javascript\nfunction chain(fns) {\n  function ChainWrapper(x) {\n    this._ = x\n  }\n  \n  Object.keys(fns).forEach(function(prop) {\n    var fn = fns[prop]\n    \n    ChainWrapper.prototype[prop] = function() {\n      var args = [].slice.call(arguments)\n      if (this._ != null) args.unshift(this._)\n      \n      var x = fn.apply(null, args)\n      return new ChainWrapper(x)\n    }\n  })\n  \n  ChainWrapper.prototype.execute = function() {\n    return this._\n  }\n  \n  return new ChainWrapper()\n}\n```\n\nline 6: 关注一下对于一般 Object  的遍历方法。主要用到 `Object.keys()` 和 `forEach()`，另外相对应的也有 `Object.values()`。\n\nline 9: ChainWrapper 是一个函数，给这个函数添加若干子函数（或也称 method）的办法。这里要弄明白一个问题，直接用 `ChainWrapper[prop]` 和使用 `ChainWrapper.prototype[prop]` 的区别在哪里。前者只给该函数加入了一个子函数，而后者透过原型链，给最原始的**函数对象**加入了一个子函数，如果讲函数作为 Object 进行创建，形如 `var a = new ChainWrapper(3)` 这样，前者创建的子函数不复存在，后者创建的子函数依然存在。如下例子：\n\n```javascript\nfunction ChainWrapper(x) {\n    this._ = x\n}\nChainWrapper['sum'] = (a,b) => (a+b)\n\nChainWrapper.sum(2,3) //5\nChainWrapper['sum'](2,3) //5\n\nvar a = new ChainWrapper(1) //ChainWrapper { _: 1 }\n\na.sum(2,3) //TypeError: a.sum is not a function\n\nChainWrapper.prototype['sum'] = (a,b) => (a+b)\n\nvar a = new ChainWrapper(1) //ChainWrapper { _: 1 }\na.sum(2,3) //5\n\n```\n\n当将函数利用 new 关键字进行创建的时候，得到的是一个 Object 而不是 function。\n\nline 11: 初次定义时，`chain()` 函数返回的是 `return new ChainWrapper()`，此时 Object 内的 `this._` 为 `undefined`。当 Object 开始 chain 第一个子函数时，得到的运算结果记录在 `this._` 中，此时为非 null 值，则在下一次 chain 的时候，前一次函数的运算结果要作为下一次 chain 的参数传入进去，所以要 `args.unshift(this._)`。\n\n但这里有一个小 bug，当 `this._` 出现 `NaN` 时，此时判定 `NaN != null`  的结果会是 `true`。然后会把 `NaN` 传入到参数的最开头，那么每次结果都会是 `NaN`。修复的办法就是判定 `x` 是否为 `NaN`，在 `apply()` 方法使用后加一个条件结构。\n\n```javascript\nif (isNaN(x)) return new ChainWrapper();\n```\n\n但注意，这里默认了当输出为 `NaN` 为输出无效，不会保留之前的参数。如果要保留参数，但不同函数参数数量都不一样，就比较复杂了。比如 `sum()` 两个数相加，只输入 1 个数时会得到 `NaN`，此时输入的那个数也是直接舍弃不再保留了。\n\n[evk](https://www.codewars.com/users/evk), [niweic](https://www.codewars.com/users/niweic), [marek_mistrzuk](https://www.codewars.com/users/marek_mistrzuk)\n\n```javascript\nfunction chain(fns) {\n  let Chain = function(val){\n    this.execute = () => val;\n  };\n  for(let i in fns) Chain.prototype[i] = function (a, b) {\n    let val = this.execute(),\n        args = val === null ? [a, b] : [val, a];\n    return new Chain(fns[i](...args));\n  }\n  return new Chain(null);\n}\n```\n\n\n\n\n\n参考文章：\n\n-  [Why is isNaN(null) == false in JS?](https://stackoverflow.com/questions/115548/why-is-isnannull-false-in-js)","source":"_posts/Born to be chained | 4kyu.md","raw":"---\ntitle: 'Born to be chained | 4kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n- 对于 Object 的遍历；\n\n## Details\n\nFunction composition is a powerful technique. For example:\n\n```javascript\nfunction sum(x, y) {\n  return x + y;\n}\n\nfunction double(x) {\n  return sum(x, x);\n}\n\nfunction minus (x, y) {\n  return x - y;\n}\n\nfunction addOne(x) {\n  return sum(x, 1);\n}\n\ndouble(sum(2, 3)); // 10\n```\n\nBut in complex expressions, composition may be difficult to understand. For example:\n\n```javascript\ndouble(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72\n```\n\nIn this kata, we will implement a function that allows us to perform this by applying a fluid style:\n\n```javascript\nc.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72\n```\n\nYour job is implement the `chain` function:\n\n```javascript\nfunction chain(fns) {\n}\n\nvar c = chain({sum: sum, minus: minus, double: double, addOne: addOne});\n```\n\nAs you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the `execute`method.\n\nChained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.\n\nNote that the chain can be reused (the internal state is not stored):\n\n<!--more-->\n\n```javascript\nc.sum(3, 4).execute(); //7\nc.sum(1, 2).execute(); //3\n```\n\nOther examples:\n\n```javascript\nvar c1 = c.sum(1, 2);\nc1.execute(); // == fns.sum(1, 2) == 3\nc1.double().execute(); // == fns.double(fns.sum(1, 2)) == 6\nc1.addOne().execute(); // == fns.addOne(fns.sum(1, 2)) == 4\nc1.execute(); // == fns.sum(1, 2) == 3\n\nvar c2 = c1.sum(5);\nc2.addOne().execute(); // == fns.addOne(fns.sum(fns.sum(1, 2) 5)) == 9\nc2.sum(3).execute(); // == fns.sum(c1.sum(fns.sum(1, 2), 5), 3) == 11\nc2.execute(); // == fns.sum(fns.sum(1, 2), 5) == 8\n\nc1.execute(); // == fns.sum(1, 2) == 3\n```\n\n## Other Solutions\n\n [ooflorent](https://www.codewars.com/users/ooflorent), [ChungGor](https://www.codewars.com/users/ChungGor), [pompeu2004](https://www.codewars.com/users/pompeu2004), [guilhermeconti](https://www.codewars.com/users/guilhermeconti), [lwio](https://www.codewars.com/users/lwio) (plus 2 more warriors)\n\n```javascript\nfunction chain(fns) {\n  function ChainWrapper(x) {\n    this._ = x\n  }\n  \n  Object.keys(fns).forEach(function(prop) {\n    var fn = fns[prop]\n    \n    ChainWrapper.prototype[prop] = function() {\n      var args = [].slice.call(arguments)\n      if (this._ != null) args.unshift(this._)\n      \n      var x = fn.apply(null, args)\n      return new ChainWrapper(x)\n    }\n  })\n  \n  ChainWrapper.prototype.execute = function() {\n    return this._\n  }\n  \n  return new ChainWrapper()\n}\n```\n\nline 6: 关注一下对于一般 Object  的遍历方法。主要用到 `Object.keys()` 和 `forEach()`，另外相对应的也有 `Object.values()`。\n\nline 9: ChainWrapper 是一个函数，给这个函数添加若干子函数（或也称 method）的办法。这里要弄明白一个问题，直接用 `ChainWrapper[prop]` 和使用 `ChainWrapper.prototype[prop]` 的区别在哪里。前者只给该函数加入了一个子函数，而后者透过原型链，给最原始的**函数对象**加入了一个子函数，如果讲函数作为 Object 进行创建，形如 `var a = new ChainWrapper(3)` 这样，前者创建的子函数不复存在，后者创建的子函数依然存在。如下例子：\n\n```javascript\nfunction ChainWrapper(x) {\n    this._ = x\n}\nChainWrapper['sum'] = (a,b) => (a+b)\n\nChainWrapper.sum(2,3) //5\nChainWrapper['sum'](2,3) //5\n\nvar a = new ChainWrapper(1) //ChainWrapper { _: 1 }\n\na.sum(2,3) //TypeError: a.sum is not a function\n\nChainWrapper.prototype['sum'] = (a,b) => (a+b)\n\nvar a = new ChainWrapper(1) //ChainWrapper { _: 1 }\na.sum(2,3) //5\n\n```\n\n当将函数利用 new 关键字进行创建的时候，得到的是一个 Object 而不是 function。\n\nline 11: 初次定义时，`chain()` 函数返回的是 `return new ChainWrapper()`，此时 Object 内的 `this._` 为 `undefined`。当 Object 开始 chain 第一个子函数时，得到的运算结果记录在 `this._` 中，此时为非 null 值，则在下一次 chain 的时候，前一次函数的运算结果要作为下一次 chain 的参数传入进去，所以要 `args.unshift(this._)`。\n\n但这里有一个小 bug，当 `this._` 出现 `NaN` 时，此时判定 `NaN != null`  的结果会是 `true`。然后会把 `NaN` 传入到参数的最开头，那么每次结果都会是 `NaN`。修复的办法就是判定 `x` 是否为 `NaN`，在 `apply()` 方法使用后加一个条件结构。\n\n```javascript\nif (isNaN(x)) return new ChainWrapper();\n```\n\n但注意，这里默认了当输出为 `NaN` 为输出无效，不会保留之前的参数。如果要保留参数，但不同函数参数数量都不一样，就比较复杂了。比如 `sum()` 两个数相加，只输入 1 个数时会得到 `NaN`，此时输入的那个数也是直接舍弃不再保留了。\n\n[evk](https://www.codewars.com/users/evk), [niweic](https://www.codewars.com/users/niweic), [marek_mistrzuk](https://www.codewars.com/users/marek_mistrzuk)\n\n```javascript\nfunction chain(fns) {\n  let Chain = function(val){\n    this.execute = () => val;\n  };\n  for(let i in fns) Chain.prototype[i] = function (a, b) {\n    let val = this.execute(),\n        args = val === null ? [a, b] : [val, a];\n    return new Chain(fns[i](...args));\n  }\n  return new Chain(null);\n}\n```\n\n\n\n\n\n参考文章：\n\n-  [Why is isNaN(null) == false in JS?](https://stackoverflow.com/questions/115548/why-is-isnannull-false-in-js)","slug":"Born to be chained | 4kyu","published":1,"updated":"2019-01-22T15:15:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx23000crg1v1d8ka15e","content":"<ul>\n<li>对于 Object 的遍历；</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Function composition is a powerful technique. For example:</p>\n<pre><code class=\"javascript\">function sum(x, y) &#123;\n  return x + y;\n&#125;\n\nfunction double(x) &#123;\n  return sum(x, x);\n&#125;\n\nfunction minus (x, y) &#123;\n  return x - y;\n&#125;\n\nfunction addOne(x) &#123;\n  return sum(x, 1);\n&#125;\n\ndouble(sum(2, 3)); // 10\n</code></pre>\n<p>But in complex expressions, composition may be difficult to understand. For example:</p>\n<pre><code class=\"javascript\">double(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72\n</code></pre>\n<p>In this kata, we will implement a function that allows us to perform this by applying a fluid style:</p>\n<pre><code class=\"javascript\">c.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72\n</code></pre>\n<p>Your job is implement the <code>chain</code> function:</p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n&#125;\n\nvar c = chain(&#123;sum: sum, minus: minus, double: double, addOne: addOne&#125;);\n</code></pre>\n<p>As you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the <code>execute</code>method.</p>\n<p>Chained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.</p>\n<p>Note that the chain can be reused (the internal state is not stored):</p>\n<span id=\"more\"></span>\n\n<pre><code class=\"javascript\">c.sum(3, 4).execute(); //7\nc.sum(1, 2).execute(); //3\n</code></pre>\n<p>Other examples:</p>\n<pre><code class=\"javascript\">var c1 = c.sum(1, 2);\nc1.execute(); // == fns.sum(1, 2) == 3\nc1.double().execute(); // == fns.double(fns.sum(1, 2)) == 6\nc1.addOne().execute(); // == fns.addOne(fns.sum(1, 2)) == 4\nc1.execute(); // == fns.sum(1, 2) == 3\n\nvar c2 = c1.sum(5);\nc2.addOne().execute(); // == fns.addOne(fns.sum(fns.sum(1, 2) 5)) == 9\nc2.sum(3).execute(); // == fns.sum(c1.sum(fns.sum(1, 2), 5), 3) == 11\nc2.execute(); // == fns.sum(fns.sum(1, 2), 5) == 8\n\nc1.execute(); // == fns.sum(1, 2) == 3\n</code></pre>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/ooflorent\">ooflorent</a>, <a href=\"https://www.codewars.com/users/ChungGor\">ChungGor</a>, <a href=\"https://www.codewars.com/users/pompeu2004\">pompeu2004</a>, <a href=\"https://www.codewars.com/users/guilhermeconti\">guilhermeconti</a>, <a href=\"https://www.codewars.com/users/lwio\">lwio</a> (plus 2 more warriors)</p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n  function ChainWrapper(x) &#123;\n    this._ = x\n  &#125;\n  \n  Object.keys(fns).forEach(function(prop) &#123;\n    var fn = fns[prop]\n    \n    ChainWrapper.prototype[prop] = function() &#123;\n      var args = [].slice.call(arguments)\n      if (this._ != null) args.unshift(this._)\n      \n      var x = fn.apply(null, args)\n      return new ChainWrapper(x)\n    &#125;\n  &#125;)\n  \n  ChainWrapper.prototype.execute = function() &#123;\n    return this._\n  &#125;\n  \n  return new ChainWrapper()\n&#125;\n</code></pre>\n<p>line 6: 关注一下对于一般 Object  的遍历方法。主要用到 <code>Object.keys()</code> 和 <code>forEach()</code>，另外相对应的也有 <code>Object.values()</code>。</p>\n<p>line 9: ChainWrapper 是一个函数，给这个函数添加若干子函数（或也称 method）的办法。这里要弄明白一个问题，直接用 <code>ChainWrapper[prop]</code> 和使用 <code>ChainWrapper.prototype[prop]</code> 的区别在哪里。前者只给该函数加入了一个子函数，而后者透过原型链，给最原始的<strong>函数对象</strong>加入了一个子函数，如果讲函数作为 Object 进行创建，形如 <code>var a = new ChainWrapper(3)</code> 这样，前者创建的子函数不复存在，后者创建的子函数依然存在。如下例子：</p>\n<pre><code class=\"javascript\">function ChainWrapper(x) &#123;\n    this._ = x\n&#125;\nChainWrapper[&#39;sum&#39;] = (a,b) =&gt; (a+b)\n\nChainWrapper.sum(2,3) //5\nChainWrapper[&#39;sum&#39;](2,3) //5\n\nvar a = new ChainWrapper(1) //ChainWrapper &#123; _: 1 &#125;\n\na.sum(2,3) //TypeError: a.sum is not a function\n\nChainWrapper.prototype[&#39;sum&#39;] = (a,b) =&gt; (a+b)\n\nvar a = new ChainWrapper(1) //ChainWrapper &#123; _: 1 &#125;\na.sum(2,3) //5\n</code></pre>\n<p>当将函数利用 new 关键字进行创建的时候，得到的是一个 Object 而不是 function。</p>\n<p>line 11: 初次定义时，<code>chain()</code> 函数返回的是 <code>return new ChainWrapper()</code>，此时 Object 内的 <code>this._</code> 为 <code>undefined</code>。当 Object 开始 chain 第一个子函数时，得到的运算结果记录在 <code>this._</code> 中，此时为非 null 值，则在下一次 chain 的时候，前一次函数的运算结果要作为下一次 chain 的参数传入进去，所以要 <code>args.unshift(this._)</code>。</p>\n<p>但这里有一个小 bug，当 <code>this._</code> 出现 <code>NaN</code> 时，此时判定 <code>NaN != null</code>  的结果会是 <code>true</code>。然后会把 <code>NaN</code> 传入到参数的最开头，那么每次结果都会是 <code>NaN</code>。修复的办法就是判定 <code>x</code> 是否为 <code>NaN</code>，在 <code>apply()</code> 方法使用后加一个条件结构。</p>\n<pre><code class=\"javascript\">if (isNaN(x)) return new ChainWrapper();\n</code></pre>\n<p>但注意，这里默认了当输出为 <code>NaN</code> 为输出无效，不会保留之前的参数。如果要保留参数，但不同函数参数数量都不一样，就比较复杂了。比如 <code>sum()</code> 两个数相加，只输入 1 个数时会得到 <code>NaN</code>，此时输入的那个数也是直接舍弃不再保留了。</p>\n<p><a href=\"https://www.codewars.com/users/evk\">evk</a>, <a href=\"https://www.codewars.com/users/niweic\">niweic</a>, <a href=\"https://www.codewars.com/users/marek_mistrzuk\">marek_mistrzuk</a></p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n  let Chain = function(val)&#123;\n    this.execute = () =&gt; val;\n  &#125;;\n  for(let i in fns) Chain.prototype[i] = function (a, b) &#123;\n    let val = this.execute(),\n        args = val === null ? [a, b] : [val, a];\n    return new Chain(fns[i](...args));\n  &#125;\n  return new Chain(null);\n&#125;\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li> <a href=\"https://stackoverflow.com/questions/115548/why-is-isnannull-false-in-js\">Why is isNaN(null) == false in JS?</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>对于 Object 的遍历；</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Function composition is a powerful technique. For example:</p>\n<pre><code class=\"javascript\">function sum(x, y) &#123;\n  return x + y;\n&#125;\n\nfunction double(x) &#123;\n  return sum(x, x);\n&#125;\n\nfunction minus (x, y) &#123;\n  return x - y;\n&#125;\n\nfunction addOne(x) &#123;\n  return sum(x, 1);\n&#125;\n\ndouble(sum(2, 3)); // 10\n</code></pre>\n<p>But in complex expressions, composition may be difficult to understand. For example:</p>\n<pre><code class=\"javascript\">double(double(addOne(sum(7, minus(sum(5, sum(4, 5)), 4))))); // 72\n</code></pre>\n<p>In this kata, we will implement a function that allows us to perform this by applying a fluid style:</p>\n<pre><code class=\"javascript\">c.sum(4, 5).sum(5).minus(4).sum(7).addOne().double().double().execute(); // 72\n</code></pre>\n<p>Your job is implement the <code>chain</code> function:</p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n&#125;\n\nvar c = chain(&#123;sum: sum, minus: minus, double: double, addOne: addOne&#125;);\n</code></pre>\n<p>As you can see, this function receives the methods to be chained and returns an object that allows you to call the chained methods. The result is obtained by calling the <code>execute</code>method.</p>\n<p>Chained functions receive an arbitrary number of arguments. The first function in the chain receives all its arguments. In the other functions, the first argument is the result of the previous function and then it only receives the remainder arguments (second, third, etc.). The tests always pass the appropriate arguments and you do not have to worry about checking this.</p>\n<p>Note that the chain can be reused (the internal state is not stored):</p>","more":"<pre><code class=\"javascript\">c.sum(3, 4).execute(); //7\nc.sum(1, 2).execute(); //3\n</code></pre>\n<p>Other examples:</p>\n<pre><code class=\"javascript\">var c1 = c.sum(1, 2);\nc1.execute(); // == fns.sum(1, 2) == 3\nc1.double().execute(); // == fns.double(fns.sum(1, 2)) == 6\nc1.addOne().execute(); // == fns.addOne(fns.sum(1, 2)) == 4\nc1.execute(); // == fns.sum(1, 2) == 3\n\nvar c2 = c1.sum(5);\nc2.addOne().execute(); // == fns.addOne(fns.sum(fns.sum(1, 2) 5)) == 9\nc2.sum(3).execute(); // == fns.sum(c1.sum(fns.sum(1, 2), 5), 3) == 11\nc2.execute(); // == fns.sum(fns.sum(1, 2), 5) == 8\n\nc1.execute(); // == fns.sum(1, 2) == 3\n</code></pre>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/ooflorent\">ooflorent</a>, <a href=\"https://www.codewars.com/users/ChungGor\">ChungGor</a>, <a href=\"https://www.codewars.com/users/pompeu2004\">pompeu2004</a>, <a href=\"https://www.codewars.com/users/guilhermeconti\">guilhermeconti</a>, <a href=\"https://www.codewars.com/users/lwio\">lwio</a> (plus 2 more warriors)</p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n  function ChainWrapper(x) &#123;\n    this._ = x\n  &#125;\n  \n  Object.keys(fns).forEach(function(prop) &#123;\n    var fn = fns[prop]\n    \n    ChainWrapper.prototype[prop] = function() &#123;\n      var args = [].slice.call(arguments)\n      if (this._ != null) args.unshift(this._)\n      \n      var x = fn.apply(null, args)\n      return new ChainWrapper(x)\n    &#125;\n  &#125;)\n  \n  ChainWrapper.prototype.execute = function() &#123;\n    return this._\n  &#125;\n  \n  return new ChainWrapper()\n&#125;\n</code></pre>\n<p>line 6: 关注一下对于一般 Object  的遍历方法。主要用到 <code>Object.keys()</code> 和 <code>forEach()</code>，另外相对应的也有 <code>Object.values()</code>。</p>\n<p>line 9: ChainWrapper 是一个函数，给这个函数添加若干子函数（或也称 method）的办法。这里要弄明白一个问题，直接用 <code>ChainWrapper[prop]</code> 和使用 <code>ChainWrapper.prototype[prop]</code> 的区别在哪里。前者只给该函数加入了一个子函数，而后者透过原型链，给最原始的<strong>函数对象</strong>加入了一个子函数，如果讲函数作为 Object 进行创建，形如 <code>var a = new ChainWrapper(3)</code> 这样，前者创建的子函数不复存在，后者创建的子函数依然存在。如下例子：</p>\n<pre><code class=\"javascript\">function ChainWrapper(x) &#123;\n    this._ = x\n&#125;\nChainWrapper[&#39;sum&#39;] = (a,b) =&gt; (a+b)\n\nChainWrapper.sum(2,3) //5\nChainWrapper[&#39;sum&#39;](2,3) //5\n\nvar a = new ChainWrapper(1) //ChainWrapper &#123; _: 1 &#125;\n\na.sum(2,3) //TypeError: a.sum is not a function\n\nChainWrapper.prototype[&#39;sum&#39;] = (a,b) =&gt; (a+b)\n\nvar a = new ChainWrapper(1) //ChainWrapper &#123; _: 1 &#125;\na.sum(2,3) //5\n</code></pre>\n<p>当将函数利用 new 关键字进行创建的时候，得到的是一个 Object 而不是 function。</p>\n<p>line 11: 初次定义时，<code>chain()</code> 函数返回的是 <code>return new ChainWrapper()</code>，此时 Object 内的 <code>this._</code> 为 <code>undefined</code>。当 Object 开始 chain 第一个子函数时，得到的运算结果记录在 <code>this._</code> 中，此时为非 null 值，则在下一次 chain 的时候，前一次函数的运算结果要作为下一次 chain 的参数传入进去，所以要 <code>args.unshift(this._)</code>。</p>\n<p>但这里有一个小 bug，当 <code>this._</code> 出现 <code>NaN</code> 时，此时判定 <code>NaN != null</code>  的结果会是 <code>true</code>。然后会把 <code>NaN</code> 传入到参数的最开头，那么每次结果都会是 <code>NaN</code>。修复的办法就是判定 <code>x</code> 是否为 <code>NaN</code>，在 <code>apply()</code> 方法使用后加一个条件结构。</p>\n<pre><code class=\"javascript\">if (isNaN(x)) return new ChainWrapper();\n</code></pre>\n<p>但注意，这里默认了当输出为 <code>NaN</code> 为输出无效，不会保留之前的参数。如果要保留参数，但不同函数参数数量都不一样，就比较复杂了。比如 <code>sum()</code> 两个数相加，只输入 1 个数时会得到 <code>NaN</code>，此时输入的那个数也是直接舍弃不再保留了。</p>\n<p><a href=\"https://www.codewars.com/users/evk\">evk</a>, <a href=\"https://www.codewars.com/users/niweic\">niweic</a>, <a href=\"https://www.codewars.com/users/marek_mistrzuk\">marek_mistrzuk</a></p>\n<pre><code class=\"javascript\">function chain(fns) &#123;\n  let Chain = function(val)&#123;\n    this.execute = () =&gt; val;\n  &#125;;\n  for(let i in fns) Chain.prototype[i] = function (a, b) &#123;\n    let val = this.execute(),\n        args = val === null ? [a, b] : [val, a];\n    return new Chain(fns[i](...args));\n  &#125;\n  return new Chain(null);\n&#125;\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li> <a href=\"https://stackoverflow.com/questions/115548/why-is-isnannull-false-in-js\">Why is isNaN(null) == false in JS?</a></li>\n</ul>"},{"title":"Wrapped Function","date":"2019-01-18T14:32:07.000Z","_content":"\n## Kata\n\nCreate a function method that allow you to wrap an existing function. The method signature would look something like this:\n\n**Usage Example**:\n\n```javascript\nfunction speak(name){\n   return \"Hello \" + name;\n}\n\nspeak = speak.wrap(function(original, yourName, myName){\n   greeting = original(yourName);\n   return greeting + \", my name is \" + myName;\n})\n\nvar greeting = speak(\"Mary\", \"Kate\");\n```\n\n<!-- more -->\n\n这个题目就是给函数扩展一个 `wrap` 方法，wrap 本意是「包裹」，这里可以理解为，在原由函数功能的基础上，再次添加新的功能，可以视为对原有函数的一种增强。在本例中，`speak` 是一个简单函数，通过 `wrap` 方法，使之在 `speak` 基础之上，增加了 greeting 的功能。\n\n## Solutions\n\n### 1. that = this\n\n```javascript\nFunction.prototype.wrap = function(fn) {\n    var that = this;\n    return function(arg2,arg3) {\n        return fn(that,arg2,arg3);\n    };\n}\n```\n\n因为 `wrap` 方法的参数是一个 callback 函数，其中 `original` 参数是要能够映射到原函数中才行。这里涉及到 `this` keyword, scope 以及函数调用的问题。\n\n在 JavaScript 中，函数调用有三种情况：\n\n1.  `fn(arg)`\n2.  `obj.child.method(arg)`\n3.  ``fn.call(context,arg)`\n\n\n\n但其实第三种调用方法才是最通用的书写形式，前两种都可以用第三种书写形式写出来，比如第一种，可以写成 `fn.call(undefined,arg)`， 第二种可以写成 `obj.child.method.call(obj.child,arg)` 。因此当 `wrap` 作为函数的方法被函数 `speak` 调用时，`this` 指代的为函数 `speak`。通过创建变量并赋值，将这种映射关系存储下来。\n\n### 2. bind()\n\n```javascript\nFunction.prototype.wrap = function(callback) {\n  return callback.bind(this, this);\n}\n```\n\n`bind()` 方法首先会创建一个新函数，这个新函数的函数体和 `callback` 保持一致。 `bind()` 方法本身可能带多个参数，第一个参数用于指定 `this` 的值，之后的参数作为「预制参数」传入到新函数中。预制参数的含义可以查阅文末的参考链接。\n\n而在这个例子里，`bind()` 方法的参数是两个 `this`，第一个 `this` 仅仅指定 context，因为是 `speak()` 调用的 `wrap()`，所以 `this` 就指向 `speak()`。 第二个 `this` 则作为 `callback` 函数第一个参数的预制参数，即参数 `original`。所以 `original` 表示函数 `speak()`。剩余参数则通过实参（实际调用时使用的参数）进行传入。为了便于理解其中的参数传递，可以试着做以下实验：\n\n```javascript\nfunction speak(name){\n   return \"Hello \" + name;\n}\n\nFunction.prototype.wrap = function(callback) {\n  return callback.bind('context',this, 's', 'this');\n}\n\nspeak = speak.wrap(function(original, yourName, myName){\n    console.log(original,yourName,myName)\n\n   return \", my name is \" + myName;\n})\n\n\nconsole.log(speak(\"Mary\", \"Kate\")) //\n```\n\n随意改变 `callback.bind()` 的参数值，查看对应的 `console.log(original,yourName,myName)` 的输出。可以找到规律，`bind()` 方法的第一个参数仅仅指定 context，对参数传递无影响。除了第一个之外的其他参数作为预制参数，影响参数传递。\n\ntl;dr: \n\n`bind()` 方法第一个参数对应原函数( bound function )的 `this`，第二个参数对应原函数( bound function )的第一个参数，但三个参数对应原函数的第二个参数，以此类推。\n\n### 3. arrow function\n\n```javascript\nFunction.prototype.wrap = function (f) {\n  return (...args) => f(this, ...args)\n};\n```\n\n`…args` 表明 rest paramaters，其余参数，字面意思很好理解。`=>` 为 arrow function，类似 lambda 函数，这里 return 一个新函数，新函数的第一个参数值改为 `this`，其余参数作为实参传入。原理上这种方法也是类似于预制参数。\n\n参考：\n\n-   [this - MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n-   [this 的值到底是什么？一次说清楚 - 方应杭](https://zhuanlan.zhihu.com/p/23804247)\n-   [Javascript之bind #1( 预制参数 )](https://github.com/Aaaaaaaty/Blog/issues/1)\n-   [JavaScript深入之从原型到原型链 #2](https://github.com/mqyqingfeng/Blog/issues/2)\n-   [Rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)","source":"_posts/Codewars.com | Wrapped Function.md","raw":"---\ntitle: 'Wrapped Function'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories:\n- Coding \n---\n\n## Kata\n\nCreate a function method that allow you to wrap an existing function. The method signature would look something like this:\n\n**Usage Example**:\n\n```javascript\nfunction speak(name){\n   return \"Hello \" + name;\n}\n\nspeak = speak.wrap(function(original, yourName, myName){\n   greeting = original(yourName);\n   return greeting + \", my name is \" + myName;\n})\n\nvar greeting = speak(\"Mary\", \"Kate\");\n```\n\n<!-- more -->\n\n这个题目就是给函数扩展一个 `wrap` 方法，wrap 本意是「包裹」，这里可以理解为，在原由函数功能的基础上，再次添加新的功能，可以视为对原有函数的一种增强。在本例中，`speak` 是一个简单函数，通过 `wrap` 方法，使之在 `speak` 基础之上，增加了 greeting 的功能。\n\n## Solutions\n\n### 1. that = this\n\n```javascript\nFunction.prototype.wrap = function(fn) {\n    var that = this;\n    return function(arg2,arg3) {\n        return fn(that,arg2,arg3);\n    };\n}\n```\n\n因为 `wrap` 方法的参数是一个 callback 函数，其中 `original` 参数是要能够映射到原函数中才行。这里涉及到 `this` keyword, scope 以及函数调用的问题。\n\n在 JavaScript 中，函数调用有三种情况：\n\n1.  `fn(arg)`\n2.  `obj.child.method(arg)`\n3.  ``fn.call(context,arg)`\n\n\n\n但其实第三种调用方法才是最通用的书写形式，前两种都可以用第三种书写形式写出来，比如第一种，可以写成 `fn.call(undefined,arg)`， 第二种可以写成 `obj.child.method.call(obj.child,arg)` 。因此当 `wrap` 作为函数的方法被函数 `speak` 调用时，`this` 指代的为函数 `speak`。通过创建变量并赋值，将这种映射关系存储下来。\n\n### 2. bind()\n\n```javascript\nFunction.prototype.wrap = function(callback) {\n  return callback.bind(this, this);\n}\n```\n\n`bind()` 方法首先会创建一个新函数，这个新函数的函数体和 `callback` 保持一致。 `bind()` 方法本身可能带多个参数，第一个参数用于指定 `this` 的值，之后的参数作为「预制参数」传入到新函数中。预制参数的含义可以查阅文末的参考链接。\n\n而在这个例子里，`bind()` 方法的参数是两个 `this`，第一个 `this` 仅仅指定 context，因为是 `speak()` 调用的 `wrap()`，所以 `this` 就指向 `speak()`。 第二个 `this` 则作为 `callback` 函数第一个参数的预制参数，即参数 `original`。所以 `original` 表示函数 `speak()`。剩余参数则通过实参（实际调用时使用的参数）进行传入。为了便于理解其中的参数传递，可以试着做以下实验：\n\n```javascript\nfunction speak(name){\n   return \"Hello \" + name;\n}\n\nFunction.prototype.wrap = function(callback) {\n  return callback.bind('context',this, 's', 'this');\n}\n\nspeak = speak.wrap(function(original, yourName, myName){\n    console.log(original,yourName,myName)\n\n   return \", my name is \" + myName;\n})\n\n\nconsole.log(speak(\"Mary\", \"Kate\")) //\n```\n\n随意改变 `callback.bind()` 的参数值，查看对应的 `console.log(original,yourName,myName)` 的输出。可以找到规律，`bind()` 方法的第一个参数仅仅指定 context，对参数传递无影响。除了第一个之外的其他参数作为预制参数，影响参数传递。\n\ntl;dr: \n\n`bind()` 方法第一个参数对应原函数( bound function )的 `this`，第二个参数对应原函数( bound function )的第一个参数，但三个参数对应原函数的第二个参数，以此类推。\n\n### 3. arrow function\n\n```javascript\nFunction.prototype.wrap = function (f) {\n  return (...args) => f(this, ...args)\n};\n```\n\n`…args` 表明 rest paramaters，其余参数，字面意思很好理解。`=>` 为 arrow function，类似 lambda 函数，这里 return 一个新函数，新函数的第一个参数值改为 `this`，其余参数作为实参传入。原理上这种方法也是类似于预制参数。\n\n参考：\n\n-   [this - MDN web docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n-   [this 的值到底是什么？一次说清楚 - 方应杭](https://zhuanlan.zhihu.com/p/23804247)\n-   [Javascript之bind #1( 预制参数 )](https://github.com/Aaaaaaaty/Blog/issues/1)\n-   [JavaScript深入之从原型到原型链 #2](https://github.com/mqyqingfeng/Blog/issues/2)\n-   [Rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)","slug":"Codewars.com | Wrapped Function","published":1,"updated":"2019-01-18T14:32:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx24000grg1v10rvav41","content":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><p>Create a function method that allow you to wrap an existing function. The method signature would look something like this:</p>\n<p><strong>Usage Example</strong>:</p>\n<pre><code class=\"javascript\">function speak(name)&#123;\n   return &quot;Hello &quot; + name;\n&#125;\n\nspeak = speak.wrap(function(original, yourName, myName)&#123;\n   greeting = original(yourName);\n   return greeting + &quot;, my name is &quot; + myName;\n&#125;)\n\nvar greeting = speak(&quot;Mary&quot;, &quot;Kate&quot;);\n</code></pre>\n<span id=\"more\"></span>\n\n<p>这个题目就是给函数扩展一个 <code>wrap</code> 方法，wrap 本意是「包裹」，这里可以理解为，在原由函数功能的基础上，再次添加新的功能，可以视为对原有函数的一种增强。在本例中，<code>speak</code> 是一个简单函数，通过 <code>wrap</code> 方法，使之在 <code>speak</code> 基础之上，增加了 greeting 的功能。</p>\n<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><h3 id=\"1-that-this\"><a href=\"#1-that-this\" class=\"headerlink\" title=\"1. that = this\"></a>1. that = this</h3><pre><code class=\"javascript\">Function.prototype.wrap = function(fn) &#123;\n    var that = this;\n    return function(arg2,arg3) &#123;\n        return fn(that,arg2,arg3);\n    &#125;;\n&#125;\n</code></pre>\n<p>因为 <code>wrap</code> 方法的参数是一个 callback 函数，其中 <code>original</code> 参数是要能够映射到原函数中才行。这里涉及到 <code>this</code> keyword, scope 以及函数调用的问题。</p>\n<p>在 JavaScript 中，函数调用有三种情况：</p>\n<ol>\n<li> <code>fn(arg)</code></li>\n<li> <code>obj.child.method(arg)</code></li>\n<li> ``fn.call(context,arg)`</li>\n</ol>\n<p>但其实第三种调用方法才是最通用的书写形式，前两种都可以用第三种书写形式写出来，比如第一种，可以写成 <code>fn.call(undefined,arg)</code>， 第二种可以写成 <code>obj.child.method.call(obj.child,arg)</code> 。因此当 <code>wrap</code> 作为函数的方法被函数 <code>speak</code> 调用时，<code>this</code> 指代的为函数 <code>speak</code>。通过创建变量并赋值，将这种映射关系存储下来。</p>\n<h3 id=\"2-bind\"><a href=\"#2-bind\" class=\"headerlink\" title=\"2. bind()\"></a>2. bind()</h3><pre><code class=\"javascript\">Function.prototype.wrap = function(callback) &#123;\n  return callback.bind(this, this);\n&#125;\n</code></pre>\n<p><code>bind()</code> 方法首先会创建一个新函数，这个新函数的函数体和 <code>callback</code> 保持一致。 <code>bind()</code> 方法本身可能带多个参数，第一个参数用于指定 <code>this</code> 的值，之后的参数作为「预制参数」传入到新函数中。预制参数的含义可以查阅文末的参考链接。</p>\n<p>而在这个例子里，<code>bind()</code> 方法的参数是两个 <code>this</code>，第一个 <code>this</code> 仅仅指定 context，因为是 <code>speak()</code> 调用的 <code>wrap()</code>，所以 <code>this</code> 就指向 <code>speak()</code>。 第二个 <code>this</code> 则作为 <code>callback</code> 函数第一个参数的预制参数，即参数 <code>original</code>。所以 <code>original</code> 表示函数 <code>speak()</code>。剩余参数则通过实参（实际调用时使用的参数）进行传入。为了便于理解其中的参数传递，可以试着做以下实验：</p>\n<pre><code class=\"javascript\">function speak(name)&#123;\n   return &quot;Hello &quot; + name;\n&#125;\n\nFunction.prototype.wrap = function(callback) &#123;\n  return callback.bind(&#39;context&#39;,this, &#39;s&#39;, &#39;this&#39;);\n&#125;\n\nspeak = speak.wrap(function(original, yourName, myName)&#123;\n    console.log(original,yourName,myName)\n\n   return &quot;, my name is &quot; + myName;\n&#125;)\n\n\nconsole.log(speak(&quot;Mary&quot;, &quot;Kate&quot;)) //\n</code></pre>\n<p>随意改变 <code>callback.bind()</code> 的参数值，查看对应的 <code>console.log(original,yourName,myName)</code> 的输出。可以找到规律，<code>bind()</code> 方法的第一个参数仅仅指定 context，对参数传递无影响。除了第一个之外的其他参数作为预制参数，影响参数传递。</p>\n<p>tl;dr: </p>\n<p><code>bind()</code> 方法第一个参数对应原函数( bound function )的 <code>this</code>，第二个参数对应原函数( bound function )的第一个参数，但三个参数对应原函数的第二个参数，以此类推。</p>\n<h3 id=\"3-arrow-function\"><a href=\"#3-arrow-function\" class=\"headerlink\" title=\"3. arrow function\"></a>3. arrow function</h3><pre><code class=\"javascript\">Function.prototype.wrap = function (f) &#123;\n  return (...args) =&gt; f(this, ...args)\n&#125;;\n</code></pre>\n<p><code>…args</code> 表明 rest paramaters，其余参数，字面意思很好理解。<code>=&gt;</code> 为 arrow function，类似 lambda 函数，这里 return 一个新函数，新函数的第一个参数值改为 <code>this</code>，其余参数作为实参传入。原理上这种方法也是类似于预制参数。</p>\n<p>参考：</p>\n<ul>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this - MDN web docs</a></li>\n<li>  <a href=\"https://zhuanlan.zhihu.com/p/23804247\">this 的值到底是什么？一次说清楚 - 方应杭</a></li>\n<li>  <a href=\"https://github.com/Aaaaaaaty/Blog/issues/1\">Javascript之bind #1( 预制参数 )</a></li>\n<li>  <a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript深入之从原型到原型链 #2</a></li>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\">Rest parameters</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><p>Create a function method that allow you to wrap an existing function. The method signature would look something like this:</p>\n<p><strong>Usage Example</strong>:</p>\n<pre><code class=\"javascript\">function speak(name)&#123;\n   return &quot;Hello &quot; + name;\n&#125;\n\nspeak = speak.wrap(function(original, yourName, myName)&#123;\n   greeting = original(yourName);\n   return greeting + &quot;, my name is &quot; + myName;\n&#125;)\n\nvar greeting = speak(&quot;Mary&quot;, &quot;Kate&quot;);\n</code></pre>","more":"<p>这个题目就是给函数扩展一个 <code>wrap</code> 方法，wrap 本意是「包裹」，这里可以理解为，在原由函数功能的基础上，再次添加新的功能，可以视为对原有函数的一种增强。在本例中，<code>speak</code> 是一个简单函数，通过 <code>wrap</code> 方法，使之在 <code>speak</code> 基础之上，增加了 greeting 的功能。</p>\n<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><h3 id=\"1-that-this\"><a href=\"#1-that-this\" class=\"headerlink\" title=\"1. that = this\"></a>1. that = this</h3><pre><code class=\"javascript\">Function.prototype.wrap = function(fn) &#123;\n    var that = this;\n    return function(arg2,arg3) &#123;\n        return fn(that,arg2,arg3);\n    &#125;;\n&#125;\n</code></pre>\n<p>因为 <code>wrap</code> 方法的参数是一个 callback 函数，其中 <code>original</code> 参数是要能够映射到原函数中才行。这里涉及到 <code>this</code> keyword, scope 以及函数调用的问题。</p>\n<p>在 JavaScript 中，函数调用有三种情况：</p>\n<ol>\n<li> <code>fn(arg)</code></li>\n<li> <code>obj.child.method(arg)</code></li>\n<li> ``fn.call(context,arg)`</li>\n</ol>\n<p>但其实第三种调用方法才是最通用的书写形式，前两种都可以用第三种书写形式写出来，比如第一种，可以写成 <code>fn.call(undefined,arg)</code>， 第二种可以写成 <code>obj.child.method.call(obj.child,arg)</code> 。因此当 <code>wrap</code> 作为函数的方法被函数 <code>speak</code> 调用时，<code>this</code> 指代的为函数 <code>speak</code>。通过创建变量并赋值，将这种映射关系存储下来。</p>\n<h3 id=\"2-bind\"><a href=\"#2-bind\" class=\"headerlink\" title=\"2. bind()\"></a>2. bind()</h3><pre><code class=\"javascript\">Function.prototype.wrap = function(callback) &#123;\n  return callback.bind(this, this);\n&#125;\n</code></pre>\n<p><code>bind()</code> 方法首先会创建一个新函数，这个新函数的函数体和 <code>callback</code> 保持一致。 <code>bind()</code> 方法本身可能带多个参数，第一个参数用于指定 <code>this</code> 的值，之后的参数作为「预制参数」传入到新函数中。预制参数的含义可以查阅文末的参考链接。</p>\n<p>而在这个例子里，<code>bind()</code> 方法的参数是两个 <code>this</code>，第一个 <code>this</code> 仅仅指定 context，因为是 <code>speak()</code> 调用的 <code>wrap()</code>，所以 <code>this</code> 就指向 <code>speak()</code>。 第二个 <code>this</code> 则作为 <code>callback</code> 函数第一个参数的预制参数，即参数 <code>original</code>。所以 <code>original</code> 表示函数 <code>speak()</code>。剩余参数则通过实参（实际调用时使用的参数）进行传入。为了便于理解其中的参数传递，可以试着做以下实验：</p>\n<pre><code class=\"javascript\">function speak(name)&#123;\n   return &quot;Hello &quot; + name;\n&#125;\n\nFunction.prototype.wrap = function(callback) &#123;\n  return callback.bind(&#39;context&#39;,this, &#39;s&#39;, &#39;this&#39;);\n&#125;\n\nspeak = speak.wrap(function(original, yourName, myName)&#123;\n    console.log(original,yourName,myName)\n\n   return &quot;, my name is &quot; + myName;\n&#125;)\n\n\nconsole.log(speak(&quot;Mary&quot;, &quot;Kate&quot;)) //\n</code></pre>\n<p>随意改变 <code>callback.bind()</code> 的参数值，查看对应的 <code>console.log(original,yourName,myName)</code> 的输出。可以找到规律，<code>bind()</code> 方法的第一个参数仅仅指定 context，对参数传递无影响。除了第一个之外的其他参数作为预制参数，影响参数传递。</p>\n<p>tl;dr: </p>\n<p><code>bind()</code> 方法第一个参数对应原函数( bound function )的 <code>this</code>，第二个参数对应原函数( bound function )的第一个参数，但三个参数对应原函数的第二个参数，以此类推。</p>\n<h3 id=\"3-arrow-function\"><a href=\"#3-arrow-function\" class=\"headerlink\" title=\"3. arrow function\"></a>3. arrow function</h3><pre><code class=\"javascript\">Function.prototype.wrap = function (f) &#123;\n  return (...args) =&gt; f(this, ...args)\n&#125;;\n</code></pre>\n<p><code>…args</code> 表明 rest paramaters，其余参数，字面意思很好理解。<code>=&gt;</code> 为 arrow function，类似 lambda 函数，这里 return 一个新函数，新函数的第一个参数值改为 <code>this</code>，其余参数作为实参传入。原理上这种方法也是类似于预制参数。</p>\n<p>参考：</p>\n<ul>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\">this - MDN web docs</a></li>\n<li>  <a href=\"https://zhuanlan.zhihu.com/p/23804247\">this 的值到底是什么？一次说清楚 - 方应杭</a></li>\n<li>  <a href=\"https://github.com/Aaaaaaaty/Blog/issues/1\">Javascript之bind #1( 预制参数 )</a></li>\n<li>  <a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript深入之从原型到原型链 #2</a></li>\n<li>  <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\">Rest parameters</a></li>\n</ul>"},{"title":"ES5 Generators(i) 和闭包 closure","date":"2019-01-18T14:30:30.000Z","_content":"\n## Kata\n\nDescription:\n\nThis is the first part of three ([part2](http://www.codewars.com/kata/es5-generators-ii), [part3](http://www.codewars.com/kata/es5-generators-iii)).\n\nGenerators and Iterators are new ES6 features that will allow things like this:\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) {\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n```\n\nUsing them in this way, we can do amazing things:\n\n```javascript\nlet seq = fibonacci();\nprint(seq.next()); // 1\nprint(seq.next()); // 2\nprint(seq.next()); // 3\nprint(seq.next()); // 5\nprint(seq.next()); // 8\n```\n\nThis is powerful, but until a few months later, ES6 will not be born.\n\nThe goal of this kata is to implement pseudo-generators with ES5.\n\n<!-- more -->\n\nThe first thing to do is to implement the generator function:\n\n```javascript\nfunction generator(sequencer) {\n   ...\n}\n```\n`generator(sequencer[, arg1, arg2, …])` receives a sequencer function to generate the sequence and returns and object with a `next()` method. When the `next()` method is invoked, the next value is generated. The method could receive as well optional arguments to be passed to the sequencer function.\n\nThis is an example of a dummy sequencer:\n\n```javascript\nfunction dummySeq() {\n  return function() {\n    return \"dummy\";\n  };\n}\n```\nTo test generator(), you could use `dummySeq()` in this way:\n\n```javascript\nvar seq = generator(dummySeq);\nseq.next(); // 'dummy'\nseq.next(); // 'dummy'\nseq.next(); // 'dummy'\n....\n```\nWhen you're done, you should implement the following generators (I think the functions are self explanatory):\n```javascript\nfunction factorialSeq() {...} // 1, 1, 2, 6, 24, ...\nfunction fibonacciSeq() {...} // 1, 1, 2, 3, 5, 8, 13, ...\nfunction rangeSeq(start, step) {...} // rangeSeq(1, 2)  -> 1, 3, 5, 7, ...\nfunction primeSeq() {...} // 2, 3, 5, 7, 11, 13, ...\npartialSumSeq(1, 3, 7, 2, 0) {...} // 1, 4, 11, 13, 13, end\n```\nYou can use any of them in the same way:\n```javascript\nvar seq = generator(factorialSeq);\nseq.next(); // !0 = 1\nseq.next(); // !1 = 1\nseq.next(); // !2 = 2\nseq.next(); // !3 = 6\nseq.next(); // !4 = 24\n...\n```\nThere are some sequences which are infinite and others are not. For example:\n\n-   primeSeq: Is infinite\n-   partialSumSeq: Is limited to the passed values.\n\nWhen the sequence is done (in finite sequences), if you call seq.next() again, it should produce an error.\n\nGood luck!\n\n## Solutions\n\n题目的大体含义是想要通过 ES5 来模拟 ES6 中才有的 generator 生成器功能。主要思路就是使用闭包 closure 这一特性：\n\n```javascript\nfunction generator(sequencer) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return {\n        next: sequencer.apply(this,args)\n    };\n}\n\nfunction fibonacciSeq() {\n    var prev = 0\n    var current = 1\n    return function() {\n        var old = current\n        current = prev + current\n        prev = old\n        return prev\n    }\n}\n\n// 直接调用\nconsole.log(fibonacciSeq()())\n// 使用 closure\nvar seq = fibonacciSeq()\nconsole.log(seq())\n```\n\n关于 Closure，非常推荐阅读 Kyle Simpson 写的 *You Don't Know JS: Scope & Closures* ，不到 100 页的小册子，由浅入深，通俗易懂。Closure 简单来讲，就是在一个函数内部定义一个嵌套的子函数，并 return 它，return 这个子函数。形式就像上面代码，在 `fibonacciSeq()` 函数里 return 了一个 anonymous function，匿名函数。这样做的好处就是，把 `fibonacciSeq()` 私有变量 `prev`, `current` 保护起来，**同时又能通过返回的 anonymous function 去修改函数的私有变量**。听起来很绕。很实用，因为一般来讲，我们是无法在函数的外部去修改一个函数内部的私有变量的，但 closure 却可以。或者换句话，通过「在函数 A 中返回一个子函数」这样的操作，可以去修改函数 A 的私有变量。\n\n这里关于 closure，主要想提及几个点：\n\n一、`fibonacciSeq()()` 和 `seq()` 区别\n\n二者函数的调用和执行都不同。`fibonacciSeq()()` 则是先调用函数 `fibonacciSeq()`，该函数返回一个匿名函数，再继续调用该匿名函数，得到匿名函数的返回值。所以是连续调用了两个函数，外层函数和内层函数，整个 `fibonacciSeq()` 函数中的语句都被执行了。\n\n而使用 closure，首先定义变量 `var seq = fibonacciSeq()`，然后在调用 `seq()` 的过程中，仅仅调用执行了 `fibonacciSeq()` 里内部返回的的匿名函数，换句话说，在执行 `seq()` 的过程中， `fibonacciSeq()`  函数并没有被调用执行，整个过程真正调用执行的**只有**被嵌套的内层子函数，也就是返回的匿名函数，anonymous function。\n\n这么一个简单区别就造成了，前者 `fibonacciSeq()()` 即便调用无数次，输出结果都是相同的，都是 `1`。而后者调用多次，却能够得到 Fibonacci 数列 `1,1,2,3,5…`。原因就在于 closure，虽然仅仅执行了匿名函数，但因为匿名函数是作为子函数存在于  `fibonacciSeq()`  函数内，所以根据 Lexical scope 的规则，内层函数是可以 access 到外层函数的变量的。所以在执行 `seq()` 的过程中，程序从内到外寻找变量  `prev`, `current`， 不仅在 `fibonacciSeq()`  找到了它的私有变量  `prev`, `current` ，而且还修改了它们的值！被修改了值的私有变量依旧保持在原来位置，即仍然作为函数的私有变量存在。这一点在文章 [Closure - The Modern JavaScript Tutorial](https://javascript.info/closure) 中有梗详细的解释，这里就不赘述了。\n\n二、其他一些细节\n\n在 `generator()` 中使用的 `call()` `apply()` 方法，主要是为了函数传参。 \n\n-   `Array.prototype.slice.call(arguments, 1)` \n\n因为 `arguments` 是一个 array-like object，而不是真正的 array，所以无法使用 array 的诸多方法，包括 slice。`call()` 的作用就是让 `arguments` 用上 slice 方法。在这里去掉了  `arguments` 里的第一个元素，剩下元素作为一个新的 array 存储到 `args` 中。\n\n-   `sequencer.apply(this,args)`\n\n绑定 this 到 `sequencer ` 并将参数 `args` 传递到函数中。\n\n参考：\n\n-   [What are the reasons to use 'return function' in JavaScript? - Quora](https://www.quora.com/What-are-the-reasons-to-use-return-function-in-JavaScript)\n-   [Closure - The Modern JavaScript Tutorial](https://javascript.info/closure) ✪\n-   You Don't Know JS: Scope & Closures - Kyle Simpson","source":"_posts/Codewars.com | ES5 Generators(i).md","raw":"---\ntitle: 'ES5 Generators(i) 和闭包 closure'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## Kata\n\nDescription:\n\nThis is the first part of three ([part2](http://www.codewars.com/kata/es5-generators-ii), [part3](http://www.codewars.com/kata/es5-generators-iii)).\n\nGenerators and Iterators are new ES6 features that will allow things like this:\n\n```javascript\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    for (;;) {\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    }\n}\n```\n\nUsing them in this way, we can do amazing things:\n\n```javascript\nlet seq = fibonacci();\nprint(seq.next()); // 1\nprint(seq.next()); // 2\nprint(seq.next()); // 3\nprint(seq.next()); // 5\nprint(seq.next()); // 8\n```\n\nThis is powerful, but until a few months later, ES6 will not be born.\n\nThe goal of this kata is to implement pseudo-generators with ES5.\n\n<!-- more -->\n\nThe first thing to do is to implement the generator function:\n\n```javascript\nfunction generator(sequencer) {\n   ...\n}\n```\n`generator(sequencer[, arg1, arg2, …])` receives a sequencer function to generate the sequence and returns and object with a `next()` method. When the `next()` method is invoked, the next value is generated. The method could receive as well optional arguments to be passed to the sequencer function.\n\nThis is an example of a dummy sequencer:\n\n```javascript\nfunction dummySeq() {\n  return function() {\n    return \"dummy\";\n  };\n}\n```\nTo test generator(), you could use `dummySeq()` in this way:\n\n```javascript\nvar seq = generator(dummySeq);\nseq.next(); // 'dummy'\nseq.next(); // 'dummy'\nseq.next(); // 'dummy'\n....\n```\nWhen you're done, you should implement the following generators (I think the functions are self explanatory):\n```javascript\nfunction factorialSeq() {...} // 1, 1, 2, 6, 24, ...\nfunction fibonacciSeq() {...} // 1, 1, 2, 3, 5, 8, 13, ...\nfunction rangeSeq(start, step) {...} // rangeSeq(1, 2)  -> 1, 3, 5, 7, ...\nfunction primeSeq() {...} // 2, 3, 5, 7, 11, 13, ...\npartialSumSeq(1, 3, 7, 2, 0) {...} // 1, 4, 11, 13, 13, end\n```\nYou can use any of them in the same way:\n```javascript\nvar seq = generator(factorialSeq);\nseq.next(); // !0 = 1\nseq.next(); // !1 = 1\nseq.next(); // !2 = 2\nseq.next(); // !3 = 6\nseq.next(); // !4 = 24\n...\n```\nThere are some sequences which are infinite and others are not. For example:\n\n-   primeSeq: Is infinite\n-   partialSumSeq: Is limited to the passed values.\n\nWhen the sequence is done (in finite sequences), if you call seq.next() again, it should produce an error.\n\nGood luck!\n\n## Solutions\n\n题目的大体含义是想要通过 ES5 来模拟 ES6 中才有的 generator 生成器功能。主要思路就是使用闭包 closure 这一特性：\n\n```javascript\nfunction generator(sequencer) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return {\n        next: sequencer.apply(this,args)\n    };\n}\n\nfunction fibonacciSeq() {\n    var prev = 0\n    var current = 1\n    return function() {\n        var old = current\n        current = prev + current\n        prev = old\n        return prev\n    }\n}\n\n// 直接调用\nconsole.log(fibonacciSeq()())\n// 使用 closure\nvar seq = fibonacciSeq()\nconsole.log(seq())\n```\n\n关于 Closure，非常推荐阅读 Kyle Simpson 写的 *You Don't Know JS: Scope & Closures* ，不到 100 页的小册子，由浅入深，通俗易懂。Closure 简单来讲，就是在一个函数内部定义一个嵌套的子函数，并 return 它，return 这个子函数。形式就像上面代码，在 `fibonacciSeq()` 函数里 return 了一个 anonymous function，匿名函数。这样做的好处就是，把 `fibonacciSeq()` 私有变量 `prev`, `current` 保护起来，**同时又能通过返回的 anonymous function 去修改函数的私有变量**。听起来很绕。很实用，因为一般来讲，我们是无法在函数的外部去修改一个函数内部的私有变量的，但 closure 却可以。或者换句话，通过「在函数 A 中返回一个子函数」这样的操作，可以去修改函数 A 的私有变量。\n\n这里关于 closure，主要想提及几个点：\n\n一、`fibonacciSeq()()` 和 `seq()` 区别\n\n二者函数的调用和执行都不同。`fibonacciSeq()()` 则是先调用函数 `fibonacciSeq()`，该函数返回一个匿名函数，再继续调用该匿名函数，得到匿名函数的返回值。所以是连续调用了两个函数，外层函数和内层函数，整个 `fibonacciSeq()` 函数中的语句都被执行了。\n\n而使用 closure，首先定义变量 `var seq = fibonacciSeq()`，然后在调用 `seq()` 的过程中，仅仅调用执行了 `fibonacciSeq()` 里内部返回的的匿名函数，换句话说，在执行 `seq()` 的过程中， `fibonacciSeq()`  函数并没有被调用执行，整个过程真正调用执行的**只有**被嵌套的内层子函数，也就是返回的匿名函数，anonymous function。\n\n这么一个简单区别就造成了，前者 `fibonacciSeq()()` 即便调用无数次，输出结果都是相同的，都是 `1`。而后者调用多次，却能够得到 Fibonacci 数列 `1,1,2,3,5…`。原因就在于 closure，虽然仅仅执行了匿名函数，但因为匿名函数是作为子函数存在于  `fibonacciSeq()`  函数内，所以根据 Lexical scope 的规则，内层函数是可以 access 到外层函数的变量的。所以在执行 `seq()` 的过程中，程序从内到外寻找变量  `prev`, `current`， 不仅在 `fibonacciSeq()`  找到了它的私有变量  `prev`, `current` ，而且还修改了它们的值！被修改了值的私有变量依旧保持在原来位置，即仍然作为函数的私有变量存在。这一点在文章 [Closure - The Modern JavaScript Tutorial](https://javascript.info/closure) 中有梗详细的解释，这里就不赘述了。\n\n二、其他一些细节\n\n在 `generator()` 中使用的 `call()` `apply()` 方法，主要是为了函数传参。 \n\n-   `Array.prototype.slice.call(arguments, 1)` \n\n因为 `arguments` 是一个 array-like object，而不是真正的 array，所以无法使用 array 的诸多方法，包括 slice。`call()` 的作用就是让 `arguments` 用上 slice 方法。在这里去掉了  `arguments` 里的第一个元素，剩下元素作为一个新的 array 存储到 `args` 中。\n\n-   `sequencer.apply(this,args)`\n\n绑定 this 到 `sequencer ` 并将参数 `args` 传递到函数中。\n\n参考：\n\n-   [What are the reasons to use 'return function' in JavaScript? - Quora](https://www.quora.com/What-are-the-reasons-to-use-return-function-in-JavaScript)\n-   [Closure - The Modern JavaScript Tutorial](https://javascript.info/closure) ✪\n-   You Don't Know JS: Scope & Closures - Kyle Simpson","slug":"Codewars.com | ES5 Generators(i)","published":1,"updated":"2019-01-18T14:30:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx24000irg1vcf9q4ghq","content":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><p>Description:</p>\n<p>This is the first part of three (<a href=\"http://www.codewars.com/kata/es5-generators-ii\">part2</a>, <a href=\"http://www.codewars.com/kata/es5-generators-iii\">part3</a>).</p>\n<p>Generators and Iterators are new ES6 features that will allow things like this:</p>\n<pre><code class=\"javascript\">function* fibonacci() &#123;\n    let [prev, curr] = [0, 1];\n    for (;;) &#123;\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    &#125;\n&#125;\n</code></pre>\n<p>Using them in this way, we can do amazing things:</p>\n<pre><code class=\"javascript\">let seq = fibonacci();\nprint(seq.next()); // 1\nprint(seq.next()); // 2\nprint(seq.next()); // 3\nprint(seq.next()); // 5\nprint(seq.next()); // 8\n</code></pre>\n<p>This is powerful, but until a few months later, ES6 will not be born.</p>\n<p>The goal of this kata is to implement pseudo-generators with ES5.</p>\n<span id=\"more\"></span>\n\n<p>The first thing to do is to implement the generator function:</p>\n<pre><code class=\"javascript\">function generator(sequencer) &#123;\n   ...\n&#125;\n</code></pre>\n<p><code>generator(sequencer[, arg1, arg2, …])</code> receives a sequencer function to generate the sequence and returns and object with a <code>next()</code> method. When the <code>next()</code> method is invoked, the next value is generated. The method could receive as well optional arguments to be passed to the sequencer function.</p>\n<p>This is an example of a dummy sequencer:</p>\n<pre><code class=\"javascript\">function dummySeq() &#123;\n  return function() &#123;\n    return &quot;dummy&quot;;\n  &#125;;\n&#125;\n</code></pre>\n<p>To test generator(), you could use <code>dummySeq()</code> in this way:</p>\n<pre><code class=\"javascript\">var seq = generator(dummySeq);\nseq.next(); // &#39;dummy&#39;\nseq.next(); // &#39;dummy&#39;\nseq.next(); // &#39;dummy&#39;\n....\n</code></pre>\n<p>When you’re done, you should implement the following generators (I think the functions are self explanatory):</p>\n<pre><code class=\"javascript\">function factorialSeq() &#123;...&#125; // 1, 1, 2, 6, 24, ...\nfunction fibonacciSeq() &#123;...&#125; // 1, 1, 2, 3, 5, 8, 13, ...\nfunction rangeSeq(start, step) &#123;...&#125; // rangeSeq(1, 2)  -&gt; 1, 3, 5, 7, ...\nfunction primeSeq() &#123;...&#125; // 2, 3, 5, 7, 11, 13, ...\npartialSumSeq(1, 3, 7, 2, 0) &#123;...&#125; // 1, 4, 11, 13, 13, end\n</code></pre>\n<p>You can use any of them in the same way:</p>\n<pre><code class=\"javascript\">var seq = generator(factorialSeq);\nseq.next(); // !0 = 1\nseq.next(); // !1 = 1\nseq.next(); // !2 = 2\nseq.next(); // !3 = 6\nseq.next(); // !4 = 24\n...\n</code></pre>\n<p>There are some sequences which are infinite and others are not. For example:</p>\n<ul>\n<li>  primeSeq: Is infinite</li>\n<li>  partialSumSeq: Is limited to the passed values.</li>\n</ul>\n<p>When the sequence is done (in finite sequences), if you call seq.next() again, it should produce an error.</p>\n<p>Good luck!</p>\n<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>题目的大体含义是想要通过 ES5 来模拟 ES6 中才有的 generator 生成器功能。主要思路就是使用闭包 closure 这一特性：</p>\n<pre><code class=\"javascript\">function generator(sequencer) &#123;\n    var args = Array.prototype.slice.call(arguments, 1);\n    return &#123;\n        next: sequencer.apply(this,args)\n    &#125;;\n&#125;\n\nfunction fibonacciSeq() &#123;\n    var prev = 0\n    var current = 1\n    return function() &#123;\n        var old = current\n        current = prev + current\n        prev = old\n        return prev\n    &#125;\n&#125;\n\n// 直接调用\nconsole.log(fibonacciSeq()())\n// 使用 closure\nvar seq = fibonacciSeq()\nconsole.log(seq())\n</code></pre>\n<p>关于 Closure，非常推荐阅读 Kyle Simpson 写的 <em>You Don’t Know JS: Scope &amp; Closures</em> ，不到 100 页的小册子，由浅入深，通俗易懂。Closure 简单来讲，就是在一个函数内部定义一个嵌套的子函数，并 return 它，return 这个子函数。形式就像上面代码，在 <code>fibonacciSeq()</code> 函数里 return 了一个 anonymous function，匿名函数。这样做的好处就是，把 <code>fibonacciSeq()</code> 私有变量 <code>prev</code>, <code>current</code> 保护起来，<strong>同时又能通过返回的 anonymous function 去修改函数的私有变量</strong>。听起来很绕。很实用，因为一般来讲，我们是无法在函数的外部去修改一个函数内部的私有变量的，但 closure 却可以。或者换句话，通过「在函数 A 中返回一个子函数」这样的操作，可以去修改函数 A 的私有变量。</p>\n<p>这里关于 closure，主要想提及几个点：</p>\n<p>一、<code>fibonacciSeq()()</code> 和 <code>seq()</code> 区别</p>\n<p>二者函数的调用和执行都不同。<code>fibonacciSeq()()</code> 则是先调用函数 <code>fibonacciSeq()</code>，该函数返回一个匿名函数，再继续调用该匿名函数，得到匿名函数的返回值。所以是连续调用了两个函数，外层函数和内层函数，整个 <code>fibonacciSeq()</code> 函数中的语句都被执行了。</p>\n<p>而使用 closure，首先定义变量 <code>var seq = fibonacciSeq()</code>，然后在调用 <code>seq()</code> 的过程中，仅仅调用执行了 <code>fibonacciSeq()</code> 里内部返回的的匿名函数，换句话说，在执行 <code>seq()</code> 的过程中， <code>fibonacciSeq()</code>  函数并没有被调用执行，整个过程真正调用执行的<strong>只有</strong>被嵌套的内层子函数，也就是返回的匿名函数，anonymous function。</p>\n<p>这么一个简单区别就造成了，前者 <code>fibonacciSeq()()</code> 即便调用无数次，输出结果都是相同的，都是 <code>1</code>。而后者调用多次，却能够得到 Fibonacci 数列 <code>1,1,2,3,5…</code>。原因就在于 closure，虽然仅仅执行了匿名函数，但因为匿名函数是作为子函数存在于  <code>fibonacciSeq()</code>  函数内，所以根据 Lexical scope 的规则，内层函数是可以 access 到外层函数的变量的。所以在执行 <code>seq()</code> 的过程中，程序从内到外寻找变量  <code>prev</code>, <code>current</code>， 不仅在 <code>fibonacciSeq()</code>  找到了它的私有变量  <code>prev</code>, <code>current</code> ，而且还修改了它们的值！被修改了值的私有变量依旧保持在原来位置，即仍然作为函数的私有变量存在。这一点在文章 <a href=\"https://javascript.info/closure\">Closure - The Modern JavaScript Tutorial</a> 中有梗详细的解释，这里就不赘述了。</p>\n<p>二、其他一些细节</p>\n<p>在 <code>generator()</code> 中使用的 <code>call()</code> <code>apply()</code> 方法，主要是为了函数传参。 </p>\n<ul>\n<li>  <code>Array.prototype.slice.call(arguments, 1)</code> </li>\n</ul>\n<p>因为 <code>arguments</code> 是一个 array-like object，而不是真正的 array，所以无法使用 array 的诸多方法，包括 slice。<code>call()</code> 的作用就是让 <code>arguments</code> 用上 slice 方法。在这里去掉了  <code>arguments</code> 里的第一个元素，剩下元素作为一个新的 array 存储到 <code>args</code> 中。</p>\n<ul>\n<li>  <code>sequencer.apply(this,args)</code></li>\n</ul>\n<p>绑定 this 到 <code>sequencer </code> 并将参数 <code>args</code> 传递到函数中。</p>\n<p>参考：</p>\n<ul>\n<li>  <a href=\"https://www.quora.com/What-are-the-reasons-to-use-return-function-in-JavaScript\">What are the reasons to use ‘return function’ in JavaScript? - Quora</a></li>\n<li>  <a href=\"https://javascript.info/closure\">Closure - The Modern JavaScript Tutorial</a> ✪</li>\n<li>  You Don’t Know JS: Scope &amp; Closures - Kyle Simpson</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><p>Description:</p>\n<p>This is the first part of three (<a href=\"http://www.codewars.com/kata/es5-generators-ii\">part2</a>, <a href=\"http://www.codewars.com/kata/es5-generators-iii\">part3</a>).</p>\n<p>Generators and Iterators are new ES6 features that will allow things like this:</p>\n<pre><code class=\"javascript\">function* fibonacci() &#123;\n    let [prev, curr] = [0, 1];\n    for (;;) &#123;\n        [prev, curr] = [curr, prev + curr];\n        yield curr;\n    &#125;\n&#125;\n</code></pre>\n<p>Using them in this way, we can do amazing things:</p>\n<pre><code class=\"javascript\">let seq = fibonacci();\nprint(seq.next()); // 1\nprint(seq.next()); // 2\nprint(seq.next()); // 3\nprint(seq.next()); // 5\nprint(seq.next()); // 8\n</code></pre>\n<p>This is powerful, but until a few months later, ES6 will not be born.</p>\n<p>The goal of this kata is to implement pseudo-generators with ES5.</p>","more":"<p>The first thing to do is to implement the generator function:</p>\n<pre><code class=\"javascript\">function generator(sequencer) &#123;\n   ...\n&#125;\n</code></pre>\n<p><code>generator(sequencer[, arg1, arg2, …])</code> receives a sequencer function to generate the sequence and returns and object with a <code>next()</code> method. When the <code>next()</code> method is invoked, the next value is generated. The method could receive as well optional arguments to be passed to the sequencer function.</p>\n<p>This is an example of a dummy sequencer:</p>\n<pre><code class=\"javascript\">function dummySeq() &#123;\n  return function() &#123;\n    return &quot;dummy&quot;;\n  &#125;;\n&#125;\n</code></pre>\n<p>To test generator(), you could use <code>dummySeq()</code> in this way:</p>\n<pre><code class=\"javascript\">var seq = generator(dummySeq);\nseq.next(); // &#39;dummy&#39;\nseq.next(); // &#39;dummy&#39;\nseq.next(); // &#39;dummy&#39;\n....\n</code></pre>\n<p>When you’re done, you should implement the following generators (I think the functions are self explanatory):</p>\n<pre><code class=\"javascript\">function factorialSeq() &#123;...&#125; // 1, 1, 2, 6, 24, ...\nfunction fibonacciSeq() &#123;...&#125; // 1, 1, 2, 3, 5, 8, 13, ...\nfunction rangeSeq(start, step) &#123;...&#125; // rangeSeq(1, 2)  -&gt; 1, 3, 5, 7, ...\nfunction primeSeq() &#123;...&#125; // 2, 3, 5, 7, 11, 13, ...\npartialSumSeq(1, 3, 7, 2, 0) &#123;...&#125; // 1, 4, 11, 13, 13, end\n</code></pre>\n<p>You can use any of them in the same way:</p>\n<pre><code class=\"javascript\">var seq = generator(factorialSeq);\nseq.next(); // !0 = 1\nseq.next(); // !1 = 1\nseq.next(); // !2 = 2\nseq.next(); // !3 = 6\nseq.next(); // !4 = 24\n...\n</code></pre>\n<p>There are some sequences which are infinite and others are not. For example:</p>\n<ul>\n<li>  primeSeq: Is infinite</li>\n<li>  partialSumSeq: Is limited to the passed values.</li>\n</ul>\n<p>When the sequence is done (in finite sequences), if you call seq.next() again, it should produce an error.</p>\n<p>Good luck!</p>\n<h2 id=\"Solutions\"><a href=\"#Solutions\" class=\"headerlink\" title=\"Solutions\"></a>Solutions</h2><p>题目的大体含义是想要通过 ES5 来模拟 ES6 中才有的 generator 生成器功能。主要思路就是使用闭包 closure 这一特性：</p>\n<pre><code class=\"javascript\">function generator(sequencer) &#123;\n    var args = Array.prototype.slice.call(arguments, 1);\n    return &#123;\n        next: sequencer.apply(this,args)\n    &#125;;\n&#125;\n\nfunction fibonacciSeq() &#123;\n    var prev = 0\n    var current = 1\n    return function() &#123;\n        var old = current\n        current = prev + current\n        prev = old\n        return prev\n    &#125;\n&#125;\n\n// 直接调用\nconsole.log(fibonacciSeq()())\n// 使用 closure\nvar seq = fibonacciSeq()\nconsole.log(seq())\n</code></pre>\n<p>关于 Closure，非常推荐阅读 Kyle Simpson 写的 <em>You Don’t Know JS: Scope &amp; Closures</em> ，不到 100 页的小册子，由浅入深，通俗易懂。Closure 简单来讲，就是在一个函数内部定义一个嵌套的子函数，并 return 它，return 这个子函数。形式就像上面代码，在 <code>fibonacciSeq()</code> 函数里 return 了一个 anonymous function，匿名函数。这样做的好处就是，把 <code>fibonacciSeq()</code> 私有变量 <code>prev</code>, <code>current</code> 保护起来，<strong>同时又能通过返回的 anonymous function 去修改函数的私有变量</strong>。听起来很绕。很实用，因为一般来讲，我们是无法在函数的外部去修改一个函数内部的私有变量的，但 closure 却可以。或者换句话，通过「在函数 A 中返回一个子函数」这样的操作，可以去修改函数 A 的私有变量。</p>\n<p>这里关于 closure，主要想提及几个点：</p>\n<p>一、<code>fibonacciSeq()()</code> 和 <code>seq()</code> 区别</p>\n<p>二者函数的调用和执行都不同。<code>fibonacciSeq()()</code> 则是先调用函数 <code>fibonacciSeq()</code>，该函数返回一个匿名函数，再继续调用该匿名函数，得到匿名函数的返回值。所以是连续调用了两个函数，外层函数和内层函数，整个 <code>fibonacciSeq()</code> 函数中的语句都被执行了。</p>\n<p>而使用 closure，首先定义变量 <code>var seq = fibonacciSeq()</code>，然后在调用 <code>seq()</code> 的过程中，仅仅调用执行了 <code>fibonacciSeq()</code> 里内部返回的的匿名函数，换句话说，在执行 <code>seq()</code> 的过程中， <code>fibonacciSeq()</code>  函数并没有被调用执行，整个过程真正调用执行的<strong>只有</strong>被嵌套的内层子函数，也就是返回的匿名函数，anonymous function。</p>\n<p>这么一个简单区别就造成了，前者 <code>fibonacciSeq()()</code> 即便调用无数次，输出结果都是相同的，都是 <code>1</code>。而后者调用多次，却能够得到 Fibonacci 数列 <code>1,1,2,3,5…</code>。原因就在于 closure，虽然仅仅执行了匿名函数，但因为匿名函数是作为子函数存在于  <code>fibonacciSeq()</code>  函数内，所以根据 Lexical scope 的规则，内层函数是可以 access 到外层函数的变量的。所以在执行 <code>seq()</code> 的过程中，程序从内到外寻找变量  <code>prev</code>, <code>current</code>， 不仅在 <code>fibonacciSeq()</code>  找到了它的私有变量  <code>prev</code>, <code>current</code> ，而且还修改了它们的值！被修改了值的私有变量依旧保持在原来位置，即仍然作为函数的私有变量存在。这一点在文章 <a href=\"https://javascript.info/closure\">Closure - The Modern JavaScript Tutorial</a> 中有梗详细的解释，这里就不赘述了。</p>\n<p>二、其他一些细节</p>\n<p>在 <code>generator()</code> 中使用的 <code>call()</code> <code>apply()</code> 方法，主要是为了函数传参。 </p>\n<ul>\n<li>  <code>Array.prototype.slice.call(arguments, 1)</code> </li>\n</ul>\n<p>因为 <code>arguments</code> 是一个 array-like object，而不是真正的 array，所以无法使用 array 的诸多方法，包括 slice。<code>call()</code> 的作用就是让 <code>arguments</code> 用上 slice 方法。在这里去掉了  <code>arguments</code> 里的第一个元素，剩下元素作为一个新的 array 存储到 <code>args</code> 中。</p>\n<ul>\n<li>  <code>sequencer.apply(this,args)</code></li>\n</ul>\n<p>绑定 this 到 <code>sequencer </code> 并将参数 <code>args</code> 传递到函数中。</p>\n<p>参考：</p>\n<ul>\n<li>  <a href=\"https://www.quora.com/What-are-the-reasons-to-use-return-function-in-JavaScript\">What are the reasons to use ‘return function’ in JavaScript? - Quora</a></li>\n<li>  <a href=\"https://javascript.info/closure\">Closure - The Modern JavaScript Tutorial</a> ✪</li>\n<li>  You Don’t Know JS: Scope &amp; Closures - Kyle Simpson</li>\n</ul>"},{"title":"Catching Car Mileage Numbers","date":"2019-01-18T14:44:33.000Z","_content":"\n## Kata\n\n>   \"7777...*8?!??!*\", exclaimed Bob, \"I missed it again! Argh!\" Every time there's an interesting number coming up, he notices and then promptly forgets. Who *doesn't* like catching those one-off interesting mileage numbers?\n\nLet's make it so Bob **never** misses another interesting number. We've hacked into his car's computer, and we have a box hooked up that reads mileage numbers. We've got a box glued to his dash that lights up yellow or green depending on whether it receives a `1` or a `2` (respectively).\n\nIt's up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a `2` if the number is \"interesting\" (see below), a `1` if an interesting number occurs within the next two miles, or a `0` if the number is not interesting.\n\n<!-- more -->\n\n**Note:** In Haskell, we use `No`, `Almost` and `Yes` instead of `0`, `1` and `2`.\n\n **\"Interesting\" Numbers**\n\nInteresting numbers are 3-or-more digit numbers that meet one or more of the following criteria:\n\n-   Any digit followed by all zeros: `100`, `90000`\n-   Every digit is the same number: `1111`\n-   The digits are sequential, incementing†: `1234`\n-   The digits are sequential, decrementing‡: `4321`\n-   The digits are a palindrome: `1221` or `73837`\n-   The digits match one of the values in the `awesomePhrases` array\n\n>   † For incrementing sequences, `0` should come after `9`, and not before  `1`, as in `7890`.\n>   ‡ For decrementing sequences, `0` should come after `1`, and not before  `9`, as in `3210`.\n\nSo, you should expect these inputs and outputs:\n\n```javascript\n// \"boring\" numbers\nisInteresting(3, [1337, 256]);    // 0\nisInteresting(3236, [1337, 256]); // 0\n\n// progress as we near an \"interesting\" number\nisInteresting(11207, []); // 0\nisInteresting(11208, []); // 0\nisInteresting(11209, []); // 1\nisInteresting(11210, []); // 1\nisInteresting(11211, []); // 2\n\n// nearing a provided \"awesome phrase\"\nisInteresting(1335, [1337, 256]); // 1\nisInteresting(1336, [1337, 256]); // 1\nisInteresting(1337, [1337, 256]); // 2\n\n```\n\n**Error Checking**\n\n-   A number is only interesting if it is greater than `99`!\n-   Input will *always* be an integer greater than `0`, and less than `1,000,000,000`. \n-   The `awesomePhrases` array will always be provided, and will always be an array, but may be empty. (Not *everyone* thinks numbers spell funny words...)\n-   You should only ever output `0`, `1`, or `2`.\n\n\n\n***\n\n## Solution\n\n题目很长，但总结起来，无非就是输入一个 number 类型的数据，检查是否符合上述列出的所谓「interesting number」的规则，按照规则输出 0，1 或 2。以下是自己看到的一个非常简洁的答案，答案来自 [laoris](https://www.codewars.com/users/laoris), [jwong483](https://www.codewars.com/users/jwong483), [Marlen](https://www.codewars.com/users/Marlen)：\n\n```javascript\nfunction isInteresting(number, awesomePhrases) {\n  var tests = [\n    function(n) { return /^\\d00+$/.test(n); },\n    function(n) { return /^(\\d)\\1+$/.test(n); },\n    function(n) { return RegExp(n).test(1234567890); },\n    function(n) { return RegExp(n).test(9876543210); },\n    function(n) { return n + '' == (n + '').split('').reverse().join(''); },\n    function(n) { return awesomePhrases.some(function(p) { return p == n; }); }\n  ];\n\n  var interesting = 0;\n  tests.some(function(test) {\n    if (number > 99 && test(number))\n      return interesting = 2;\n    else if ((number > 98 && test(number + 1)) || (number > 97 && test(number + 2)))\n      interesting = 1;\n  });\n  return interesting;\n}\n```\n\n这个答案在代码结构上很厉害的一点在于，使用了 `some()` 这个函数，以及加上完全由函数组成的 array 数组，来进行给定规则的检验。 `some()` 方法主要用于测试数组中某些元素。用法就是在方法 `some()` 中定义一个 callback 回调函数，数组中的每一个元素作为回调函数的参数依次传入到回调函数中（回调函数的意思就是函数作为函数的参数，这里有点儿绕） 。\n\n在这个例子里，`tests` 是事先定义好的数组，数组的每一个元素都是一个函数。对这个数组使用 `some()` 方法，在其中定义了一个回调函数，形如：\n\n```javascript\ntests.some(function(test){\n    if（number > 99 && test(number)){\n        // code here\n    }\n    //code here\n})\n```\n\n在实际执行过程中，`tests` 中的每一个元素 element，都会作为回调函数的参数 `test` 传递进回调函数中。因为 `tests`  数组里的元素都是函数，所以这里使用参数  `test`  时也是把它当作函数来使用的。因此才会看到有 `test(number)` 这样的语句。\n\n关于 `some()` 方法，MDN 上给了一个更加简单的例子，来帮助理解这其中的参数传导：\n\n```javascript\nfunction isBigEnough(element, index, array) {\n  return (element >= 10);\n}\nvar passed = [2, 5, 8, 1, 4].some(isBigEnough);\n// passed is false\npassed = [12, 5, 8, 1, 4].some(isBigEnough);\n// passed is true\n```\n\n明白了整个算法的结构，其实在 `tests` 中定义的检测函数，也都非常巧妙。 \n\n-   形如 [1234, 8765] 这类数，把被检测数转化成 `RegExp` 逆向使用正则表达式；\n-   `n+''` 把数字转化成数组；\n-   检测 palindrome 回文数，使用 `reverse()` 方法，判断反转后是否相等。","source":"_posts/Codewars.com-|-Catching-Car-Mileage-Numbers.md","raw":"---\ntitle: 'Catching Car Mileage Numbers'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## Kata\n\n>   \"7777...*8?!??!*\", exclaimed Bob, \"I missed it again! Argh!\" Every time there's an interesting number coming up, he notices and then promptly forgets. Who *doesn't* like catching those one-off interesting mileage numbers?\n\nLet's make it so Bob **never** misses another interesting number. We've hacked into his car's computer, and we have a box hooked up that reads mileage numbers. We've got a box glued to his dash that lights up yellow or green depending on whether it receives a `1` or a `2` (respectively).\n\nIt's up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a `2` if the number is \"interesting\" (see below), a `1` if an interesting number occurs within the next two miles, or a `0` if the number is not interesting.\n\n<!-- more -->\n\n**Note:** In Haskell, we use `No`, `Almost` and `Yes` instead of `0`, `1` and `2`.\n\n **\"Interesting\" Numbers**\n\nInteresting numbers are 3-or-more digit numbers that meet one or more of the following criteria:\n\n-   Any digit followed by all zeros: `100`, `90000`\n-   Every digit is the same number: `1111`\n-   The digits are sequential, incementing†: `1234`\n-   The digits are sequential, decrementing‡: `4321`\n-   The digits are a palindrome: `1221` or `73837`\n-   The digits match one of the values in the `awesomePhrases` array\n\n>   † For incrementing sequences, `0` should come after `9`, and not before  `1`, as in `7890`.\n>   ‡ For decrementing sequences, `0` should come after `1`, and not before  `9`, as in `3210`.\n\nSo, you should expect these inputs and outputs:\n\n```javascript\n// \"boring\" numbers\nisInteresting(3, [1337, 256]);    // 0\nisInteresting(3236, [1337, 256]); // 0\n\n// progress as we near an \"interesting\" number\nisInteresting(11207, []); // 0\nisInteresting(11208, []); // 0\nisInteresting(11209, []); // 1\nisInteresting(11210, []); // 1\nisInteresting(11211, []); // 2\n\n// nearing a provided \"awesome phrase\"\nisInteresting(1335, [1337, 256]); // 1\nisInteresting(1336, [1337, 256]); // 1\nisInteresting(1337, [1337, 256]); // 2\n\n```\n\n**Error Checking**\n\n-   A number is only interesting if it is greater than `99`!\n-   Input will *always* be an integer greater than `0`, and less than `1,000,000,000`. \n-   The `awesomePhrases` array will always be provided, and will always be an array, but may be empty. (Not *everyone* thinks numbers spell funny words...)\n-   You should only ever output `0`, `1`, or `2`.\n\n\n\n***\n\n## Solution\n\n题目很长，但总结起来，无非就是输入一个 number 类型的数据，检查是否符合上述列出的所谓「interesting number」的规则，按照规则输出 0，1 或 2。以下是自己看到的一个非常简洁的答案，答案来自 [laoris](https://www.codewars.com/users/laoris), [jwong483](https://www.codewars.com/users/jwong483), [Marlen](https://www.codewars.com/users/Marlen)：\n\n```javascript\nfunction isInteresting(number, awesomePhrases) {\n  var tests = [\n    function(n) { return /^\\d00+$/.test(n); },\n    function(n) { return /^(\\d)\\1+$/.test(n); },\n    function(n) { return RegExp(n).test(1234567890); },\n    function(n) { return RegExp(n).test(9876543210); },\n    function(n) { return n + '' == (n + '').split('').reverse().join(''); },\n    function(n) { return awesomePhrases.some(function(p) { return p == n; }); }\n  ];\n\n  var interesting = 0;\n  tests.some(function(test) {\n    if (number > 99 && test(number))\n      return interesting = 2;\n    else if ((number > 98 && test(number + 1)) || (number > 97 && test(number + 2)))\n      interesting = 1;\n  });\n  return interesting;\n}\n```\n\n这个答案在代码结构上很厉害的一点在于，使用了 `some()` 这个函数，以及加上完全由函数组成的 array 数组，来进行给定规则的检验。 `some()` 方法主要用于测试数组中某些元素。用法就是在方法 `some()` 中定义一个 callback 回调函数，数组中的每一个元素作为回调函数的参数依次传入到回调函数中（回调函数的意思就是函数作为函数的参数，这里有点儿绕） 。\n\n在这个例子里，`tests` 是事先定义好的数组，数组的每一个元素都是一个函数。对这个数组使用 `some()` 方法，在其中定义了一个回调函数，形如：\n\n```javascript\ntests.some(function(test){\n    if（number > 99 && test(number)){\n        // code here\n    }\n    //code here\n})\n```\n\n在实际执行过程中，`tests` 中的每一个元素 element，都会作为回调函数的参数 `test` 传递进回调函数中。因为 `tests`  数组里的元素都是函数，所以这里使用参数  `test`  时也是把它当作函数来使用的。因此才会看到有 `test(number)` 这样的语句。\n\n关于 `some()` 方法，MDN 上给了一个更加简单的例子，来帮助理解这其中的参数传导：\n\n```javascript\nfunction isBigEnough(element, index, array) {\n  return (element >= 10);\n}\nvar passed = [2, 5, 8, 1, 4].some(isBigEnough);\n// passed is false\npassed = [12, 5, 8, 1, 4].some(isBigEnough);\n// passed is true\n```\n\n明白了整个算法的结构，其实在 `tests` 中定义的检测函数，也都非常巧妙。 \n\n-   形如 [1234, 8765] 这类数，把被检测数转化成 `RegExp` 逆向使用正则表达式；\n-   `n+''` 把数字转化成数组；\n-   检测 palindrome 回文数，使用 `reverse()` 方法，判断反转后是否相等。","slug":"Codewars.com-|-Catching-Car-Mileage-Numbers","published":1,"updated":"2019-01-18T14:44:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx24000lrg1v06ehfj72","content":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><blockquote>\n<p>  “7777…<em>8?!??!</em>“, exclaimed Bob, “I missed it again! Argh!” Every time there’s an interesting number coming up, he notices and then promptly forgets. Who <em>doesn’t</em> like catching those one-off interesting mileage numbers?</p>\n</blockquote>\n<p>Let’s make it so Bob <strong>never</strong> misses another interesting number. We’ve hacked into his car’s computer, and we have a box hooked up that reads mileage numbers. We’ve got a box glued to his dash that lights up yellow or green depending on whether it receives a <code>1</code> or a <code>2</code> (respectively).</p>\n<p>It’s up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a <code>2</code> if the number is “interesting” (see below), a <code>1</code> if an interesting number occurs within the next two miles, or a <code>0</code> if the number is not interesting.</p>\n<span id=\"more\"></span>\n\n<p><strong>Note:</strong> In Haskell, we use <code>No</code>, <code>Almost</code> and <code>Yes</code> instead of <code>0</code>, <code>1</code> and <code>2</code>.</p>\n<p> <strong>“Interesting” Numbers</strong></p>\n<p>Interesting numbers are 3-or-more digit numbers that meet one or more of the following criteria:</p>\n<ul>\n<li>  Any digit followed by all zeros: <code>100</code>, <code>90000</code></li>\n<li>  Every digit is the same number: <code>1111</code></li>\n<li>  The digits are sequential, incementing†: <code>1234</code></li>\n<li>  The digits are sequential, decrementing‡: <code>4321</code></li>\n<li>  The digits are a palindrome: <code>1221</code> or <code>73837</code></li>\n<li>  The digits match one of the values in the <code>awesomePhrases</code> array</li>\n</ul>\n<blockquote>\n<p>  † For incrementing sequences, <code>0</code> should come after <code>9</code>, and not before  <code>1</code>, as in <code>7890</code>.<br>  ‡ For decrementing sequences, <code>0</code> should come after <code>1</code>, and not before  <code>9</code>, as in <code>3210</code>.</p>\n</blockquote>\n<p>So, you should expect these inputs and outputs:</p>\n<pre><code class=\"javascript\">// &quot;boring&quot; numbers\nisInteresting(3, [1337, 256]);    // 0\nisInteresting(3236, [1337, 256]); // 0\n\n// progress as we near an &quot;interesting&quot; number\nisInteresting(11207, []); // 0\nisInteresting(11208, []); // 0\nisInteresting(11209, []); // 1\nisInteresting(11210, []); // 1\nisInteresting(11211, []); // 2\n\n// nearing a provided &quot;awesome phrase&quot;\nisInteresting(1335, [1337, 256]); // 1\nisInteresting(1336, [1337, 256]); // 1\nisInteresting(1337, [1337, 256]); // 2\n</code></pre>\n<p><strong>Error Checking</strong></p>\n<ul>\n<li>  A number is only interesting if it is greater than <code>99</code>!</li>\n<li>  Input will <em>always</em> be an integer greater than <code>0</code>, and less than <code>1,000,000,000</code>. </li>\n<li>  The <code>awesomePhrases</code> array will always be provided, and will always be an array, but may be empty. (Not <em>everyone</em> thinks numbers spell funny words…)</li>\n<li>  You should only ever output <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n<hr>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>题目很长，但总结起来，无非就是输入一个 number 类型的数据，检查是否符合上述列出的所谓「interesting number」的规则，按照规则输出 0，1 或 2。以下是自己看到的一个非常简洁的答案，答案来自 <a href=\"https://www.codewars.com/users/laoris\">laoris</a>, <a href=\"https://www.codewars.com/users/jwong483\">jwong483</a>, <a href=\"https://www.codewars.com/users/Marlen\">Marlen</a>：</p>\n<pre><code class=\"javascript\">function isInteresting(number, awesomePhrases) &#123;\n  var tests = [\n    function(n) &#123; return /^\\d00+$/.test(n); &#125;,\n    function(n) &#123; return /^(\\d)\\1+$/.test(n); &#125;,\n    function(n) &#123; return RegExp(n).test(1234567890); &#125;,\n    function(n) &#123; return RegExp(n).test(9876543210); &#125;,\n    function(n) &#123; return n + &#39;&#39; == (n + &#39;&#39;).split(&#39;&#39;).reverse().join(&#39;&#39;); &#125;,\n    function(n) &#123; return awesomePhrases.some(function(p) &#123; return p == n; &#125;); &#125;\n  ];\n\n  var interesting = 0;\n  tests.some(function(test) &#123;\n    if (number &gt; 99 &amp;&amp; test(number))\n      return interesting = 2;\n    else if ((number &gt; 98 &amp;&amp; test(number + 1)) || (number &gt; 97 &amp;&amp; test(number + 2)))\n      interesting = 1;\n  &#125;);\n  return interesting;\n&#125;\n</code></pre>\n<p>这个答案在代码结构上很厉害的一点在于，使用了 <code>some()</code> 这个函数，以及加上完全由函数组成的 array 数组，来进行给定规则的检验。 <code>some()</code> 方法主要用于测试数组中某些元素。用法就是在方法 <code>some()</code> 中定义一个 callback 回调函数，数组中的每一个元素作为回调函数的参数依次传入到回调函数中（回调函数的意思就是函数作为函数的参数，这里有点儿绕） 。</p>\n<p>在这个例子里，<code>tests</code> 是事先定义好的数组，数组的每一个元素都是一个函数。对这个数组使用 <code>some()</code> 方法，在其中定义了一个回调函数，形如：</p>\n<pre><code class=\"javascript\">tests.some(function(test)&#123;\n    if（number &gt; 99 &amp;&amp; test(number))&#123;\n        // code here\n    &#125;\n    //code here\n&#125;)\n</code></pre>\n<p>在实际执行过程中，<code>tests</code> 中的每一个元素 element，都会作为回调函数的参数 <code>test</code> 传递进回调函数中。因为 <code>tests</code>  数组里的元素都是函数，所以这里使用参数  <code>test</code>  时也是把它当作函数来使用的。因此才会看到有 <code>test(number)</code> 这样的语句。</p>\n<p>关于 <code>some()</code> 方法，MDN 上给了一个更加简单的例子，来帮助理解这其中的参数传导：</p>\n<pre><code class=\"javascript\">function isBigEnough(element, index, array) &#123;\n  return (element &gt;= 10);\n&#125;\nvar passed = [2, 5, 8, 1, 4].some(isBigEnough);\n// passed is false\npassed = [12, 5, 8, 1, 4].some(isBigEnough);\n// passed is true\n</code></pre>\n<p>明白了整个算法的结构，其实在 <code>tests</code> 中定义的检测函数，也都非常巧妙。 </p>\n<ul>\n<li>  形如 [1234, 8765] 这类数，把被检测数转化成 <code>RegExp</code> 逆向使用正则表达式；</li>\n<li>  <code>n+&#39;&#39;</code> 把数字转化成数组；</li>\n<li>  检测 palindrome 回文数，使用 <code>reverse()</code> 方法，判断反转后是否相等。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Kata\"><a href=\"#Kata\" class=\"headerlink\" title=\"Kata\"></a>Kata</h2><blockquote>\n<p>  “7777…<em>8?!??!</em>“, exclaimed Bob, “I missed it again! Argh!” Every time there’s an interesting number coming up, he notices and then promptly forgets. Who <em>doesn’t</em> like catching those one-off interesting mileage numbers?</p>\n</blockquote>\n<p>Let’s make it so Bob <strong>never</strong> misses another interesting number. We’ve hacked into his car’s computer, and we have a box hooked up that reads mileage numbers. We’ve got a box glued to his dash that lights up yellow or green depending on whether it receives a <code>1</code> or a <code>2</code> (respectively).</p>\n<p>It’s up to you, intrepid warrior, to glue the parts together. Write the function that parses the mileage number input, and returns a <code>2</code> if the number is “interesting” (see below), a <code>1</code> if an interesting number occurs within the next two miles, or a <code>0</code> if the number is not interesting.</p>","more":"<p><strong>Note:</strong> In Haskell, we use <code>No</code>, <code>Almost</code> and <code>Yes</code> instead of <code>0</code>, <code>1</code> and <code>2</code>.</p>\n<p> <strong>“Interesting” Numbers</strong></p>\n<p>Interesting numbers are 3-or-more digit numbers that meet one or more of the following criteria:</p>\n<ul>\n<li>  Any digit followed by all zeros: <code>100</code>, <code>90000</code></li>\n<li>  Every digit is the same number: <code>1111</code></li>\n<li>  The digits are sequential, incementing†: <code>1234</code></li>\n<li>  The digits are sequential, decrementing‡: <code>4321</code></li>\n<li>  The digits are a palindrome: <code>1221</code> or <code>73837</code></li>\n<li>  The digits match one of the values in the <code>awesomePhrases</code> array</li>\n</ul>\n<blockquote>\n<p>  † For incrementing sequences, <code>0</code> should come after <code>9</code>, and not before  <code>1</code>, as in <code>7890</code>.<br>  ‡ For decrementing sequences, <code>0</code> should come after <code>1</code>, and not before  <code>9</code>, as in <code>3210</code>.</p>\n</blockquote>\n<p>So, you should expect these inputs and outputs:</p>\n<pre><code class=\"javascript\">// &quot;boring&quot; numbers\nisInteresting(3, [1337, 256]);    // 0\nisInteresting(3236, [1337, 256]); // 0\n\n// progress as we near an &quot;interesting&quot; number\nisInteresting(11207, []); // 0\nisInteresting(11208, []); // 0\nisInteresting(11209, []); // 1\nisInteresting(11210, []); // 1\nisInteresting(11211, []); // 2\n\n// nearing a provided &quot;awesome phrase&quot;\nisInteresting(1335, [1337, 256]); // 1\nisInteresting(1336, [1337, 256]); // 1\nisInteresting(1337, [1337, 256]); // 2\n</code></pre>\n<p><strong>Error Checking</strong></p>\n<ul>\n<li>  A number is only interesting if it is greater than <code>99</code>!</li>\n<li>  Input will <em>always</em> be an integer greater than <code>0</code>, and less than <code>1,000,000,000</code>. </li>\n<li>  The <code>awesomePhrases</code> array will always be provided, and will always be an array, but may be empty. (Not <em>everyone</em> thinks numbers spell funny words…)</li>\n<li>  You should only ever output <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n<hr>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>题目很长，但总结起来，无非就是输入一个 number 类型的数据，检查是否符合上述列出的所谓「interesting number」的规则，按照规则输出 0，1 或 2。以下是自己看到的一个非常简洁的答案，答案来自 <a href=\"https://www.codewars.com/users/laoris\">laoris</a>, <a href=\"https://www.codewars.com/users/jwong483\">jwong483</a>, <a href=\"https://www.codewars.com/users/Marlen\">Marlen</a>：</p>\n<pre><code class=\"javascript\">function isInteresting(number, awesomePhrases) &#123;\n  var tests = [\n    function(n) &#123; return /^\\d00+$/.test(n); &#125;,\n    function(n) &#123; return /^(\\d)\\1+$/.test(n); &#125;,\n    function(n) &#123; return RegExp(n).test(1234567890); &#125;,\n    function(n) &#123; return RegExp(n).test(9876543210); &#125;,\n    function(n) &#123; return n + &#39;&#39; == (n + &#39;&#39;).split(&#39;&#39;).reverse().join(&#39;&#39;); &#125;,\n    function(n) &#123; return awesomePhrases.some(function(p) &#123; return p == n; &#125;); &#125;\n  ];\n\n  var interesting = 0;\n  tests.some(function(test) &#123;\n    if (number &gt; 99 &amp;&amp; test(number))\n      return interesting = 2;\n    else if ((number &gt; 98 &amp;&amp; test(number + 1)) || (number &gt; 97 &amp;&amp; test(number + 2)))\n      interesting = 1;\n  &#125;);\n  return interesting;\n&#125;\n</code></pre>\n<p>这个答案在代码结构上很厉害的一点在于，使用了 <code>some()</code> 这个函数，以及加上完全由函数组成的 array 数组，来进行给定规则的检验。 <code>some()</code> 方法主要用于测试数组中某些元素。用法就是在方法 <code>some()</code> 中定义一个 callback 回调函数，数组中的每一个元素作为回调函数的参数依次传入到回调函数中（回调函数的意思就是函数作为函数的参数，这里有点儿绕） 。</p>\n<p>在这个例子里，<code>tests</code> 是事先定义好的数组，数组的每一个元素都是一个函数。对这个数组使用 <code>some()</code> 方法，在其中定义了一个回调函数，形如：</p>\n<pre><code class=\"javascript\">tests.some(function(test)&#123;\n    if（number &gt; 99 &amp;&amp; test(number))&#123;\n        // code here\n    &#125;\n    //code here\n&#125;)\n</code></pre>\n<p>在实际执行过程中，<code>tests</code> 中的每一个元素 element，都会作为回调函数的参数 <code>test</code> 传递进回调函数中。因为 <code>tests</code>  数组里的元素都是函数，所以这里使用参数  <code>test</code>  时也是把它当作函数来使用的。因此才会看到有 <code>test(number)</code> 这样的语句。</p>\n<p>关于 <code>some()</code> 方法，MDN 上给了一个更加简单的例子，来帮助理解这其中的参数传导：</p>\n<pre><code class=\"javascript\">function isBigEnough(element, index, array) &#123;\n  return (element &gt;= 10);\n&#125;\nvar passed = [2, 5, 8, 1, 4].some(isBigEnough);\n// passed is false\npassed = [12, 5, 8, 1, 4].some(isBigEnough);\n// passed is true\n</code></pre>\n<p>明白了整个算法的结构，其实在 <code>tests</code> 中定义的检测函数，也都非常巧妙。 </p>\n<ul>\n<li>  形如 [1234, 8765] 这类数，把被检测数转化成 <code>RegExp</code> 逆向使用正则表达式；</li>\n<li>  <code>n+&#39;&#39;</code> 把数字转化成数组；</li>\n<li>  检测 palindrome 回文数，使用 <code>reverse()</code> 方法，判断反转后是否相等。</li>\n</ul>"},{"title":"Default Arguments | 4kyu","date":"2019-01-22T15:14:34.000Z","_content":"\n## Details\n\nWrite a function `defaultArguments`. It takes a function as an argument, along with an object containing default values for that function's arguments, and returns another function which defaults to the right values. \n\nYou cannot assume that the function's arguments have any particular names.\n\nYou should be able to call `defaultArguments` repeatedly to change the defaults.\n\n```javascript\nfunction add(a,b) { return a+b;};\n\nvar add_ = defaultArguments(add,{b:9});\nadd_(10); // returns 19\nadd_(10,7); // returns 17\nadd_(); // returns NaN\n\nadd_ = defaultArguments(add_,{b:3, a:2});\nadd_(10); // returns 13 now\nadd_(); // returns 5\n\nadd_ = defaultArguments(add_,{c:3}); // doesn't do anything, since c isn't an argument\nadd_(10); // returns NaN\nadd_(10,10); // returns 20\n```\n\nHINT: This problem requires using `Fuction.prototype.toString()` in order to extract a function's argument list\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction defaultArguments(func, params) {\n\n    // get the properties list of params\n    let defArg = Object.keys(params);\n\n    // use Function.prototype.toString() to get the arguments list\n    let args = func.args || func.toString().replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, '').match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(',');\n\n    // pass the properties into func\n    let newArgs = {};\n    for (var i = 0; i < defArg.length; i++) {\n        if (args.indexOf(defArg[i]) > -1) {\n            let idx = args.indexOf(defArg[i]);\n            newArgs[idx] = params[defArg[i]];\n        }\n    }\n    // bind the func and params into a new function\n\n    let detour = function() {\n                let argsArray = [].slice.call(arguments);\n                let x = Object.keys(newArgs);\n                for (var i = 0; i < x.length; i++) {\n                    if(x[i] >= argsArray.length) {\n                        argsArray[x[i]] = newArgs[x[i]];\n                    }\n                }\n                return func.apply(this,argsArray);\n            }\n    detour.args = args;\n    return detour;\n}\n```\n\n`args` 那一大串正则表达式，获得的是原函数的参数列表，是一个 array。`defArg` 是函数 `defaultArguments()` 预先给定的参数。将两者合并成新的参数 `newArgs` ，类型为 object。\n\n举例说明，如果 `params` 传入的值是 `{ b: 3, a: 2 }`，那么经过中间 10 行到 16 行的循环运算得到的 `newArgs` 值是 `{ '0': 2, '1': 3 }`。\n\n20 行 `argsArray = [].slice.call(arguments);`作用是打印参数列表。举例说明：\n\n```javascript\n>function add(a,b) { console.log([].slice.call(arguments));return a+b;};\nundefined\n>add(1,2)\n[ 1, 2 ]\n3\n>add(1,2,3)\n[ 1, 2, 3 ]\n3\n>add(1,2,3,4)\n[ 1, 2, 3, 4 ]\n3\n```\n\n因为整个函数最后 return 的是 detour。也就是说当第一次运行 `defaultArguments()` 时，仅仅是声明了 `detour()` 函数但是并没有运行。按照 details 里给出的例子，只有当 `add_(10)` 调用时， `detour()` 函数才真正被运行。此时的 `arguments ` 值为 `[10]`。\n\n27 行 `apply()` 方法的应用，就是调取 `func` 函数，并给他特定的 arguments 值，并获得结果。第一个参数是修改 `func` 函数的 `this` 指向的， 是 `this` 还是 `null` 对结果都是没有影响的。[因为都是对函数的直接调用，不存在对某个 object 的 method 进行调用。](https://stackoverflow.com/questions/9644044/javascript-this-pointer-within-nested-function)\n\n注意第 29 行的，函数也是 object，而且这个定义使得返回的函数对象多携带了 args 信息。这一点当时自己没有想到，也是看了答案后才明白的。\n\n## Other Solutions\n\n [mrkishi](https://www.codewars.com/users/mrkishi), [guyingll](https://www.codewars.com/users/guyingll), [iphp](https://www.codewars.com/users/iphp), [willin](https://www.codewars.com/users/willin), [marek_mistrzuk](https://www.codewars.com/users/marek_mistrzuk)\n\n```javascript\nfunction defaultArguments(func, params) {\n  var names = func.names || func.toString()\n    .replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, '')\n    .match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(',');\n  \n  var detour = function () {\n    var input = arguments;\n    return func.apply(this, names.map(function (val, i) {\n      return i < input.length ? input[i] : params[names[i]];\n    }));\n  };\n  \n  detour.names = names;\n  return detour;\n}\n```\n\n","source":"_posts/Default Arguments | 4kyu.md","raw":"---\ntitle: 'Default Arguments | 4kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## Details\n\nWrite a function `defaultArguments`. It takes a function as an argument, along with an object containing default values for that function's arguments, and returns another function which defaults to the right values. \n\nYou cannot assume that the function's arguments have any particular names.\n\nYou should be able to call `defaultArguments` repeatedly to change the defaults.\n\n```javascript\nfunction add(a,b) { return a+b;};\n\nvar add_ = defaultArguments(add,{b:9});\nadd_(10); // returns 19\nadd_(10,7); // returns 17\nadd_(); // returns NaN\n\nadd_ = defaultArguments(add_,{b:3, a:2});\nadd_(10); // returns 13 now\nadd_(); // returns 5\n\nadd_ = defaultArguments(add_,{c:3}); // doesn't do anything, since c isn't an argument\nadd_(10); // returns NaN\nadd_(10,10); // returns 20\n```\n\nHINT: This problem requires using `Fuction.prototype.toString()` in order to extract a function's argument list\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction defaultArguments(func, params) {\n\n    // get the properties list of params\n    let defArg = Object.keys(params);\n\n    // use Function.prototype.toString() to get the arguments list\n    let args = func.args || func.toString().replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, '').match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(',');\n\n    // pass the properties into func\n    let newArgs = {};\n    for (var i = 0; i < defArg.length; i++) {\n        if (args.indexOf(defArg[i]) > -1) {\n            let idx = args.indexOf(defArg[i]);\n            newArgs[idx] = params[defArg[i]];\n        }\n    }\n    // bind the func and params into a new function\n\n    let detour = function() {\n                let argsArray = [].slice.call(arguments);\n                let x = Object.keys(newArgs);\n                for (var i = 0; i < x.length; i++) {\n                    if(x[i] >= argsArray.length) {\n                        argsArray[x[i]] = newArgs[x[i]];\n                    }\n                }\n                return func.apply(this,argsArray);\n            }\n    detour.args = args;\n    return detour;\n}\n```\n\n`args` 那一大串正则表达式，获得的是原函数的参数列表，是一个 array。`defArg` 是函数 `defaultArguments()` 预先给定的参数。将两者合并成新的参数 `newArgs` ，类型为 object。\n\n举例说明，如果 `params` 传入的值是 `{ b: 3, a: 2 }`，那么经过中间 10 行到 16 行的循环运算得到的 `newArgs` 值是 `{ '0': 2, '1': 3 }`。\n\n20 行 `argsArray = [].slice.call(arguments);`作用是打印参数列表。举例说明：\n\n```javascript\n>function add(a,b) { console.log([].slice.call(arguments));return a+b;};\nundefined\n>add(1,2)\n[ 1, 2 ]\n3\n>add(1,2,3)\n[ 1, 2, 3 ]\n3\n>add(1,2,3,4)\n[ 1, 2, 3, 4 ]\n3\n```\n\n因为整个函数最后 return 的是 detour。也就是说当第一次运行 `defaultArguments()` 时，仅仅是声明了 `detour()` 函数但是并没有运行。按照 details 里给出的例子，只有当 `add_(10)` 调用时， `detour()` 函数才真正被运行。此时的 `arguments ` 值为 `[10]`。\n\n27 行 `apply()` 方法的应用，就是调取 `func` 函数，并给他特定的 arguments 值，并获得结果。第一个参数是修改 `func` 函数的 `this` 指向的， 是 `this` 还是 `null` 对结果都是没有影响的。[因为都是对函数的直接调用，不存在对某个 object 的 method 进行调用。](https://stackoverflow.com/questions/9644044/javascript-this-pointer-within-nested-function)\n\n注意第 29 行的，函数也是 object，而且这个定义使得返回的函数对象多携带了 args 信息。这一点当时自己没有想到，也是看了答案后才明白的。\n\n## Other Solutions\n\n [mrkishi](https://www.codewars.com/users/mrkishi), [guyingll](https://www.codewars.com/users/guyingll), [iphp](https://www.codewars.com/users/iphp), [willin](https://www.codewars.com/users/willin), [marek_mistrzuk](https://www.codewars.com/users/marek_mistrzuk)\n\n```javascript\nfunction defaultArguments(func, params) {\n  var names = func.names || func.toString()\n    .replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, '')\n    .match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(',');\n  \n  var detour = function () {\n    var input = arguments;\n    return func.apply(this, names.map(function (val, i) {\n      return i < input.length ? input[i] : params[names[i]];\n    }));\n  };\n  \n  detour.names = names;\n  return detour;\n}\n```\n\n","slug":"Default Arguments | 4kyu","published":1,"updated":"2019-01-22T15:14:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx25000org1v8kdmhwvv","content":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Write a function <code>defaultArguments</code>. It takes a function as an argument, along with an object containing default values for that function’s arguments, and returns another function which defaults to the right values. </p>\n<p>You cannot assume that the function’s arguments have any particular names.</p>\n<p>You should be able to call <code>defaultArguments</code> repeatedly to change the defaults.</p>\n<pre><code class=\"javascript\">function add(a,b) &#123; return a+b;&#125;;\n\nvar add_ = defaultArguments(add,&#123;b:9&#125;);\nadd_(10); // returns 19\nadd_(10,7); // returns 17\nadd_(); // returns NaN\n\nadd_ = defaultArguments(add_,&#123;b:3, a:2&#125;);\nadd_(10); // returns 13 now\nadd_(); // returns 5\n\nadd_ = defaultArguments(add_,&#123;c:3&#125;); // doesn&#39;t do anything, since c isn&#39;t an argument\nadd_(10); // returns NaN\nadd_(10,10); // returns 20\n</code></pre>\n<p>HINT: This problem requires using <code>Fuction.prototype.toString()</code> in order to extract a function’s argument list</p>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function defaultArguments(func, params) &#123;\n\n    // get the properties list of params\n    let defArg = Object.keys(params);\n\n    // use Function.prototype.toString() to get the arguments list\n    let args = func.args || func.toString().replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, &#39;&#39;).match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(&#39;,&#39;);\n\n    // pass the properties into func\n    let newArgs = &#123;&#125;;\n    for (var i = 0; i &lt; defArg.length; i++) &#123;\n        if (args.indexOf(defArg[i]) &gt; -1) &#123;\n            let idx = args.indexOf(defArg[i]);\n            newArgs[idx] = params[defArg[i]];\n        &#125;\n    &#125;\n    // bind the func and params into a new function\n\n    let detour = function() &#123;\n                let argsArray = [].slice.call(arguments);\n                let x = Object.keys(newArgs);\n                for (var i = 0; i &lt; x.length; i++) &#123;\n                    if(x[i] &gt;= argsArray.length) &#123;\n                        argsArray[x[i]] = newArgs[x[i]];\n                    &#125;\n                &#125;\n                return func.apply(this,argsArray);\n            &#125;\n    detour.args = args;\n    return detour;\n&#125;\n</code></pre>\n<p><code>args</code> 那一大串正则表达式，获得的是原函数的参数列表，是一个 array。<code>defArg</code> 是函数 <code>defaultArguments()</code> 预先给定的参数。将两者合并成新的参数 <code>newArgs</code> ，类型为 object。</p>\n<p>举例说明，如果 <code>params</code> 传入的值是 <code>&#123; b: 3, a: 2 &#125;</code>，那么经过中间 10 行到 16 行的循环运算得到的 <code>newArgs</code> 值是 <code>&#123; &#39;0&#39;: 2, &#39;1&#39;: 3 &#125;</code>。</p>\n<p>20 行 <code>argsArray = [].slice.call(arguments);</code>作用是打印参数列表。举例说明：</p>\n<pre><code class=\"javascript\">&gt;function add(a,b) &#123; console.log([].slice.call(arguments));return a+b;&#125;;\nundefined\n&gt;add(1,2)\n[ 1, 2 ]\n3\n&gt;add(1,2,3)\n[ 1, 2, 3 ]\n3\n&gt;add(1,2,3,4)\n[ 1, 2, 3, 4 ]\n3\n</code></pre>\n<p>因为整个函数最后 return 的是 detour。也就是说当第一次运行 <code>defaultArguments()</code> 时，仅仅是声明了 <code>detour()</code> 函数但是并没有运行。按照 details 里给出的例子，只有当 <code>add_(10)</code> 调用时， <code>detour()</code> 函数才真正被运行。此时的 <code>arguments </code> 值为 <code>[10]</code>。</p>\n<p>27 行 <code>apply()</code> 方法的应用，就是调取 <code>func</code> 函数，并给他特定的 arguments 值，并获得结果。第一个参数是修改 <code>func</code> 函数的 <code>this</code> 指向的， 是 <code>this</code> 还是 <code>null</code> 对结果都是没有影响的。<a href=\"https://stackoverflow.com/questions/9644044/javascript-this-pointer-within-nested-function\">因为都是对函数的直接调用，不存在对某个 object 的 method 进行调用。</a></p>\n<p>注意第 29 行的，函数也是 object，而且这个定义使得返回的函数对象多携带了 args 信息。这一点当时自己没有想到，也是看了答案后才明白的。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/mrkishi\">mrkishi</a>, <a href=\"https://www.codewars.com/users/guyingll\">guyingll</a>, <a href=\"https://www.codewars.com/users/iphp\">iphp</a>, <a href=\"https://www.codewars.com/users/willin\">willin</a>, <a href=\"https://www.codewars.com/users/marek_mistrzuk\">marek_mistrzuk</a></p>\n<pre><code class=\"javascript\">function defaultArguments(func, params) &#123;\n  var names = func.names || func.toString()\n    .replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, &#39;&#39;)\n    .match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(&#39;,&#39;);\n  \n  var detour = function () &#123;\n    var input = arguments;\n    return func.apply(this, names.map(function (val, i) &#123;\n      return i &lt; input.length ? input[i] : params[names[i]];\n    &#125;));\n  &#125;;\n  \n  detour.names = names;\n  return detour;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Write a function <code>defaultArguments</code>. It takes a function as an argument, along with an object containing default values for that function’s arguments, and returns another function which defaults to the right values. </p>\n<p>You cannot assume that the function’s arguments have any particular names.</p>\n<p>You should be able to call <code>defaultArguments</code> repeatedly to change the defaults.</p>\n<pre><code class=\"javascript\">function add(a,b) &#123; return a+b;&#125;;\n\nvar add_ = defaultArguments(add,&#123;b:9&#125;);\nadd_(10); // returns 19\nadd_(10,7); // returns 17\nadd_(); // returns NaN\n\nadd_ = defaultArguments(add_,&#123;b:3, a:2&#125;);\nadd_(10); // returns 13 now\nadd_(); // returns 5\n\nadd_ = defaultArguments(add_,&#123;c:3&#125;); // doesn&#39;t do anything, since c isn&#39;t an argument\nadd_(10); // returns NaN\nadd_(10,10); // returns 20\n</code></pre>\n<p>HINT: This problem requires using <code>Fuction.prototype.toString()</code> in order to extract a function’s argument list</p>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function defaultArguments(func, params) &#123;\n\n    // get the properties list of params\n    let defArg = Object.keys(params);\n\n    // use Function.prototype.toString() to get the arguments list\n    let args = func.args || func.toString().replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, &#39;&#39;).match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(&#39;,&#39;);\n\n    // pass the properties into func\n    let newArgs = &#123;&#125;;\n    for (var i = 0; i &lt; defArg.length; i++) &#123;\n        if (args.indexOf(defArg[i]) &gt; -1) &#123;\n            let idx = args.indexOf(defArg[i]);\n            newArgs[idx] = params[defArg[i]];\n        &#125;\n    &#125;\n    // bind the func and params into a new function\n\n    let detour = function() &#123;\n                let argsArray = [].slice.call(arguments);\n                let x = Object.keys(newArgs);\n                for (var i = 0; i &lt; x.length; i++) &#123;\n                    if(x[i] &gt;= argsArray.length) &#123;\n                        argsArray[x[i]] = newArgs[x[i]];\n                    &#125;\n                &#125;\n                return func.apply(this,argsArray);\n            &#125;\n    detour.args = args;\n    return detour;\n&#125;\n</code></pre>\n<p><code>args</code> 那一大串正则表达式，获得的是原函数的参数列表，是一个 array。<code>defArg</code> 是函数 <code>defaultArguments()</code> 预先给定的参数。将两者合并成新的参数 <code>newArgs</code> ，类型为 object。</p>\n<p>举例说明，如果 <code>params</code> 传入的值是 <code>&#123; b: 3, a: 2 &#125;</code>，那么经过中间 10 行到 16 行的循环运算得到的 <code>newArgs</code> 值是 <code>&#123; &#39;0&#39;: 2, &#39;1&#39;: 3 &#125;</code>。</p>\n<p>20 行 <code>argsArray = [].slice.call(arguments);</code>作用是打印参数列表。举例说明：</p>\n<pre><code class=\"javascript\">&gt;function add(a,b) &#123; console.log([].slice.call(arguments));return a+b;&#125;;\nundefined\n&gt;add(1,2)\n[ 1, 2 ]\n3\n&gt;add(1,2,3)\n[ 1, 2, 3 ]\n3\n&gt;add(1,2,3,4)\n[ 1, 2, 3, 4 ]\n3\n</code></pre>\n<p>因为整个函数最后 return 的是 detour。也就是说当第一次运行 <code>defaultArguments()</code> 时，仅仅是声明了 <code>detour()</code> 函数但是并没有运行。按照 details 里给出的例子，只有当 <code>add_(10)</code> 调用时， <code>detour()</code> 函数才真正被运行。此时的 <code>arguments </code> 值为 <code>[10]</code>。</p>\n<p>27 行 <code>apply()</code> 方法的应用，就是调取 <code>func</code> 函数，并给他特定的 arguments 值，并获得结果。第一个参数是修改 <code>func</code> 函数的 <code>this</code> 指向的， 是 <code>this</code> 还是 <code>null</code> 对结果都是没有影响的。<a href=\"https://stackoverflow.com/questions/9644044/javascript-this-pointer-within-nested-function\">因为都是对函数的直接调用，不存在对某个 object 的 method 进行调用。</a></p>\n<p>注意第 29 行的，函数也是 object，而且这个定义使得返回的函数对象多携带了 args 信息。这一点当时自己没有想到，也是看了答案后才明白的。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/mrkishi\">mrkishi</a>, <a href=\"https://www.codewars.com/users/guyingll\">guyingll</a>, <a href=\"https://www.codewars.com/users/iphp\">iphp</a>, <a href=\"https://www.codewars.com/users/willin\">willin</a>, <a href=\"https://www.codewars.com/users/marek_mistrzuk\">marek_mistrzuk</a></p>\n<pre><code class=\"javascript\">function defaultArguments(func, params) &#123;\n  var names = func.names || func.toString()\n    .replace(/\\/\\/.*$|\\/\\*.*?\\*\\/|\\s/gm, &#39;&#39;)\n    .match(/(?:[\\w]+(?:,[\\w]+)*)?(?=\\))/m)[0].split(&#39;,&#39;);\n  \n  var detour = function () &#123;\n    var input = arguments;\n    return func.apply(this, names.map(function (val, i) &#123;\n      return i &lt; input.length ? input[i] : params[names[i]];\n    &#125;));\n  &#125;;\n  \n  detour.names = names;\n  return detour;\n&#125;\n</code></pre>"},{"title":"Fly Me to the Moon","date":"2021-12-31T01:47:59.000Z","_content":"\n![zelda-botw](/images/zelda-botw.jpg)\n\n6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。\n\n但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，\n\n> 哎，又到了此刻。\n\n<!--more-->\n\n# 游戏\n\n- [女神异闻录5 皇家版](https://www.playstation.com/zh-hans-hk/games/persona-5-royal/) | PlayStation 5\n- [Metroid™ Dread](https://www.nintendo.com/games/detail/metroid-dread-switch/) | Nintendo Switch\n- [真・女神轉生V](http://asia.sega.com/megaten5/cht/) | Nintendo Switch\n\n*以上列表按照喜好顺序排名。*\n\n七夕节的那天收到 PS5，第一时间便入手了 P5R，从 8 月份到 9 月中旬，把自己所有的空闲时间都投入了进去。现代背景，荣格心理学，东京涩谷。日式 rpg 的框架下，种种设定让代入感过于强烈，以至于某些时刻，我仿佛真的回到了学生时代。挤地铁，上课，考试，看书，和一帮小伙伴嬉笑打闹。\n\n因为以前的学生时代，和现在真的有很大不同。经常一帮人一起玩某个游戏，一起打篮球。所以那天 p5r 一周目通关，想了一下，是时候约好友出来见一面聊聊天了。大家平日工作都很忙，虽然在同一个城市，但好久都没见面了。\n\n> 『女神异闻录』攻略到「回忆」部分结束，剧情的反转设计，和游戏交互上给人带来的沉浸感简直太棒了。几处伏笔并没有意识到，剧情上带来的合理性也让我没有太多思考，只是感到奇怪。使用的手法完全想不出来，太绝妙了。太久没有过这种「啊，竟然是这样，被骗了」这种感觉了。\n>\n> 完全没有想过黑衣人会是「认识的人」。倒叙的故事结构，因为药物而部分记忆丢失，通过只言片语的提示，让玩家和主角一起绞尽脑汁去回忆究竟是哪里出了问题，这样的设计，沉浸感和代入感太棒了。\n\n![p5r-ending](/images/p5r-ending.png)\n\nMetroidvania，一种游戏类型，中文翻译为「类银河战士恶魔城」，分别来自两款游戏，其一便是任天堂旗下的『密特罗德』，另一款是科樂美的『恶魔城』系列。之前玩过同类型的『奥日 1&2』，非常喜欢。对这一部也是期待了很久，也最终没有让我失望。20 多小时一周目通关，几个印象深刻的点是\n\n- 精巧的地图设计；\n- 超级复杂的按键；\n- 非常爽快的动作体验；\n- 破序玩法\n\n自己通关会去看了相关的速通视频，才知道原来这系列一直有着「破序玩法」的传统。\n\n![metroid](/images/metroid.png)\n\n因为玩过了 P5R，对于 ATLUS 这套神魔体系有所了解。比如「吉祥天」「爱丽丝」等等这些经典的形象。当本家新一作「真女神转生」发布的时候，很自然就第一时间入手了。初期的时候还是有很多不适应，直到我去买了 dlc，整个的游戏体验就好很多了。和外传不一样，本传的气质挺像『恶魔人Crybaby』的。大地图迷宫，战斗设计都非常精彩。唯一缺憾的可能还是 Switch 的机能。不时的卡顿，掉帧，和流畅，绚烂，不羁的 P5R 比起来，似乎还是差了一个时代。\n\n![shin-megami-tensei-v](/images/shin-megami-tensei-v.png)\n\n\n\n## 音乐\n\n- Can't Take My Eyes Off You - Joytastic Sarah\n- Another Day of Sun - La La Land Cast\n- Fly Me to the Moon - The Macarons Project\n- Happy Birthday ( Single Version Remix ) - Kyoko\n- On the Nature of Daylight - Max Richter\n\n[Replay 2021 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2021/pl.rp-6xxXTlPZDQL)\n\nJoytastic Sarah 算是一个惊喜，在 YouTube 上有她的[频道](https://www.youtube.com/c/JoytasticSarahCovers)，她的一些翻唱和混音真的非常好听。\n\n## 电影\n\n豆瓣记录里，今年总共看了 33 部电影。相比于去年的 13 部，提高了不少。有一些是周末的时候去到一个线下小众观影俱乐部看的。年初那会儿，有段时间每周末都过去。\n\n- 『金都』\n- 『无间道』三部曲\n- 『城市之光』\n- 『偶然与想象』\n- 『鱿鱼游戏』\n- 『新·福音战士剧场版：终』\n- 『弥留之国的爱丽丝』\n\n大部分的观影记录集中在了上半年。现在回想起来，看剧的时刻真的非常美妙。花上一下午或一个晚上，binge-watching 的去看整部剧。六七点钟时叫一家附近的披萨和冷饮。\n\n因为『鱿鱼游戏』，之后又去看了『弥留之国的爱丽丝』。\n\n16 年那会儿开始看 EVA，那个时候毕业，放假在家，一边学习德语，一边看剧，看电影。那段时间把 EVA 所有的 TV 剧集，旧剧场版，新剧场版的前三部都看完了。我至今都清楚得记得我当时看新剧场版『Q』的时刻，自己一个人坐在大大客厅沙发上，面对红的一片的屏幕。绫波丽缓缓的走来，明日香开始骂碇真嗣。镜头拉远，三个人就这样慢慢在空无一人红色大地上缓慢走着。\n\n![eva-1](/images/eva-1.png)\n\n![eva-2](/images/eva-2.png)\n\n![eva-3](/images/eva-3.png)\n\n![eva-4](/images/eva-4.png)\n\n即便是在等待了 5 年之后，看完了『新剧场版：终』。对于其他 EVA 粉丝，这个等待时间更久。在我心里，给我最大震撼和感动的还是来自『新剧场版：破』。在 16 年补完 EVA 的许多作品后，之后的很多时间，我都在循环听里面的音乐。很喜欢 EVA 的音乐。\n\n> 年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。\n\n## 书\n\n无论是技术类还是非技术类书籍，今年都没能很完整的去看完一本书。想了一下。非技术类书籍终究是被其他的一些娱乐方式占用或代替了。技术类书籍，则是被大部分看文档，看源码，看 YouTube 视频给代替了。从去年开始陆续看了很多 iOS 相关的技术内容。今年也算小有成效吧，在 iOS 项目的整体架构上有所认识和实践了。\n\n# 时刻\n\n### 离灯\n\n3 月份的时候，关注到了「离灯_冬眠mode关闭失败」，她发了一篇微博，那篇微博的内容开头是\n\n> 首先，对不起大家，刷到我这么一条让人不开心的微博，还要看我絮絮叨叨。\n\n看了她写的内容，心里很难过。有可能是某些状态我是能和她感同身受来着。\n\n## Clubhouse\n\n年初大火的 clubhouse，费了好大一番功夫才搞来了邀请码。年初的时候听了一阵子。当再次下载下来听，就是六七月份了，那个时候中文社区已经变得大不一样。我像是以前听播客那样，有段时间里很高频度的收听它。尽管我清楚有 80% 的内容是像「水茧房」一样，但仍然有一些，可能是只有通过 clubhouse 的这种形式才能够被表达出来。现在想想，自己也不过是在某个时间点希望听些东西，这个媒介，无论是播客，还是 clubhouse，似乎都不重要。因为我听 clubhouse，也是大部分时间在听，很少去发言。\n\n## 灰犀牛事件\n\n有关这些事情，端传媒最近的[一篇文章](https://theinitium.com/article/20211229-mainland-comprehensive-supervision/)梳理的更加全面。这么多如此密集的，大规模的事情，一桩接着一桩。也让 2021 年保持了一个很高的区分度。\n\n# 结语\n\n每次在这样的时间点，大家都会说「明年会更好」啊，「新年新气象」啊，这些内容。然而这些年，无论是大的氛围的变化，还是周遭的我的个人感知。都让我认为，过去的那一年，才是更好的一年。哪怕现在站在这里，回想这一年发生的许多事情，似乎是称不上好。但真要我用力迈过去，心中依然相信的是，过去的那一年，才是更好的一年。\n\n这一年告别了挺多人的。从年初到年尾。\n\n按照惯例，一些期许，希望新的 Zelda 续作，希望『弥留之国的爱丽丝』第二季内容，希望『巫师』『Red Dead Redemption』『GTA V』能够推出 PS5 版本。\n\n技术上还有很多未实现的愿景，需要一点一点提上日程了。\n\n🌻\n\n","source":"_posts/Fly-Me-to-the-Moon.md","raw":"---\ntitle: Fly Me to the Moon\ndate: 2021-12-31 09:47:59\ntags:\n- 电影\n- 游戏\n- 音乐\ncategories: 'I/O'\n---\n\n![zelda-botw](/images/zelda-botw.jpg)\n\n6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。\n\n但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，\n\n> 哎，又到了此刻。\n\n<!--more-->\n\n# 游戏\n\n- [女神异闻录5 皇家版](https://www.playstation.com/zh-hans-hk/games/persona-5-royal/) | PlayStation 5\n- [Metroid™ Dread](https://www.nintendo.com/games/detail/metroid-dread-switch/) | Nintendo Switch\n- [真・女神轉生V](http://asia.sega.com/megaten5/cht/) | Nintendo Switch\n\n*以上列表按照喜好顺序排名。*\n\n七夕节的那天收到 PS5，第一时间便入手了 P5R，从 8 月份到 9 月中旬，把自己所有的空闲时间都投入了进去。现代背景，荣格心理学，东京涩谷。日式 rpg 的框架下，种种设定让代入感过于强烈，以至于某些时刻，我仿佛真的回到了学生时代。挤地铁，上课，考试，看书，和一帮小伙伴嬉笑打闹。\n\n因为以前的学生时代，和现在真的有很大不同。经常一帮人一起玩某个游戏，一起打篮球。所以那天 p5r 一周目通关，想了一下，是时候约好友出来见一面聊聊天了。大家平日工作都很忙，虽然在同一个城市，但好久都没见面了。\n\n> 『女神异闻录』攻略到「回忆」部分结束，剧情的反转设计，和游戏交互上给人带来的沉浸感简直太棒了。几处伏笔并没有意识到，剧情上带来的合理性也让我没有太多思考，只是感到奇怪。使用的手法完全想不出来，太绝妙了。太久没有过这种「啊，竟然是这样，被骗了」这种感觉了。\n>\n> 完全没有想过黑衣人会是「认识的人」。倒叙的故事结构，因为药物而部分记忆丢失，通过只言片语的提示，让玩家和主角一起绞尽脑汁去回忆究竟是哪里出了问题，这样的设计，沉浸感和代入感太棒了。\n\n![p5r-ending](/images/p5r-ending.png)\n\nMetroidvania，一种游戏类型，中文翻译为「类银河战士恶魔城」，分别来自两款游戏，其一便是任天堂旗下的『密特罗德』，另一款是科樂美的『恶魔城』系列。之前玩过同类型的『奥日 1&2』，非常喜欢。对这一部也是期待了很久，也最终没有让我失望。20 多小时一周目通关，几个印象深刻的点是\n\n- 精巧的地图设计；\n- 超级复杂的按键；\n- 非常爽快的动作体验；\n- 破序玩法\n\n自己通关会去看了相关的速通视频，才知道原来这系列一直有着「破序玩法」的传统。\n\n![metroid](/images/metroid.png)\n\n因为玩过了 P5R，对于 ATLUS 这套神魔体系有所了解。比如「吉祥天」「爱丽丝」等等这些经典的形象。当本家新一作「真女神转生」发布的时候，很自然就第一时间入手了。初期的时候还是有很多不适应，直到我去买了 dlc，整个的游戏体验就好很多了。和外传不一样，本传的气质挺像『恶魔人Crybaby』的。大地图迷宫，战斗设计都非常精彩。唯一缺憾的可能还是 Switch 的机能。不时的卡顿，掉帧，和流畅，绚烂，不羁的 P5R 比起来，似乎还是差了一个时代。\n\n![shin-megami-tensei-v](/images/shin-megami-tensei-v.png)\n\n\n\n## 音乐\n\n- Can't Take My Eyes Off You - Joytastic Sarah\n- Another Day of Sun - La La Land Cast\n- Fly Me to the Moon - The Macarons Project\n- Happy Birthday ( Single Version Remix ) - Kyoko\n- On the Nature of Daylight - Max Richter\n\n[Replay 2021 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2021/pl.rp-6xxXTlPZDQL)\n\nJoytastic Sarah 算是一个惊喜，在 YouTube 上有她的[频道](https://www.youtube.com/c/JoytasticSarahCovers)，她的一些翻唱和混音真的非常好听。\n\n## 电影\n\n豆瓣记录里，今年总共看了 33 部电影。相比于去年的 13 部，提高了不少。有一些是周末的时候去到一个线下小众观影俱乐部看的。年初那会儿，有段时间每周末都过去。\n\n- 『金都』\n- 『无间道』三部曲\n- 『城市之光』\n- 『偶然与想象』\n- 『鱿鱼游戏』\n- 『新·福音战士剧场版：终』\n- 『弥留之国的爱丽丝』\n\n大部分的观影记录集中在了上半年。现在回想起来，看剧的时刻真的非常美妙。花上一下午或一个晚上，binge-watching 的去看整部剧。六七点钟时叫一家附近的披萨和冷饮。\n\n因为『鱿鱼游戏』，之后又去看了『弥留之国的爱丽丝』。\n\n16 年那会儿开始看 EVA，那个时候毕业，放假在家，一边学习德语，一边看剧，看电影。那段时间把 EVA 所有的 TV 剧集，旧剧场版，新剧场版的前三部都看完了。我至今都清楚得记得我当时看新剧场版『Q』的时刻，自己一个人坐在大大客厅沙发上，面对红的一片的屏幕。绫波丽缓缓的走来，明日香开始骂碇真嗣。镜头拉远，三个人就这样慢慢在空无一人红色大地上缓慢走着。\n\n![eva-1](/images/eva-1.png)\n\n![eva-2](/images/eva-2.png)\n\n![eva-3](/images/eva-3.png)\n\n![eva-4](/images/eva-4.png)\n\n即便是在等待了 5 年之后，看完了『新剧场版：终』。对于其他 EVA 粉丝，这个等待时间更久。在我心里，给我最大震撼和感动的还是来自『新剧场版：破』。在 16 年补完 EVA 的许多作品后，之后的很多时间，我都在循环听里面的音乐。很喜欢 EVA 的音乐。\n\n> 年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。\n\n## 书\n\n无论是技术类还是非技术类书籍，今年都没能很完整的去看完一本书。想了一下。非技术类书籍终究是被其他的一些娱乐方式占用或代替了。技术类书籍，则是被大部分看文档，看源码，看 YouTube 视频给代替了。从去年开始陆续看了很多 iOS 相关的技术内容。今年也算小有成效吧，在 iOS 项目的整体架构上有所认识和实践了。\n\n# 时刻\n\n### 离灯\n\n3 月份的时候，关注到了「离灯_冬眠mode关闭失败」，她发了一篇微博，那篇微博的内容开头是\n\n> 首先，对不起大家，刷到我这么一条让人不开心的微博，还要看我絮絮叨叨。\n\n看了她写的内容，心里很难过。有可能是某些状态我是能和她感同身受来着。\n\n## Clubhouse\n\n年初大火的 clubhouse，费了好大一番功夫才搞来了邀请码。年初的时候听了一阵子。当再次下载下来听，就是六七月份了，那个时候中文社区已经变得大不一样。我像是以前听播客那样，有段时间里很高频度的收听它。尽管我清楚有 80% 的内容是像「水茧房」一样，但仍然有一些，可能是只有通过 clubhouse 的这种形式才能够被表达出来。现在想想，自己也不过是在某个时间点希望听些东西，这个媒介，无论是播客，还是 clubhouse，似乎都不重要。因为我听 clubhouse，也是大部分时间在听，很少去发言。\n\n## 灰犀牛事件\n\n有关这些事情，端传媒最近的[一篇文章](https://theinitium.com/article/20211229-mainland-comprehensive-supervision/)梳理的更加全面。这么多如此密集的，大规模的事情，一桩接着一桩。也让 2021 年保持了一个很高的区分度。\n\n# 结语\n\n每次在这样的时间点，大家都会说「明年会更好」啊，「新年新气象」啊，这些内容。然而这些年，无论是大的氛围的变化，还是周遭的我的个人感知。都让我认为，过去的那一年，才是更好的一年。哪怕现在站在这里，回想这一年发生的许多事情，似乎是称不上好。但真要我用力迈过去，心中依然相信的是，过去的那一年，才是更好的一年。\n\n这一年告别了挺多人的。从年初到年尾。\n\n按照惯例，一些期许，希望新的 Zelda 续作，希望『弥留之国的爱丽丝』第二季内容，希望『巫师』『Red Dead Redemption』『GTA V』能够推出 PS5 版本。\n\n技术上还有很多未实现的愿景，需要一点一点提上日程了。\n\n🌻\n\n","slug":"Fly-Me-to-the-Moon","published":1,"updated":"2022-01-01T02:11:23.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx25000srg1v47uedlmz","content":"<p><img src=\"/images/zelda-botw.jpg\" alt=\"zelda-botw\"></p>\n<p>6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。</p>\n<p>但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，</p>\n<blockquote>\n<p>哎，又到了此刻。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h1><ul>\n<li><a href=\"https://www.playstation.com/zh-hans-hk/games/persona-5-royal/\">女神异闻录5 皇家版</a> | PlayStation 5</li>\n<li><a href=\"https://www.nintendo.com/games/detail/metroid-dread-switch/\">Metroid™ Dread</a> | Nintendo Switch</li>\n<li><a href=\"http://asia.sega.com/megaten5/cht/\">真・女神轉生V</a> | Nintendo Switch</li>\n</ul>\n<p><em>以上列表按照喜好顺序排名。</em></p>\n<p>七夕节的那天收到 PS5，第一时间便入手了 P5R，从 8 月份到 9 月中旬，把自己所有的空闲时间都投入了进去。现代背景，荣格心理学，东京涩谷。日式 rpg 的框架下，种种设定让代入感过于强烈，以至于某些时刻，我仿佛真的回到了学生时代。挤地铁，上课，考试，看书，和一帮小伙伴嬉笑打闹。</p>\n<p>因为以前的学生时代，和现在真的有很大不同。经常一帮人一起玩某个游戏，一起打篮球。所以那天 p5r 一周目通关，想了一下，是时候约好友出来见一面聊聊天了。大家平日工作都很忙，虽然在同一个城市，但好久都没见面了。</p>\n<blockquote>\n<p>『女神异闻录』攻略到「回忆」部分结束，剧情的反转设计，和游戏交互上给人带来的沉浸感简直太棒了。几处伏笔并没有意识到，剧情上带来的合理性也让我没有太多思考，只是感到奇怪。使用的手法完全想不出来，太绝妙了。太久没有过这种「啊，竟然是这样，被骗了」这种感觉了。</p>\n<p>完全没有想过黑衣人会是「认识的人」。倒叙的故事结构，因为药物而部分记忆丢失，通过只言片语的提示，让玩家和主角一起绞尽脑汁去回忆究竟是哪里出了问题，这样的设计，沉浸感和代入感太棒了。</p>\n</blockquote>\n<p><img src=\"/images/p5r-ending.png\" alt=\"p5r-ending\"></p>\n<p>Metroidvania，一种游戏类型，中文翻译为「类银河战士恶魔城」，分别来自两款游戏，其一便是任天堂旗下的『密特罗德』，另一款是科樂美的『恶魔城』系列。之前玩过同类型的『奥日 1&amp;2』，非常喜欢。对这一部也是期待了很久，也最终没有让我失望。20 多小时一周目通关，几个印象深刻的点是</p>\n<ul>\n<li>精巧的地图设计；</li>\n<li>超级复杂的按键；</li>\n<li>非常爽快的动作体验；</li>\n<li>破序玩法</li>\n</ul>\n<p>自己通关会去看了相关的速通视频，才知道原来这系列一直有着「破序玩法」的传统。</p>\n<p><img src=\"/images/metroid.png\" alt=\"metroid\"></p>\n<p>因为玩过了 P5R，对于 ATLUS 这套神魔体系有所了解。比如「吉祥天」「爱丽丝」等等这些经典的形象。当本家新一作「真女神转生」发布的时候，很自然就第一时间入手了。初期的时候还是有很多不适应，直到我去买了 dlc，整个的游戏体验就好很多了。和外传不一样，本传的气质挺像『恶魔人Crybaby』的。大地图迷宫，战斗设计都非常精彩。唯一缺憾的可能还是 Switch 的机能。不时的卡顿，掉帧，和流畅，绚烂，不羁的 P5R 比起来，似乎还是差了一个时代。</p>\n<p><img src=\"/images/shin-megami-tensei-v.png\" alt=\"shin-megami-tensei-v\"></p>\n<h2 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h2><ul>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>Another Day of Sun - La La Land Cast</li>\n<li>Fly Me to the Moon - The Macarons Project</li>\n<li>Happy Birthday ( Single Version Remix ) - Kyoko</li>\n<li>On the Nature of Daylight - Max Richter</li>\n</ul>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2021/pl.rp-6xxXTlPZDQL\">Replay 2021 - Apple Music for Reyshawn</a></p>\n<p>Joytastic Sarah 算是一个惊喜，在 YouTube 上有她的<a href=\"https://www.youtube.com/c/JoytasticSarahCovers\">频道</a>，她的一些翻唱和混音真的非常好听。</p>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><p>豆瓣记录里，今年总共看了 33 部电影。相比于去年的 13 部，提高了不少。有一些是周末的时候去到一个线下小众观影俱乐部看的。年初那会儿，有段时间每周末都过去。</p>\n<ul>\n<li>『金都』</li>\n<li>『无间道』三部曲</li>\n<li>『城市之光』</li>\n<li>『偶然与想象』</li>\n<li>『鱿鱼游戏』</li>\n<li>『新·福音战士剧场版：终』</li>\n<li>『弥留之国的爱丽丝』</li>\n</ul>\n<p>大部分的观影记录集中在了上半年。现在回想起来，看剧的时刻真的非常美妙。花上一下午或一个晚上，binge-watching 的去看整部剧。六七点钟时叫一家附近的披萨和冷饮。</p>\n<p>因为『鱿鱼游戏』，之后又去看了『弥留之国的爱丽丝』。</p>\n<p>16 年那会儿开始看 EVA，那个时候毕业，放假在家，一边学习德语，一边看剧，看电影。那段时间把 EVA 所有的 TV 剧集，旧剧场版，新剧场版的前三部都看完了。我至今都清楚得记得我当时看新剧场版『Q』的时刻，自己一个人坐在大大客厅沙发上，面对红的一片的屏幕。绫波丽缓缓的走来，明日香开始骂碇真嗣。镜头拉远，三个人就这样慢慢在空无一人红色大地上缓慢走着。</p>\n<p><img src=\"/images/eva-1.png\" alt=\"eva-1\"></p>\n<p><img src=\"/images/eva-2.png\" alt=\"eva-2\"></p>\n<p><img src=\"/images/eva-3.png\" alt=\"eva-3\"></p>\n<p><img src=\"/images/eva-4.png\" alt=\"eva-4\"></p>\n<p>即便是在等待了 5 年之后，看完了『新剧场版：终』。对于其他 EVA 粉丝，这个等待时间更久。在我心里，给我最大震撼和感动的还是来自『新剧场版：破』。在 16 年补完 EVA 的许多作品后，之后的很多时间，我都在循环听里面的音乐。很喜欢 EVA 的音乐。</p>\n<blockquote>\n<p>年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。</p>\n</blockquote>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><p>无论是技术类还是非技术类书籍，今年都没能很完整的去看完一本书。想了一下。非技术类书籍终究是被其他的一些娱乐方式占用或代替了。技术类书籍，则是被大部分看文档，看源码，看 YouTube 视频给代替了。从去年开始陆续看了很多 iOS 相关的技术内容。今年也算小有成效吧，在 iOS 项目的整体架构上有所认识和实践了。</p>\n<h1 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h1><h3 id=\"离灯\"><a href=\"#离灯\" class=\"headerlink\" title=\"离灯\"></a>离灯</h3><p>3 月份的时候，关注到了「离灯_冬眠mode关闭失败」，她发了一篇微博，那篇微博的内容开头是</p>\n<blockquote>\n<p>首先，对不起大家，刷到我这么一条让人不开心的微博，还要看我絮絮叨叨。</p>\n</blockquote>\n<p>看了她写的内容，心里很难过。有可能是某些状态我是能和她感同身受来着。</p>\n<h2 id=\"Clubhouse\"><a href=\"#Clubhouse\" class=\"headerlink\" title=\"Clubhouse\"></a>Clubhouse</h2><p>年初大火的 clubhouse，费了好大一番功夫才搞来了邀请码。年初的时候听了一阵子。当再次下载下来听，就是六七月份了，那个时候中文社区已经变得大不一样。我像是以前听播客那样，有段时间里很高频度的收听它。尽管我清楚有 80% 的内容是像「水茧房」一样，但仍然有一些，可能是只有通过 clubhouse 的这种形式才能够被表达出来。现在想想，自己也不过是在某个时间点希望听些东西，这个媒介，无论是播客，还是 clubhouse，似乎都不重要。因为我听 clubhouse，也是大部分时间在听，很少去发言。</p>\n<h2 id=\"灰犀牛事件\"><a href=\"#灰犀牛事件\" class=\"headerlink\" title=\"灰犀牛事件\"></a>灰犀牛事件</h2><p>有关这些事情，端传媒最近的<a href=\"https://theinitium.com/article/20211229-mainland-comprehensive-supervision/\">一篇文章</a>梳理的更加全面。这么多如此密集的，大规模的事情，一桩接着一桩。也让 2021 年保持了一个很高的区分度。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>每次在这样的时间点，大家都会说「明年会更好」啊，「新年新气象」啊，这些内容。然而这些年，无论是大的氛围的变化，还是周遭的我的个人感知。都让我认为，过去的那一年，才是更好的一年。哪怕现在站在这里，回想这一年发生的许多事情，似乎是称不上好。但真要我用力迈过去，心中依然相信的是，过去的那一年，才是更好的一年。</p>\n<p>这一年告别了挺多人的。从年初到年尾。</p>\n<p>按照惯例，一些期许，希望新的 Zelda 续作，希望『弥留之国的爱丽丝』第二季内容，希望『巫师』『Red Dead Redemption』『GTA V』能够推出 PS5 版本。</p>\n<p>技术上还有很多未实现的愿景，需要一点一点提上日程了。</p>\n<p>🌻</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/zelda-botw.jpg\" alt=\"zelda-botw\"></p>\n<p>6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。</p>\n<p>但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，</p>\n<blockquote>\n<p>哎，又到了此刻。</p>\n</blockquote>","more":"<h1 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h1><ul>\n<li><a href=\"https://www.playstation.com/zh-hans-hk/games/persona-5-royal/\">女神异闻录5 皇家版</a> | PlayStation 5</li>\n<li><a href=\"https://www.nintendo.com/games/detail/metroid-dread-switch/\">Metroid™ Dread</a> | Nintendo Switch</li>\n<li><a href=\"http://asia.sega.com/megaten5/cht/\">真・女神轉生V</a> | Nintendo Switch</li>\n</ul>\n<p><em>以上列表按照喜好顺序排名。</em></p>\n<p>七夕节的那天收到 PS5，第一时间便入手了 P5R，从 8 月份到 9 月中旬，把自己所有的空闲时间都投入了进去。现代背景，荣格心理学，东京涩谷。日式 rpg 的框架下，种种设定让代入感过于强烈，以至于某些时刻，我仿佛真的回到了学生时代。挤地铁，上课，考试，看书，和一帮小伙伴嬉笑打闹。</p>\n<p>因为以前的学生时代，和现在真的有很大不同。经常一帮人一起玩某个游戏，一起打篮球。所以那天 p5r 一周目通关，想了一下，是时候约好友出来见一面聊聊天了。大家平日工作都很忙，虽然在同一个城市，但好久都没见面了。</p>\n<blockquote>\n<p>『女神异闻录』攻略到「回忆」部分结束，剧情的反转设计，和游戏交互上给人带来的沉浸感简直太棒了。几处伏笔并没有意识到，剧情上带来的合理性也让我没有太多思考，只是感到奇怪。使用的手法完全想不出来，太绝妙了。太久没有过这种「啊，竟然是这样，被骗了」这种感觉了。</p>\n<p>完全没有想过黑衣人会是「认识的人」。倒叙的故事结构，因为药物而部分记忆丢失，通过只言片语的提示，让玩家和主角一起绞尽脑汁去回忆究竟是哪里出了问题，这样的设计，沉浸感和代入感太棒了。</p>\n</blockquote>\n<p><img src=\"/images/p5r-ending.png\" alt=\"p5r-ending\"></p>\n<p>Metroidvania，一种游戏类型，中文翻译为「类银河战士恶魔城」，分别来自两款游戏，其一便是任天堂旗下的『密特罗德』，另一款是科樂美的『恶魔城』系列。之前玩过同类型的『奥日 1&amp;2』，非常喜欢。对这一部也是期待了很久，也最终没有让我失望。20 多小时一周目通关，几个印象深刻的点是</p>\n<ul>\n<li>精巧的地图设计；</li>\n<li>超级复杂的按键；</li>\n<li>非常爽快的动作体验；</li>\n<li>破序玩法</li>\n</ul>\n<p>自己通关会去看了相关的速通视频，才知道原来这系列一直有着「破序玩法」的传统。</p>\n<p><img src=\"/images/metroid.png\" alt=\"metroid\"></p>\n<p>因为玩过了 P5R，对于 ATLUS 这套神魔体系有所了解。比如「吉祥天」「爱丽丝」等等这些经典的形象。当本家新一作「真女神转生」发布的时候，很自然就第一时间入手了。初期的时候还是有很多不适应，直到我去买了 dlc，整个的游戏体验就好很多了。和外传不一样，本传的气质挺像『恶魔人Crybaby』的。大地图迷宫，战斗设计都非常精彩。唯一缺憾的可能还是 Switch 的机能。不时的卡顿，掉帧，和流畅，绚烂，不羁的 P5R 比起来，似乎还是差了一个时代。</p>\n<p><img src=\"/images/shin-megami-tensei-v.png\" alt=\"shin-megami-tensei-v\"></p>\n<h2 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h2><ul>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>Another Day of Sun - La La Land Cast</li>\n<li>Fly Me to the Moon - The Macarons Project</li>\n<li>Happy Birthday ( Single Version Remix ) - Kyoko</li>\n<li>On the Nature of Daylight - Max Richter</li>\n</ul>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2021/pl.rp-6xxXTlPZDQL\">Replay 2021 - Apple Music for Reyshawn</a></p>\n<p>Joytastic Sarah 算是一个惊喜，在 YouTube 上有她的<a href=\"https://www.youtube.com/c/JoytasticSarahCovers\">频道</a>，她的一些翻唱和混音真的非常好听。</p>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><p>豆瓣记录里，今年总共看了 33 部电影。相比于去年的 13 部，提高了不少。有一些是周末的时候去到一个线下小众观影俱乐部看的。年初那会儿，有段时间每周末都过去。</p>\n<ul>\n<li>『金都』</li>\n<li>『无间道』三部曲</li>\n<li>『城市之光』</li>\n<li>『偶然与想象』</li>\n<li>『鱿鱼游戏』</li>\n<li>『新·福音战士剧场版：终』</li>\n<li>『弥留之国的爱丽丝』</li>\n</ul>\n<p>大部分的观影记录集中在了上半年。现在回想起来，看剧的时刻真的非常美妙。花上一下午或一个晚上，binge-watching 的去看整部剧。六七点钟时叫一家附近的披萨和冷饮。</p>\n<p>因为『鱿鱼游戏』，之后又去看了『弥留之国的爱丽丝』。</p>\n<p>16 年那会儿开始看 EVA，那个时候毕业，放假在家，一边学习德语，一边看剧，看电影。那段时间把 EVA 所有的 TV 剧集，旧剧场版，新剧场版的前三部都看完了。我至今都清楚得记得我当时看新剧场版『Q』的时刻，自己一个人坐在大大客厅沙发上，面对红的一片的屏幕。绫波丽缓缓的走来，明日香开始骂碇真嗣。镜头拉远，三个人就这样慢慢在空无一人红色大地上缓慢走着。</p>\n<p><img src=\"/images/eva-1.png\" alt=\"eva-1\"></p>\n<p><img src=\"/images/eva-2.png\" alt=\"eva-2\"></p>\n<p><img src=\"/images/eva-3.png\" alt=\"eva-3\"></p>\n<p><img src=\"/images/eva-4.png\" alt=\"eva-4\"></p>\n<p>即便是在等待了 5 年之后，看完了『新剧场版：终』。对于其他 EVA 粉丝，这个等待时间更久。在我心里，给我最大震撼和感动的还是来自『新剧场版：破』。在 16 年补完 EVA 的许多作品后，之后的很多时间，我都在循环听里面的音乐。很喜欢 EVA 的音乐。</p>\n<blockquote>\n<p>年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。</p>\n</blockquote>\n<h2 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h2><p>无论是技术类还是非技术类书籍，今年都没能很完整的去看完一本书。想了一下。非技术类书籍终究是被其他的一些娱乐方式占用或代替了。技术类书籍，则是被大部分看文档，看源码，看 YouTube 视频给代替了。从去年开始陆续看了很多 iOS 相关的技术内容。今年也算小有成效吧，在 iOS 项目的整体架构上有所认识和实践了。</p>\n<h1 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h1><h3 id=\"离灯\"><a href=\"#离灯\" class=\"headerlink\" title=\"离灯\"></a>离灯</h3><p>3 月份的时候，关注到了「离灯_冬眠mode关闭失败」，她发了一篇微博，那篇微博的内容开头是</p>\n<blockquote>\n<p>首先，对不起大家，刷到我这么一条让人不开心的微博，还要看我絮絮叨叨。</p>\n</blockquote>\n<p>看了她写的内容，心里很难过。有可能是某些状态我是能和她感同身受来着。</p>\n<h2 id=\"Clubhouse\"><a href=\"#Clubhouse\" class=\"headerlink\" title=\"Clubhouse\"></a>Clubhouse</h2><p>年初大火的 clubhouse，费了好大一番功夫才搞来了邀请码。年初的时候听了一阵子。当再次下载下来听，就是六七月份了，那个时候中文社区已经变得大不一样。我像是以前听播客那样，有段时间里很高频度的收听它。尽管我清楚有 80% 的内容是像「水茧房」一样，但仍然有一些，可能是只有通过 clubhouse 的这种形式才能够被表达出来。现在想想，自己也不过是在某个时间点希望听些东西，这个媒介，无论是播客，还是 clubhouse，似乎都不重要。因为我听 clubhouse，也是大部分时间在听，很少去发言。</p>\n<h2 id=\"灰犀牛事件\"><a href=\"#灰犀牛事件\" class=\"headerlink\" title=\"灰犀牛事件\"></a>灰犀牛事件</h2><p>有关这些事情，端传媒最近的<a href=\"https://theinitium.com/article/20211229-mainland-comprehensive-supervision/\">一篇文章</a>梳理的更加全面。这么多如此密集的，大规模的事情，一桩接着一桩。也让 2021 年保持了一个很高的区分度。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>每次在这样的时间点，大家都会说「明年会更好」啊，「新年新气象」啊，这些内容。然而这些年，无论是大的氛围的变化，还是周遭的我的个人感知。都让我认为，过去的那一年，才是更好的一年。哪怕现在站在这里，回想这一年发生的许多事情，似乎是称不上好。但真要我用力迈过去，心中依然相信的是，过去的那一年，才是更好的一年。</p>\n<p>这一年告别了挺多人的。从年初到年尾。</p>\n<p>按照惯例，一些期许，希望新的 Zelda 续作，希望『弥留之国的爱丽丝』第二季内容，希望『巫师』『Red Dead Redemption』『GTA V』能够推出 PS5 版本。</p>\n<p>技术上还有很多未实现的愿景，需要一点一点提上日程了。</p>\n<p>🌻</p>"},{"title":"Hexo 部署到新电脑","date":"2017-11-02T14:53:17.000Z","_content":"换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 `hexo d` 部署， 都会把所有源文件都部署到 `master` 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 `master` 分支下的。\n\n<!-- more -->\n\n在网上找了很多解决方案，最终认为还是 cache 出了问题。但只是去 `hexo clean` 并不起效。\n\n解决办法：\n\n首先是检查，github.io 仓库下默认分支是哪个，这里要把默认分支改成存储源文件的那个分支。在我的仓库下就是把默认分支改成 「hexo」。\n\n再者，就是 `hexo clean`，然后把目录下的 `.deploy_git` 删掉。然后再重新进行 `hexo generate` 和 `hexo deploy`。成功！\n","source":"_posts/Hexo部署到新电脑.md","raw":"---\ntitle: 'Hexo 部署到新电脑'\ndate: 2017-11-02 22:53:17\ntags:\ncategories:\n---\n换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 `hexo d` 部署， 都会把所有源文件都部署到 `master` 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 `master` 分支下的。\n\n<!-- more -->\n\n在网上找了很多解决方案，最终认为还是 cache 出了问题。但只是去 `hexo clean` 并不起效。\n\n解决办法：\n\n首先是检查，github.io 仓库下默认分支是哪个，这里要把默认分支改成存储源文件的那个分支。在我的仓库下就是把默认分支改成 「hexo」。\n\n再者，就是 `hexo clean`，然后把目录下的 `.deploy_git` 删掉。然后再重新进行 `hexo generate` 和 `hexo deploy`。成功！\n","slug":"Hexo部署到新电脑","published":1,"updated":"2019-01-18T14:43:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx25000vrg1vee30dbqs","content":"<p>换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 <code>hexo d</code> 部署， 都会把所有源文件都部署到 <code>master</code> 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 <code>master</code> 分支下的。</p>\n<span id=\"more\"></span>\n\n<p>在网上找了很多解决方案，最终认为还是 cache 出了问题。但只是去 <code>hexo clean</code> 并不起效。</p>\n<p>解决办法：</p>\n<p>首先是检查，github.io 仓库下默认分支是哪个，这里要把默认分支改成存储源文件的那个分支。在我的仓库下就是把默认分支改成 「hexo」。</p>\n<p>再者，就是 <code>hexo clean</code>，然后把目录下的 <code>.deploy_git</code> 删掉。然后再重新进行 <code>hexo generate</code> 和 <code>hexo deploy</code>。成功！</p>\n","site":{"data":{}},"excerpt":"<p>换了新的电脑，想把在 hexo 上的部署文件转移到新电脑上。因为提前在 github 为此做了一些工作，就是按照网上一些朋友的建议，在 github 上创建两个分支，一个分支 「master」 用于 hexo 部署，另一个分支「hexo」用于存储源文件。这样当需要在一台新电脑上使用 hexo 时，只需要把源文件 clone 到本地就行了。但事情总不是一帆风顺😅。今天遇到的问题是，把源文件拉到本地以后，每次执行 <code>hexo d</code> 部署， 都会把所有源文件都部署到 <code>master</code> 分支上。按照常理，应该是只有 public 文件夹里的内容才会放在 <code>master</code> 分支下的。</p>","more":"<p>在网上找了很多解决方案，最终认为还是 cache 出了问题。但只是去 <code>hexo clean</code> 并不起效。</p>\n<p>解决办法：</p>\n<p>首先是检查，github.io 仓库下默认分支是哪个，这里要把默认分支改成存储源文件的那个分支。在我的仓库下就是把默认分支改成 「hexo」。</p>\n<p>再者，就是 <code>hexo clean</code>，然后把目录下的 <code>.deploy_git</code> 删掉。然后再重新进行 <code>hexo generate</code> 和 <code>hexo deploy</code>。成功！</p>"},{"title":"名为丢失的记忆","date":"2016-09-12T01:59:19.000Z","_content":"\n\n\n* [『カイバ』](https://www.wikiwand.com/en/Kaiba)\n* 如何在 AI 中加入人的思考和情感？\n\n『カイバ』(读作：Kaiba)可能会是一部我目前看过的汤浅的所有作品中，最喜欢的一部，喜欢的程度已经超过了『ケモノヅメ』(读作：Kemonozume)。在之前我的另一个系列文章[「间隔年日记 #008: 人体机器」](https://app.yinxiang.com/shard/s6/nl/1479304/bfbcd12c-218a-4d89-b76d-77aee6d8d9ad)中，我曾经得到了这样的结论：\n<!-- more -->\n>小時候，也有過像蘇菲那樣思考「我是誰？」這樣終極的哲學命題。前幾日我似乎終於找到了答案。當我在問「我是誰？」時，我其實是想知道我的意識從何而來，爲什麼我是屬於這具軀體而不是屬於另外一具軀體。我最後得以確定，所有關於「人」意識的問題都要回歸于記憶，有了記憶才有線性時間的概念，進而在線性時間上衍生出事件，以及出現因果概念，因果概念加上線性時間上的事件，就是更加抽象的思考。\n\n在『カイバ』中，作者和我这一想法不谋而合，并且通过将记忆进行实体化，可移植，可贩卖，由此引申一个庞大的世界设定。在这个世界里，因为记忆可以移植，肉体不再具有意义。有钱人将记忆不断载入健康的身体，用掉的身体则丢掉回收，以此达到永生的目的。穷人迫不得已通过贩卖自己的身体来度日维生，有时甚至要贩卖自己学过的知识。删除痛苦的记忆，下载快乐的记忆。这些看似超现实下的科幻描写，其实也在当下不断发生。你还记得你上次做爱是什么时候吗？上一次自慰是什么时候？上次和女友/男友争吵是什么原因？这些不愉快的记忆早已经忘的一干二净。但是，是不是能清晰的记得，高考后的那天晚上做了什么，还记得大四最后毕业那些天，一起爬山，在山上看看星星的情景。高兴的，快乐的记忆被我们一遍又一遍想起，在脑中的那段脑回路，被一遍遍的补给营养得到加强。而那些痛苦的，伤心的，羞耻的，不堪的记忆，我们希望它消失，希望它从来没有发生过，希望脑中那段回路消失，消失，消失。我们愿意记起那些快乐的回忆，希望忘掉不好的事情。\n\n>海马体，Hippocampus，是组成大脑边缘系统的一部分，位于大脑皮质下方，担当着关于短期记忆，长期记忆和空间定位的作用。\n\n在电影『Who Am I - Kein System ist sicher』中，导演试图告诉我们，我们更愿意相信我们眼中看到的事情。在本文的主题下，可以解读为，我们更愿意相信我们自己的记忆。但有时候记忆会撒谎，记忆也会被篡改，记忆会像『Memento』里 Leonard 那样，会被打破成碎片。而与之相对的，事实就是事实，是客观存在发生过的事。记忆是事实的一面镜子，有时候能照出事实，有时候只能照出一部分，有时候甚至会导向与事实相反的方向。我有时候会很洁癖，手机的屏幕，电脑的屏幕，平板的屏幕擦了又擦，擦的跟新的一样。但无论怎么擦，也擦不掉我已经使用了三年零六个月的事实了。在做了坏事之后，希望忘掉不愉快，一切从新开始。这大概是我以后需要更正的态度，那就是，我不应该刻意忘掉那些给我带来伤痛的回忆，所有的一切，无论好的，坏的，都实实在在的曾经发生在我身上。我想要采取的态度是，希望自己的记忆能最大程度的还原现实，还原真实。\n\n如何让一个机器人更像人，如何引入人的思考和人的情感？我想了下，只需要加入和海马体类似的存储机制。之前还在思考，为了情感的需要，是不是需要性欲。想了想，情感和性欲终究是两件不同的事情，性欲是生殖的需求，而情感，是由于在一起时间久了以后所产生的依恋，羁绊。这种依恋，羁绊自是由时间产生，也是由记忆产生。","source":"_posts/I-O-18-名为丢失的记忆.md","raw":"---\ntitle: '名为丢失的记忆'\ndate: 2016-09-12 09:59:19\ntags:\n- 电影\n- Anime\ncategories: \"I/O\"\n---\n\n\n\n* [『カイバ』](https://www.wikiwand.com/en/Kaiba)\n* 如何在 AI 中加入人的思考和情感？\n\n『カイバ』(读作：Kaiba)可能会是一部我目前看过的汤浅的所有作品中，最喜欢的一部，喜欢的程度已经超过了『ケモノヅメ』(读作：Kemonozume)。在之前我的另一个系列文章[「间隔年日记 #008: 人体机器」](https://app.yinxiang.com/shard/s6/nl/1479304/bfbcd12c-218a-4d89-b76d-77aee6d8d9ad)中，我曾经得到了这样的结论：\n<!-- more -->\n>小時候，也有過像蘇菲那樣思考「我是誰？」這樣終極的哲學命題。前幾日我似乎終於找到了答案。當我在問「我是誰？」時，我其實是想知道我的意識從何而來，爲什麼我是屬於這具軀體而不是屬於另外一具軀體。我最後得以確定，所有關於「人」意識的問題都要回歸于記憶，有了記憶才有線性時間的概念，進而在線性時間上衍生出事件，以及出現因果概念，因果概念加上線性時間上的事件，就是更加抽象的思考。\n\n在『カイバ』中，作者和我这一想法不谋而合，并且通过将记忆进行实体化，可移植，可贩卖，由此引申一个庞大的世界设定。在这个世界里，因为记忆可以移植，肉体不再具有意义。有钱人将记忆不断载入健康的身体，用掉的身体则丢掉回收，以此达到永生的目的。穷人迫不得已通过贩卖自己的身体来度日维生，有时甚至要贩卖自己学过的知识。删除痛苦的记忆，下载快乐的记忆。这些看似超现实下的科幻描写，其实也在当下不断发生。你还记得你上次做爱是什么时候吗？上一次自慰是什么时候？上次和女友/男友争吵是什么原因？这些不愉快的记忆早已经忘的一干二净。但是，是不是能清晰的记得，高考后的那天晚上做了什么，还记得大四最后毕业那些天，一起爬山，在山上看看星星的情景。高兴的，快乐的记忆被我们一遍又一遍想起，在脑中的那段脑回路，被一遍遍的补给营养得到加强。而那些痛苦的，伤心的，羞耻的，不堪的记忆，我们希望它消失，希望它从来没有发生过，希望脑中那段回路消失，消失，消失。我们愿意记起那些快乐的回忆，希望忘掉不好的事情。\n\n>海马体，Hippocampus，是组成大脑边缘系统的一部分，位于大脑皮质下方，担当着关于短期记忆，长期记忆和空间定位的作用。\n\n在电影『Who Am I - Kein System ist sicher』中，导演试图告诉我们，我们更愿意相信我们眼中看到的事情。在本文的主题下，可以解读为，我们更愿意相信我们自己的记忆。但有时候记忆会撒谎，记忆也会被篡改，记忆会像『Memento』里 Leonard 那样，会被打破成碎片。而与之相对的，事实就是事实，是客观存在发生过的事。记忆是事实的一面镜子，有时候能照出事实，有时候只能照出一部分，有时候甚至会导向与事实相反的方向。我有时候会很洁癖，手机的屏幕，电脑的屏幕，平板的屏幕擦了又擦，擦的跟新的一样。但无论怎么擦，也擦不掉我已经使用了三年零六个月的事实了。在做了坏事之后，希望忘掉不愉快，一切从新开始。这大概是我以后需要更正的态度，那就是，我不应该刻意忘掉那些给我带来伤痛的回忆，所有的一切，无论好的，坏的，都实实在在的曾经发生在我身上。我想要采取的态度是，希望自己的记忆能最大程度的还原现实，还原真实。\n\n如何让一个机器人更像人，如何引入人的思考和人的情感？我想了下，只需要加入和海马体类似的存储机制。之前还在思考，为了情感的需要，是不是需要性欲。想了想，情感和性欲终究是两件不同的事情，性欲是生殖的需求，而情感，是由于在一起时间久了以后所产生的依恋，羁绊。这种依恋，羁绊自是由时间产生，也是由记忆产生。","slug":"I-O-18-名为丢失的记忆","published":1,"updated":"2019-01-20T09:35:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx25000xrg1v3v7beeyq","content":"<ul>\n<li><a href=\"https://www.wikiwand.com/en/Kaiba\">『カイバ』</a></li>\n<li>如何在 AI 中加入人的思考和情感？</li>\n</ul>\n<p>『カイバ』(读作：Kaiba)可能会是一部我目前看过的汤浅的所有作品中，最喜欢的一部，喜欢的程度已经超过了『ケモノヅメ』(读作：Kemonozume)。在之前我的另一个系列文章<a href=\"https://app.yinxiang.com/shard/s6/nl/1479304/bfbcd12c-218a-4d89-b76d-77aee6d8d9ad\">「间隔年日记 #008: 人体机器」</a>中，我曾经得到了这样的结论：</p>\n<span id=\"more\"></span>\n<blockquote>\n<p>小時候，也有過像蘇菲那樣思考「我是誰？」這樣終極的哲學命題。前幾日我似乎終於找到了答案。當我在問「我是誰？」時，我其實是想知道我的意識從何而來，爲什麼我是屬於這具軀體而不是屬於另外一具軀體。我最後得以確定，所有關於「人」意識的問題都要回歸于記憶，有了記憶才有線性時間的概念，進而在線性時間上衍生出事件，以及出現因果概念，因果概念加上線性時間上的事件，就是更加抽象的思考。</p>\n</blockquote>\n<p>在『カイバ』中，作者和我这一想法不谋而合，并且通过将记忆进行实体化，可移植，可贩卖，由此引申一个庞大的世界设定。在这个世界里，因为记忆可以移植，肉体不再具有意义。有钱人将记忆不断载入健康的身体，用掉的身体则丢掉回收，以此达到永生的目的。穷人迫不得已通过贩卖自己的身体来度日维生，有时甚至要贩卖自己学过的知识。删除痛苦的记忆，下载快乐的记忆。这些看似超现实下的科幻描写，其实也在当下不断发生。你还记得你上次做爱是什么时候吗？上一次自慰是什么时候？上次和女友/男友争吵是什么原因？这些不愉快的记忆早已经忘的一干二净。但是，是不是能清晰的记得，高考后的那天晚上做了什么，还记得大四最后毕业那些天，一起爬山，在山上看看星星的情景。高兴的，快乐的记忆被我们一遍又一遍想起，在脑中的那段脑回路，被一遍遍的补给营养得到加强。而那些痛苦的，伤心的，羞耻的，不堪的记忆，我们希望它消失，希望它从来没有发生过，希望脑中那段回路消失，消失，消失。我们愿意记起那些快乐的回忆，希望忘掉不好的事情。</p>\n<blockquote>\n<p>海马体，Hippocampus，是组成大脑边缘系统的一部分，位于大脑皮质下方，担当着关于短期记忆，长期记忆和空间定位的作用。</p>\n</blockquote>\n<p>在电影『Who Am I - Kein System ist sicher』中，导演试图告诉我们，我们更愿意相信我们眼中看到的事情。在本文的主题下，可以解读为，我们更愿意相信我们自己的记忆。但有时候记忆会撒谎，记忆也会被篡改，记忆会像『Memento』里 Leonard 那样，会被打破成碎片。而与之相对的，事实就是事实，是客观存在发生过的事。记忆是事实的一面镜子，有时候能照出事实，有时候只能照出一部分，有时候甚至会导向与事实相反的方向。我有时候会很洁癖，手机的屏幕，电脑的屏幕，平板的屏幕擦了又擦，擦的跟新的一样。但无论怎么擦，也擦不掉我已经使用了三年零六个月的事实了。在做了坏事之后，希望忘掉不愉快，一切从新开始。这大概是我以后需要更正的态度，那就是，我不应该刻意忘掉那些给我带来伤痛的回忆，所有的一切，无论好的，坏的，都实实在在的曾经发生在我身上。我想要采取的态度是，希望自己的记忆能最大程度的还原现实，还原真实。</p>\n<p>如何让一个机器人更像人，如何引入人的思考和人的情感？我想了下，只需要加入和海马体类似的存储机制。之前还在思考，为了情感的需要，是不是需要性欲。想了想，情感和性欲终究是两件不同的事情，性欲是生殖的需求，而情感，是由于在一起时间久了以后所产生的依恋，羁绊。这种依恋，羁绊自是由时间产生，也是由记忆产生。</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li><a href=\"https://www.wikiwand.com/en/Kaiba\">『カイバ』</a></li>\n<li>如何在 AI 中加入人的思考和情感？</li>\n</ul>\n<p>『カイバ』(读作：Kaiba)可能会是一部我目前看过的汤浅的所有作品中，最喜欢的一部，喜欢的程度已经超过了『ケモノヅメ』(读作：Kemonozume)。在之前我的另一个系列文章<a href=\"https://app.yinxiang.com/shard/s6/nl/1479304/bfbcd12c-218a-4d89-b76d-77aee6d8d9ad\">「间隔年日记 #008: 人体机器」</a>中，我曾经得到了这样的结论：</p>","more":"<blockquote>\n<p>小時候，也有過像蘇菲那樣思考「我是誰？」這樣終極的哲學命題。前幾日我似乎終於找到了答案。當我在問「我是誰？」時，我其實是想知道我的意識從何而來，爲什麼我是屬於這具軀體而不是屬於另外一具軀體。我最後得以確定，所有關於「人」意識的問題都要回歸于記憶，有了記憶才有線性時間的概念，進而在線性時間上衍生出事件，以及出現因果概念，因果概念加上線性時間上的事件，就是更加抽象的思考。</p>\n</blockquote>\n<p>在『カイバ』中，作者和我这一想法不谋而合，并且通过将记忆进行实体化，可移植，可贩卖，由此引申一个庞大的世界设定。在这个世界里，因为记忆可以移植，肉体不再具有意义。有钱人将记忆不断载入健康的身体，用掉的身体则丢掉回收，以此达到永生的目的。穷人迫不得已通过贩卖自己的身体来度日维生，有时甚至要贩卖自己学过的知识。删除痛苦的记忆，下载快乐的记忆。这些看似超现实下的科幻描写，其实也在当下不断发生。你还记得你上次做爱是什么时候吗？上一次自慰是什么时候？上次和女友/男友争吵是什么原因？这些不愉快的记忆早已经忘的一干二净。但是，是不是能清晰的记得，高考后的那天晚上做了什么，还记得大四最后毕业那些天，一起爬山，在山上看看星星的情景。高兴的，快乐的记忆被我们一遍又一遍想起，在脑中的那段脑回路，被一遍遍的补给营养得到加强。而那些痛苦的，伤心的，羞耻的，不堪的记忆，我们希望它消失，希望它从来没有发生过，希望脑中那段回路消失，消失，消失。我们愿意记起那些快乐的回忆，希望忘掉不好的事情。</p>\n<blockquote>\n<p>海马体，Hippocampus，是组成大脑边缘系统的一部分，位于大脑皮质下方，担当着关于短期记忆，长期记忆和空间定位的作用。</p>\n</blockquote>\n<p>在电影『Who Am I - Kein System ist sicher』中，导演试图告诉我们，我们更愿意相信我们眼中看到的事情。在本文的主题下，可以解读为，我们更愿意相信我们自己的记忆。但有时候记忆会撒谎，记忆也会被篡改，记忆会像『Memento』里 Leonard 那样，会被打破成碎片。而与之相对的，事实就是事实，是客观存在发生过的事。记忆是事实的一面镜子，有时候能照出事实，有时候只能照出一部分，有时候甚至会导向与事实相反的方向。我有时候会很洁癖，手机的屏幕，电脑的屏幕，平板的屏幕擦了又擦，擦的跟新的一样。但无论怎么擦，也擦不掉我已经使用了三年零六个月的事实了。在做了坏事之后，希望忘掉不愉快，一切从新开始。这大概是我以后需要更正的态度，那就是，我不应该刻意忘掉那些给我带来伤痛的回忆，所有的一切，无论好的，坏的，都实实在在的曾经发生在我身上。我想要采取的态度是，希望自己的记忆能最大程度的还原现实，还原真实。</p>\n<p>如何让一个机器人更像人，如何引入人的思考和人的情感？我想了下，只需要加入和海马体类似的存储机制。之前还在思考，为了情感的需要，是不是需要性欲。想了想，情感和性欲终究是两件不同的事情，性欲是生殖的需求，而情感，是由于在一起时间久了以后所产生的依恋，羁绊。这种依恋，羁绊自是由时间产生，也是由记忆产生。</p>"},{"title":"Samorost 的银河历险记","date":"2016-12-17T08:31:48.000Z","_content":"\n\n\n「Samorost」是来自捷克开发者团队  Amanita Design 的作品，中文译名「星际历险记」，如果之前有玩过他们的作品比如「Machinarium」，便能提前对他们的作品风格有所预设。「Samorost」和前作「Machinarium」风格相似，都是相同的鼠标点触操作模式，内含大量构思巧妙的关卡，人物沟通采用了会话气泡加动画的形式，暗藏的手绘攻略，以及故事核心都是一个子供向的童话。\n\n**以下涉及剧透**\n<!-- more -->\n\n「Samorost」的主人公是一个拿着小喇叭的 Gnome，小喇叭在游戏中是非常重要的道具，所以许多的关卡都是和音乐有关的。如果有过基本的音乐训练，我想通过这些关卡可能会更加有趣。像我这样没有接受过乐理训练的人，在很多地方，背景音乐给的提示察觉不到，或者是察觉到了，但没办法将音乐转化为谱，转化为符号，分不清各个音阶大小，所以最后只能考暗藏的提示和网上给出的攻略来解密，这自然也损失了不少乐趣。\n\n如果说前作「「Machinarium」」讲述的是一个英雄救美的故事，那么「Samorost」则是典型的太空探险故事，通过探险过程中的蛛丝马迹，发现了宇宙面临着巨大危机，而最后也是「英雄参上」，手擎宝剑，打败恶魔。Amanita Design 世界里的人物交流就像「三体」\n星人一样，不需要文字，而是脑电波的直接传达。「Samorost」在前作的基础上，通过小喇叭，引入和「物」交流的概念，这里的「物」包含了动物，植物，昆虫，还有那些没有生命的星球，石头，门，雕刻图腾的柱子。它们时而讲述它们前世的遭遇，时而对当前的关卡给出提示，时而发出窸窣的声音。\n\n正如电影中的旁白通常会被认为是最低级的叙事方式，游戏中的通篇文字，也会被认为叙事能力低级。电影的叙事是通过电影语言进行的，电影语言就是通过镜头，对白，剪辑，音乐来叙事。游戏则在电影的层面上是又高了一个维度，这个维度就是交互。游戏中经常出现的小电影，过场动画，使用的其实就是电影语言的叙事方法。而游戏超越电影的一面，则在于如何使用「交互」来进行叙事。在传统的 RPG （Role-playing game）中，人物通过对话引导，进入事先设计好的剧情点，引发剧情。因为「Samorost」似乎是完全丢掉了文字表达这一手段。所以用除文字之外的媒介来讲好这个故事，就显得非常高明。这其中包括历险中开始，主人公使用天文望远镜观察外太空，冒险的中段捡到了第二本故事书（漫画书），故事从这里出现反转，以及在冒险过程中逐渐明白了用小喇叭听声音的意义，就是去听那些有生命的物，无生命的物的倾诉。通过不断的倾听，故事也渐渐清晰起来，之前支离的线索开始慢慢能拼凑成一幅画，可以依稀辨认个中模样了。我想，「Samorost」带给我最大的乐趣，就是透过各种各样的符号，提示来进行解谜。还有就是最后把所有线索串起来的时候，那种恍然大悟的感觉。\n\n![地下洞穴](http://samorost3.net/img/big/samorost-3-red-cave.jpg)\n\n![巨大昆虫](http://samorost3.net/img/big/samorost-3-newts.jpg)\n\n\n最后说一下游戏中几个，我个人到目前还有所回味的点。一个是第一次在自己家楼顶，使用天文望远镜望星星，当时不禁就想到了『三体』里的三体星的瞭望员，那位整日都在百无聊赖的看星星，然后某一天收到的来自地球的叶文洁的消息，最后回信警告「不要回答！不要回答！不要回答！」。第二个是自己驾驶飞船来到一个白色的星球上，星球上有一颗枯树，倾听它的声音，它告诉我们，它是如何被一个有着三个头的机械怪物烧掉，吃掉灵魂，变成如今这般模样的。而在下一个星球，也终于找到了故事的下册，也终于明白了三头机械怪物的来历。第三个是游戏蕴含的所有音乐，和音乐相关的关卡。在小黑人所在的那个星球上，调了很多遍才终于让四个小黑人同样节奏的唱起歌来，那一刻，整个情绪都起来了。当然，还有巨大的虫子，麦草，乌龟，花朵，果实，僧侣等等，这些意象在一起，共同编织一个「小王子」般的童话故事。\n\n最后，维基百科里写出了开发者创作游戏时参考的一些电影，但都是捷克导演的作品，自己本身对捷克电影不太了解。这里列出的两部，可以看到和游戏有明显的相关性。\n\n相关电影\n* [Vynález zkázy ( The Fabulous World of Jules Verne ) - Karel Zeman](https://movie.douban.com/subject/1940670/?from=subject-page)\n* [Hedgehog in the Fog](https://www.wikiwand.com/en/Hedgehog_in_the_Fog)","source":"_posts/I-O-19-Samorost-的银河历险记.md","raw":"---\ntitle: 'Samorost 的银河历险记'\ndate: 2016-12-17 16:31:48\ntags: \n- 游戏\n- 故事\ncategories: \"I/O\"\n---\n\n\n\n「Samorost」是来自捷克开发者团队  Amanita Design 的作品，中文译名「星际历险记」，如果之前有玩过他们的作品比如「Machinarium」，便能提前对他们的作品风格有所预设。「Samorost」和前作「Machinarium」风格相似，都是相同的鼠标点触操作模式，内含大量构思巧妙的关卡，人物沟通采用了会话气泡加动画的形式，暗藏的手绘攻略，以及故事核心都是一个子供向的童话。\n\n**以下涉及剧透**\n<!-- more -->\n\n「Samorost」的主人公是一个拿着小喇叭的 Gnome，小喇叭在游戏中是非常重要的道具，所以许多的关卡都是和音乐有关的。如果有过基本的音乐训练，我想通过这些关卡可能会更加有趣。像我这样没有接受过乐理训练的人，在很多地方，背景音乐给的提示察觉不到，或者是察觉到了，但没办法将音乐转化为谱，转化为符号，分不清各个音阶大小，所以最后只能考暗藏的提示和网上给出的攻略来解密，这自然也损失了不少乐趣。\n\n如果说前作「「Machinarium」」讲述的是一个英雄救美的故事，那么「Samorost」则是典型的太空探险故事，通过探险过程中的蛛丝马迹，发现了宇宙面临着巨大危机，而最后也是「英雄参上」，手擎宝剑，打败恶魔。Amanita Design 世界里的人物交流就像「三体」\n星人一样，不需要文字，而是脑电波的直接传达。「Samorost」在前作的基础上，通过小喇叭，引入和「物」交流的概念，这里的「物」包含了动物，植物，昆虫，还有那些没有生命的星球，石头，门，雕刻图腾的柱子。它们时而讲述它们前世的遭遇，时而对当前的关卡给出提示，时而发出窸窣的声音。\n\n正如电影中的旁白通常会被认为是最低级的叙事方式，游戏中的通篇文字，也会被认为叙事能力低级。电影的叙事是通过电影语言进行的，电影语言就是通过镜头，对白，剪辑，音乐来叙事。游戏则在电影的层面上是又高了一个维度，这个维度就是交互。游戏中经常出现的小电影，过场动画，使用的其实就是电影语言的叙事方法。而游戏超越电影的一面，则在于如何使用「交互」来进行叙事。在传统的 RPG （Role-playing game）中，人物通过对话引导，进入事先设计好的剧情点，引发剧情。因为「Samorost」似乎是完全丢掉了文字表达这一手段。所以用除文字之外的媒介来讲好这个故事，就显得非常高明。这其中包括历险中开始，主人公使用天文望远镜观察外太空，冒险的中段捡到了第二本故事书（漫画书），故事从这里出现反转，以及在冒险过程中逐渐明白了用小喇叭听声音的意义，就是去听那些有生命的物，无生命的物的倾诉。通过不断的倾听，故事也渐渐清晰起来，之前支离的线索开始慢慢能拼凑成一幅画，可以依稀辨认个中模样了。我想，「Samorost」带给我最大的乐趣，就是透过各种各样的符号，提示来进行解谜。还有就是最后把所有线索串起来的时候，那种恍然大悟的感觉。\n\n![地下洞穴](http://samorost3.net/img/big/samorost-3-red-cave.jpg)\n\n![巨大昆虫](http://samorost3.net/img/big/samorost-3-newts.jpg)\n\n\n最后说一下游戏中几个，我个人到目前还有所回味的点。一个是第一次在自己家楼顶，使用天文望远镜望星星，当时不禁就想到了『三体』里的三体星的瞭望员，那位整日都在百无聊赖的看星星，然后某一天收到的来自地球的叶文洁的消息，最后回信警告「不要回答！不要回答！不要回答！」。第二个是自己驾驶飞船来到一个白色的星球上，星球上有一颗枯树，倾听它的声音，它告诉我们，它是如何被一个有着三个头的机械怪物烧掉，吃掉灵魂，变成如今这般模样的。而在下一个星球，也终于找到了故事的下册，也终于明白了三头机械怪物的来历。第三个是游戏蕴含的所有音乐，和音乐相关的关卡。在小黑人所在的那个星球上，调了很多遍才终于让四个小黑人同样节奏的唱起歌来，那一刻，整个情绪都起来了。当然，还有巨大的虫子，麦草，乌龟，花朵，果实，僧侣等等，这些意象在一起，共同编织一个「小王子」般的童话故事。\n\n最后，维基百科里写出了开发者创作游戏时参考的一些电影，但都是捷克导演的作品，自己本身对捷克电影不太了解。这里列出的两部，可以看到和游戏有明显的相关性。\n\n相关电影\n* [Vynález zkázy ( The Fabulous World of Jules Verne ) - Karel Zeman](https://movie.douban.com/subject/1940670/?from=subject-page)\n* [Hedgehog in the Fog](https://www.wikiwand.com/en/Hedgehog_in_the_Fog)","slug":"I-O-19-Samorost-的银河历险记","published":1,"updated":"2019-01-20T09:35:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx260010rg1vce46b1d8","content":"<p>「Samorost」是来自捷克开发者团队  Amanita Design 的作品，中文译名「星际历险记」，如果之前有玩过他们的作品比如「Machinarium」，便能提前对他们的作品风格有所预设。「Samorost」和前作「Machinarium」风格相似，都是相同的鼠标点触操作模式，内含大量构思巧妙的关卡，人物沟通采用了会话气泡加动画的形式，暗藏的手绘攻略，以及故事核心都是一个子供向的童话。</p>\n<p><strong>以下涉及剧透</strong></p>\n<span id=\"more\"></span>\n\n<p>「Samorost」的主人公是一个拿着小喇叭的 Gnome，小喇叭在游戏中是非常重要的道具，所以许多的关卡都是和音乐有关的。如果有过基本的音乐训练，我想通过这些关卡可能会更加有趣。像我这样没有接受过乐理训练的人，在很多地方，背景音乐给的提示察觉不到，或者是察觉到了，但没办法将音乐转化为谱，转化为符号，分不清各个音阶大小，所以最后只能考暗藏的提示和网上给出的攻略来解密，这自然也损失了不少乐趣。</p>\n<p>如果说前作「「Machinarium」」讲述的是一个英雄救美的故事，那么「Samorost」则是典型的太空探险故事，通过探险过程中的蛛丝马迹，发现了宇宙面临着巨大危机，而最后也是「英雄参上」，手擎宝剑，打败恶魔。Amanita Design 世界里的人物交流就像「三体」<br>星人一样，不需要文字，而是脑电波的直接传达。「Samorost」在前作的基础上，通过小喇叭，引入和「物」交流的概念，这里的「物」包含了动物，植物，昆虫，还有那些没有生命的星球，石头，门，雕刻图腾的柱子。它们时而讲述它们前世的遭遇，时而对当前的关卡给出提示，时而发出窸窣的声音。</p>\n<p>正如电影中的旁白通常会被认为是最低级的叙事方式，游戏中的通篇文字，也会被认为叙事能力低级。电影的叙事是通过电影语言进行的，电影语言就是通过镜头，对白，剪辑，音乐来叙事。游戏则在电影的层面上是又高了一个维度，这个维度就是交互。游戏中经常出现的小电影，过场动画，使用的其实就是电影语言的叙事方法。而游戏超越电影的一面，则在于如何使用「交互」来进行叙事。在传统的 RPG （Role-playing game）中，人物通过对话引导，进入事先设计好的剧情点，引发剧情。因为「Samorost」似乎是完全丢掉了文字表达这一手段。所以用除文字之外的媒介来讲好这个故事，就显得非常高明。这其中包括历险中开始，主人公使用天文望远镜观察外太空，冒险的中段捡到了第二本故事书（漫画书），故事从这里出现反转，以及在冒险过程中逐渐明白了用小喇叭听声音的意义，就是去听那些有生命的物，无生命的物的倾诉。通过不断的倾听，故事也渐渐清晰起来，之前支离的线索开始慢慢能拼凑成一幅画，可以依稀辨认个中模样了。我想，「Samorost」带给我最大的乐趣，就是透过各种各样的符号，提示来进行解谜。还有就是最后把所有线索串起来的时候，那种恍然大悟的感觉。</p>\n<p><img src=\"http://samorost3.net/img/big/samorost-3-red-cave.jpg\" alt=\"地下洞穴\"></p>\n<p><img src=\"http://samorost3.net/img/big/samorost-3-newts.jpg\" alt=\"巨大昆虫\"></p>\n<p>最后说一下游戏中几个，我个人到目前还有所回味的点。一个是第一次在自己家楼顶，使用天文望远镜望星星，当时不禁就想到了『三体』里的三体星的瞭望员，那位整日都在百无聊赖的看星星，然后某一天收到的来自地球的叶文洁的消息，最后回信警告「不要回答！不要回答！不要回答！」。第二个是自己驾驶飞船来到一个白色的星球上，星球上有一颗枯树，倾听它的声音，它告诉我们，它是如何被一个有着三个头的机械怪物烧掉，吃掉灵魂，变成如今这般模样的。而在下一个星球，也终于找到了故事的下册，也终于明白了三头机械怪物的来历。第三个是游戏蕴含的所有音乐，和音乐相关的关卡。在小黑人所在的那个星球上，调了很多遍才终于让四个小黑人同样节奏的唱起歌来，那一刻，整个情绪都起来了。当然，还有巨大的虫子，麦草，乌龟，花朵，果实，僧侣等等，这些意象在一起，共同编织一个「小王子」般的童话故事。</p>\n<p>最后，维基百科里写出了开发者创作游戏时参考的一些电影，但都是捷克导演的作品，自己本身对捷克电影不太了解。这里列出的两部，可以看到和游戏有明显的相关性。</p>\n<p>相关电影</p>\n<ul>\n<li><a href=\"https://movie.douban.com/subject/1940670/?from=subject-page\">Vynález zkázy ( The Fabulous World of Jules Verne ) - Karel Zeman</a></li>\n<li><a href=\"https://www.wikiwand.com/en/Hedgehog_in_the_Fog\">Hedgehog in the Fog</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>「Samorost」是来自捷克开发者团队  Amanita Design 的作品，中文译名「星际历险记」，如果之前有玩过他们的作品比如「Machinarium」，便能提前对他们的作品风格有所预设。「Samorost」和前作「Machinarium」风格相似，都是相同的鼠标点触操作模式，内含大量构思巧妙的关卡，人物沟通采用了会话气泡加动画的形式，暗藏的手绘攻略，以及故事核心都是一个子供向的童话。</p>\n<p><strong>以下涉及剧透</strong></p>","more":"<p>「Samorost」的主人公是一个拿着小喇叭的 Gnome，小喇叭在游戏中是非常重要的道具，所以许多的关卡都是和音乐有关的。如果有过基本的音乐训练，我想通过这些关卡可能会更加有趣。像我这样没有接受过乐理训练的人，在很多地方，背景音乐给的提示察觉不到，或者是察觉到了，但没办法将音乐转化为谱，转化为符号，分不清各个音阶大小，所以最后只能考暗藏的提示和网上给出的攻略来解密，这自然也损失了不少乐趣。</p>\n<p>如果说前作「「Machinarium」」讲述的是一个英雄救美的故事，那么「Samorost」则是典型的太空探险故事，通过探险过程中的蛛丝马迹，发现了宇宙面临着巨大危机，而最后也是「英雄参上」，手擎宝剑，打败恶魔。Amanita Design 世界里的人物交流就像「三体」<br>星人一样，不需要文字，而是脑电波的直接传达。「Samorost」在前作的基础上，通过小喇叭，引入和「物」交流的概念，这里的「物」包含了动物，植物，昆虫，还有那些没有生命的星球，石头，门，雕刻图腾的柱子。它们时而讲述它们前世的遭遇，时而对当前的关卡给出提示，时而发出窸窣的声音。</p>\n<p>正如电影中的旁白通常会被认为是最低级的叙事方式，游戏中的通篇文字，也会被认为叙事能力低级。电影的叙事是通过电影语言进行的，电影语言就是通过镜头，对白，剪辑，音乐来叙事。游戏则在电影的层面上是又高了一个维度，这个维度就是交互。游戏中经常出现的小电影，过场动画，使用的其实就是电影语言的叙事方法。而游戏超越电影的一面，则在于如何使用「交互」来进行叙事。在传统的 RPG （Role-playing game）中，人物通过对话引导，进入事先设计好的剧情点，引发剧情。因为「Samorost」似乎是完全丢掉了文字表达这一手段。所以用除文字之外的媒介来讲好这个故事，就显得非常高明。这其中包括历险中开始，主人公使用天文望远镜观察外太空，冒险的中段捡到了第二本故事书（漫画书），故事从这里出现反转，以及在冒险过程中逐渐明白了用小喇叭听声音的意义，就是去听那些有生命的物，无生命的物的倾诉。通过不断的倾听，故事也渐渐清晰起来，之前支离的线索开始慢慢能拼凑成一幅画，可以依稀辨认个中模样了。我想，「Samorost」带给我最大的乐趣，就是透过各种各样的符号，提示来进行解谜。还有就是最后把所有线索串起来的时候，那种恍然大悟的感觉。</p>\n<p><img src=\"http://samorost3.net/img/big/samorost-3-red-cave.jpg\" alt=\"地下洞穴\"></p>\n<p><img src=\"http://samorost3.net/img/big/samorost-3-newts.jpg\" alt=\"巨大昆虫\"></p>\n<p>最后说一下游戏中几个，我个人到目前还有所回味的点。一个是第一次在自己家楼顶，使用天文望远镜望星星，当时不禁就想到了『三体』里的三体星的瞭望员，那位整日都在百无聊赖的看星星，然后某一天收到的来自地球的叶文洁的消息，最后回信警告「不要回答！不要回答！不要回答！」。第二个是自己驾驶飞船来到一个白色的星球上，星球上有一颗枯树，倾听它的声音，它告诉我们，它是如何被一个有着三个头的机械怪物烧掉，吃掉灵魂，变成如今这般模样的。而在下一个星球，也终于找到了故事的下册，也终于明白了三头机械怪物的来历。第三个是游戏蕴含的所有音乐，和音乐相关的关卡。在小黑人所在的那个星球上，调了很多遍才终于让四个小黑人同样节奏的唱起歌来，那一刻，整个情绪都起来了。当然，还有巨大的虫子，麦草，乌龟，花朵，果实，僧侣等等，这些意象在一起，共同编织一个「小王子」般的童话故事。</p>\n<p>最后，维基百科里写出了开发者创作游戏时参考的一些电影，但都是捷克导演的作品，自己本身对捷克电影不太了解。这里列出的两部，可以看到和游戏有明显的相关性。</p>\n<p>相关电影</p>\n<ul>\n<li><a href=\"https://movie.douban.com/subject/1940670/?from=subject-page\">Vynález zkázy ( The Fabulous World of Jules Verne ) - Karel Zeman</a></li>\n<li><a href=\"https://www.wikiwand.com/en/Hedgehog_in_the_Fog\">Hedgehog in the Fog</a></li>\n</ul>"},{"title":"Hexo Theme 开发不完全记录","_content":"\n决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 [Pelican](https://github.com/getpelican/pelican) 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：\n\n> 两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。\n\n那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。\n\n目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 [Themes | Hexo](https://hexo.io/themes/index.html) 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。\n\n<!--more-->\n\n## template engine 的比较，swig，ejs or pug\n\nHexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 `public` 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。\n\n目前可用的 template engine 有多种选择，在 [Awesome JS](https://js.libhunt.com/categories/13-templating-engines) 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。\n\nejs 常用 pattern：\n\n- `<% %>`: 不输出任何内容，用于嵌套 if 或 for 控制语句；\n- `<%- %>`: 输出 raw html 文本；\n- `<%= %>`:  输出文本，html 中的 tag 如 `<div>` 会 escape 成 `&lt;div&gt;`\n\n\n\n## 文件结构\n\n这是我目前整个主题的文件结构。\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n│   ├── _partials\n│   │   ├── footer.ejs\n│   │   ├── head.ejs\n│   │   ├── header.ejs\n│   │   ├── pagination.ejs\n│   │   └── sidebar.ejs\n│   ├── archive.ejs\n│   ├── category.ejs\n│   ├── index.ejs\n│   ├── layout.ejs\n│   ├── page.ejs\n│   ├── post.ejs\n│   └── tag.ejs\n├── scripts\n└── source\n    ├── css\n    │   ├── highlight.css\n    │   └── main.css\n    ├── images\n    │   ├── footer.png\n    │   └── logo.png\n    └── js\n        ├── highlight.min.js\n        ├── highlightjs-line-numbers.js\n        ├── jquery-3.3.1.min.js\n        └── main.js\n```\n\n`layout` 里存放的是 `ejs` 模版文件。`source` 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。`languages` 和 `scripts` 这两个文件夹没有用到。\n\n在 ejs 里使用 source 中的文件：\n\n```ejs\n<%- js('js/main.js') %>\n<%- css('css/main.css') %>\n<img class=\"typology-logo\" src=\"/images/logo.png\" alt=\"hagoromo\" style=\"width: 125px;\">\n```\n\n因为 source 的里文件会原封不动的 copy 进 `public` 文件夹一份。所以可以直接以上述的形式进行引用。\n\n## 测试环境搭建\n\n最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 `hexo s` 进行本地测试。\n\n我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。\n\n## traps 不完全统计\n\n### archive 页面构建\n\n我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 `partial(archive)`。loop 所有 posts 时使用 global variable `site.posts`。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 `site.posts` 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。\n\n实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：\n\n```yaml\narchive_dir: archives\n```\n\n这样在执行完 `hexo g` 时候，会自动在 `public` 文件夹下生成一个 `archives` 文件，这个文件夹里的内容是和 template 文件 `archive.ejs` 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。\n\n```ejs\n<a href=\"/archives\">Archive</a>\n```\n\n接下来整个 archive 的页面，就是在  `archive.ejs`  中进行的。在 archive 页面里，采用变量 `page.posts`，输出的 posts 刚好是按照时间顺序从近到远排列。\n\n### pagination 分页实现\n\n使用 pagination 分页功能，需要现在 config 里配置：\n\n```yaml\nper_page: 10\npagination_dir: page\n```\n\n此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。\n\n```ejs\n<% if (page.total > 1){ %>\n<div class=\"hagoromo-pagination\">\n    <nav class=\"navigation pagination\" role=\"navigation\">\n        <% let prev_text = \"&laquo; \" + __('prev'); %>\n        <% let next_text = __('next') + \" &raquo;\"; %>\n        <%- paginator({\n          prev_text: prev_text,\n          next_text: next_text\n        }) %>\n    </nav>\n</div>\n<% } %>\n```\n\n如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 `paginator()` 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。\n\n### banner 下拉动画\n\n我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY>600 时，banner 从顶部出现并固定，当 scrollY<600 时，banner 隐去。\n\n大体思路是给 `window` bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 `animate()` 函数，相比 css，控制起来更加灵活方便。\n\n```javascript\n$(window).on('scroll', function() {\n    let scrollPosition = $(this).scrollTop();\n    let $header = $('.hagoromo-header');        \n    \n    if ($(window).width() > 800) {\n        if (scrollPosition < 200) {\n            $header.finish();\n            $header.css({\n                'top': '0',\n            });\n        }\n        if (scrollPosition > 600 && !$header.hasClass('hagoromo-header-sticky')) {\n            $header.addClass('hagoromo-header-sticky');\n            $header.css({\n                'top': '-70px',\n            });\n            $header.animate({\n                top: \"0\"\n            },160)\n        }\n        if (scrollPosition < 550 && $header.hasClass('hagoromo-header-sticky')) {\n            $header.animate({\n                top: \"-70px\"\n            },160, function() {\n                $header.removeClass('hagoromo-header-sticky');\n                $header.finish();\n                $header.css('top', '0');\n            })\n        }\n    } else {\n        if (scrollPosition > 55) {\n            $header.addClass('hagoromo-header-hidden')\n        } else {\n            $header.removeClass('hagoromo-header-hidden')\n        }\n    }\n});\n```\n\n其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 `finish()` ，强制结束之前动画。这样一来整体的效果就好多了。\n\n### coding highlight 和 line number 显示\n\nhexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 `<figure><table>` 这样形式。参考网上意见后，通常的解决方案是采取 `highlight.js`。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 `<pre><code>` 形式。引入 `highlight.js`  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：\n\n```javascript\nhljs.initHighlightingOnLoad();\n```\n\n这个函数是要写在自己 js 文件的 `$(document).ready()` **外面**。因为函数本身已经包含 onload 了。\n\n `highlight.js` 自身是没有 line number 显示的。这里需要另外一个扩展 [highlightjs-line-numbers.js](https://github.com/wcoder/highlightjs-line-numbers.js/), 使用方法同  `highlight.js` 。初始化的时候同样要写在  `$(document).ready()` **外面**。\n\n\n\n### 搜索功能的替代性实现\n\n搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。\n\n第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。\n\n第二种暂时只是我个人想法。就是借助 Google 的 [Custom Search JSON API](https://developers.google.com/custom-search/v1/overview)。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。\n\n第三种，也就是我现在使用的比较简单的办法。记得 [V2EX](www.v2ex.com) 也是这么实现的。利用 Google 搜索中的 `site:` 语句。点击 `SEARCH` 后是直接打开 Google，展示 Google 的站内搜索结果。\n\n## 后记\n\n文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。\n\n## 番外\n\n### 配置 favicon\n\n需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 `source` 文件夹下。在 `head.ejs` 中加入一条 `<link>` 来声明 favicon 地址：\n\n```ejs\n<% if (theme.favicon){ %>\n\t<link rel=\"icon\" href=\"<%- theme.favicon %>\">\n<% } %>\n```\n\n这里使用 if 结构是为了方便在 `config.yaml` 中进行配置。\n\n在 theme 的配置文件 `config.yaml` 中添加，\n\n```yaml\nfavicon: ./favicon.ico\n```\n\n即可。\n\n测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 `/Users/reyshawn/Library/Safari/Touch\\ Icons\\ Cache ` 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 `<head>` 中加入下面两个 `<link>`:\n\n```html\n<link rel=\"icon\" type=\"image/png\" href=\"./favicon.png\">\n<link rel=\"apple-touch-icon\" href=\"./favicon180x180.png\" sizes=\"180x180\">\n```\n\n同时要把 png 的icon 移动到 `source` 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。\n\n\n\n参考：\n\n- [What is the best practice for creating a favicon on a web site?](https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon)\n- [What size should apple-touch-icon.png be for iPad and iPhone?](https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone)\n\n","source":"_posts/Hexo Theme 开发不完全记录.md","raw":"---\ntitle: 'Hexo Theme 开发不完全记录'\ntags:\n- JavaScript\n- Front-end\ncategories: 'Coding'\n---\n\n决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 [Pelican](https://github.com/getpelican/pelican) 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：\n\n> 两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。\n\n那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。\n\n目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 [Themes | Hexo](https://hexo.io/themes/index.html) 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。\n\n<!--more-->\n\n## template engine 的比较，swig，ejs or pug\n\nHexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 `public` 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。\n\n目前可用的 template engine 有多种选择，在 [Awesome JS](https://js.libhunt.com/categories/13-templating-engines) 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。\n\nejs 常用 pattern：\n\n- `<% %>`: 不输出任何内容，用于嵌套 if 或 for 控制语句；\n- `<%- %>`: 输出 raw html 文本；\n- `<%= %>`:  输出文本，html 中的 tag 如 `<div>` 会 escape 成 `&lt;div&gt;`\n\n\n\n## 文件结构\n\n这是我目前整个主题的文件结构。\n\n```shell\n.\n├── _config.yml\n├── languages\n├── layout\n│   ├── _partials\n│   │   ├── footer.ejs\n│   │   ├── head.ejs\n│   │   ├── header.ejs\n│   │   ├── pagination.ejs\n│   │   └── sidebar.ejs\n│   ├── archive.ejs\n│   ├── category.ejs\n│   ├── index.ejs\n│   ├── layout.ejs\n│   ├── page.ejs\n│   ├── post.ejs\n│   └── tag.ejs\n├── scripts\n└── source\n    ├── css\n    │   ├── highlight.css\n    │   └── main.css\n    ├── images\n    │   ├── footer.png\n    │   └── logo.png\n    └── js\n        ├── highlight.min.js\n        ├── highlightjs-line-numbers.js\n        ├── jquery-3.3.1.min.js\n        └── main.js\n```\n\n`layout` 里存放的是 `ejs` 模版文件。`source` 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。`languages` 和 `scripts` 这两个文件夹没有用到。\n\n在 ejs 里使用 source 中的文件：\n\n```ejs\n<%- js('js/main.js') %>\n<%- css('css/main.css') %>\n<img class=\"typology-logo\" src=\"/images/logo.png\" alt=\"hagoromo\" style=\"width: 125px;\">\n```\n\n因为 source 的里文件会原封不动的 copy 进 `public` 文件夹一份。所以可以直接以上述的形式进行引用。\n\n## 测试环境搭建\n\n最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 `hexo s` 进行本地测试。\n\n我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。\n\n## traps 不完全统计\n\n### archive 页面构建\n\n我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 `partial(archive)`。loop 所有 posts 时使用 global variable `site.posts`。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 `site.posts` 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。\n\n实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：\n\n```yaml\narchive_dir: archives\n```\n\n这样在执行完 `hexo g` 时候，会自动在 `public` 文件夹下生成一个 `archives` 文件，这个文件夹里的内容是和 template 文件 `archive.ejs` 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。\n\n```ejs\n<a href=\"/archives\">Archive</a>\n```\n\n接下来整个 archive 的页面，就是在  `archive.ejs`  中进行的。在 archive 页面里，采用变量 `page.posts`，输出的 posts 刚好是按照时间顺序从近到远排列。\n\n### pagination 分页实现\n\n使用 pagination 分页功能，需要现在 config 里配置：\n\n```yaml\nper_page: 10\npagination_dir: page\n```\n\n此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。\n\n```ejs\n<% if (page.total > 1){ %>\n<div class=\"hagoromo-pagination\">\n    <nav class=\"navigation pagination\" role=\"navigation\">\n        <% let prev_text = \"&laquo; \" + __('prev'); %>\n        <% let next_text = __('next') + \" &raquo;\"; %>\n        <%- paginator({\n          prev_text: prev_text,\n          next_text: next_text\n        }) %>\n    </nav>\n</div>\n<% } %>\n```\n\n如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 `paginator()` 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。\n\n### banner 下拉动画\n\n我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY>600 时，banner 从顶部出现并固定，当 scrollY<600 时，banner 隐去。\n\n大体思路是给 `window` bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 `animate()` 函数，相比 css，控制起来更加灵活方便。\n\n```javascript\n$(window).on('scroll', function() {\n    let scrollPosition = $(this).scrollTop();\n    let $header = $('.hagoromo-header');        \n    \n    if ($(window).width() > 800) {\n        if (scrollPosition < 200) {\n            $header.finish();\n            $header.css({\n                'top': '0',\n            });\n        }\n        if (scrollPosition > 600 && !$header.hasClass('hagoromo-header-sticky')) {\n            $header.addClass('hagoromo-header-sticky');\n            $header.css({\n                'top': '-70px',\n            });\n            $header.animate({\n                top: \"0\"\n            },160)\n        }\n        if (scrollPosition < 550 && $header.hasClass('hagoromo-header-sticky')) {\n            $header.animate({\n                top: \"-70px\"\n            },160, function() {\n                $header.removeClass('hagoromo-header-sticky');\n                $header.finish();\n                $header.css('top', '0');\n            })\n        }\n    } else {\n        if (scrollPosition > 55) {\n            $header.addClass('hagoromo-header-hidden')\n        } else {\n            $header.removeClass('hagoromo-header-hidden')\n        }\n    }\n});\n```\n\n其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 `finish()` ，强制结束之前动画。这样一来整体的效果就好多了。\n\n### coding highlight 和 line number 显示\n\nhexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 `<figure><table>` 这样形式。参考网上意见后，通常的解决方案是采取 `highlight.js`。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 `<pre><code>` 形式。引入 `highlight.js`  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：\n\n```javascript\nhljs.initHighlightingOnLoad();\n```\n\n这个函数是要写在自己 js 文件的 `$(document).ready()` **外面**。因为函数本身已经包含 onload 了。\n\n `highlight.js` 自身是没有 line number 显示的。这里需要另外一个扩展 [highlightjs-line-numbers.js](https://github.com/wcoder/highlightjs-line-numbers.js/), 使用方法同  `highlight.js` 。初始化的时候同样要写在  `$(document).ready()` **外面**。\n\n\n\n### 搜索功能的替代性实现\n\n搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。\n\n第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。\n\n第二种暂时只是我个人想法。就是借助 Google 的 [Custom Search JSON API](https://developers.google.com/custom-search/v1/overview)。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。\n\n第三种，也就是我现在使用的比较简单的办法。记得 [V2EX](www.v2ex.com) 也是这么实现的。利用 Google 搜索中的 `site:` 语句。点击 `SEARCH` 后是直接打开 Google，展示 Google 的站内搜索结果。\n\n## 后记\n\n文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。\n\n## 番外\n\n### 配置 favicon\n\n需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 `source` 文件夹下。在 `head.ejs` 中加入一条 `<link>` 来声明 favicon 地址：\n\n```ejs\n<% if (theme.favicon){ %>\n\t<link rel=\"icon\" href=\"<%- theme.favicon %>\">\n<% } %>\n```\n\n这里使用 if 结构是为了方便在 `config.yaml` 中进行配置。\n\n在 theme 的配置文件 `config.yaml` 中添加，\n\n```yaml\nfavicon: ./favicon.ico\n```\n\n即可。\n\n测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 `/Users/reyshawn/Library/Safari/Touch\\ Icons\\ Cache ` 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 `<head>` 中加入下面两个 `<link>`:\n\n```html\n<link rel=\"icon\" type=\"image/png\" href=\"./favicon.png\">\n<link rel=\"apple-touch-icon\" href=\"./favicon180x180.png\" sizes=\"180x180\">\n```\n\n同时要把 png 的icon 移动到 `source` 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。\n\n\n\n参考：\n\n- [What is the best practice for creating a favicon on a web site?](https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon)\n- [What size should apple-touch-icon.png be for iPad and iPhone?](https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone)\n\n","slug":"Hexo Theme 开发不完全记录","published":1,"date":"2019-01-22T14:28:53.000Z","updated":"2019-01-22T14:28:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx260012rg1v93cnf8s3","content":"<p>决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 <a href=\"https://github.com/getpelican/pelican\">Pelican</a> 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：</p>\n<blockquote>\n<p>两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。</p>\n</blockquote>\n<p>那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。</p>\n<p>目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 <a href=\"https://hexo.io/themes/index.html\">Themes | Hexo</a> 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"template-engine-的比较，swig，ejs-or-pug\"><a href=\"#template-engine-的比较，swig，ejs-or-pug\" class=\"headerlink\" title=\"template engine 的比较，swig，ejs or pug\"></a>template engine 的比较，swig，ejs or pug</h2><p>Hexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 <code>public</code> 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。</p>\n<p>目前可用的 template engine 有多种选择，在 <a href=\"https://js.libhunt.com/categories/13-templating-engines\">Awesome JS</a> 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。</p>\n<p>ejs 常用 pattern：</p>\n<ul>\n<li><code>&lt;% %&gt;</code>: 不输出任何内容，用于嵌套 if 或 for 控制语句；</li>\n<li><code>&lt;%- %&gt;</code>: 输出 raw html 文本；</li>\n<li><code>&lt;%= %&gt;</code>:  输出文本，html 中的 tag 如 <code>&lt;div&gt;</code> 会 escape 成 <code>&amp;lt;div&amp;gt;</code></li>\n</ul>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><p>这是我目前整个主题的文件结构。</p>\n<pre><code class=\"shell\">.\n├── _config.yml\n├── languages\n├── layout\n│   ├── _partials\n│   │   ├── footer.ejs\n│   │   ├── head.ejs\n│   │   ├── header.ejs\n│   │   ├── pagination.ejs\n│   │   └── sidebar.ejs\n│   ├── archive.ejs\n│   ├── category.ejs\n│   ├── index.ejs\n│   ├── layout.ejs\n│   ├── page.ejs\n│   ├── post.ejs\n│   └── tag.ejs\n├── scripts\n└── source\n    ├── css\n    │   ├── highlight.css\n    │   └── main.css\n    ├── images\n    │   ├── footer.png\n    │   └── logo.png\n    └── js\n        ├── highlight.min.js\n        ├── highlightjs-line-numbers.js\n        ├── jquery-3.3.1.min.js\n        └── main.js\n</code></pre>\n<p><code>layout</code> 里存放的是 <code>ejs</code> 模版文件。<code>source</code> 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。<code>languages</code> 和 <code>scripts</code> 这两个文件夹没有用到。</p>\n<p>在 ejs 里使用 source 中的文件：</p>\n<pre><code class=\"ejs\">&lt;%- js(&#39;js/main.js&#39;) %&gt;\n&lt;%- css(&#39;css/main.css&#39;) %&gt;\n&lt;img class=&quot;typology-logo&quot; src=&quot;/images/logo.png&quot; alt=&quot;hagoromo&quot; style=&quot;width: 125px;&quot;&gt;\n</code></pre>\n<p>因为 source 的里文件会原封不动的 copy 进 <code>public</code> 文件夹一份。所以可以直接以上述的形式进行引用。</p>\n<h2 id=\"测试环境搭建\"><a href=\"#测试环境搭建\" class=\"headerlink\" title=\"测试环境搭建\"></a>测试环境搭建</h2><p>最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 <code>hexo s</code> 进行本地测试。</p>\n<p>我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。</p>\n<h2 id=\"traps-不完全统计\"><a href=\"#traps-不完全统计\" class=\"headerlink\" title=\"traps 不完全统计\"></a>traps 不完全统计</h2><h3 id=\"archive-页面构建\"><a href=\"#archive-页面构建\" class=\"headerlink\" title=\"archive 页面构建\"></a>archive 页面构建</h3><p>我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 <code>partial(archive)</code>。loop 所有 posts 时使用 global variable <code>site.posts</code>。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 <code>site.posts</code> 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。</p>\n<p>实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：</p>\n<pre><code class=\"yaml\">archive_dir: archives\n</code></pre>\n<p>这样在执行完 <code>hexo g</code> 时候，会自动在 <code>public</code> 文件夹下生成一个 <code>archives</code> 文件，这个文件夹里的内容是和 template 文件 <code>archive.ejs</code> 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。</p>\n<pre><code class=\"ejs\">&lt;a href=&quot;/archives&quot;&gt;Archive&lt;/a&gt;\n</code></pre>\n<p>接下来整个 archive 的页面，就是在  <code>archive.ejs</code>  中进行的。在 archive 页面里，采用变量 <code>page.posts</code>，输出的 posts 刚好是按照时间顺序从近到远排列。</p>\n<h3 id=\"pagination-分页实现\"><a href=\"#pagination-分页实现\" class=\"headerlink\" title=\"pagination 分页实现\"></a>pagination 分页实现</h3><p>使用 pagination 分页功能，需要现在 config 里配置：</p>\n<pre><code class=\"yaml\">per_page: 10\npagination_dir: page\n</code></pre>\n<p>此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。</p>\n<pre><code class=\"ejs\">&lt;% if (page.total &gt; 1)&#123; %&gt;\n&lt;div class=&quot;hagoromo-pagination&quot;&gt;\n    &lt;nav class=&quot;navigation pagination&quot; role=&quot;navigation&quot;&gt;\n        &lt;% let prev_text = &quot;&amp;laquo; &quot; + __(&#39;prev&#39;); %&gt;\n        &lt;% let next_text = __(&#39;next&#39;) + &quot; &amp;raquo;&quot;; %&gt;\n        &lt;%- paginator(&#123;\n          prev_text: prev_text,\n          next_text: next_text\n        &#125;) %&gt;\n    &lt;/nav&gt;\n&lt;/div&gt;\n&lt;% &#125; %&gt;\n</code></pre>\n<p>如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 <code>paginator()</code> 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。</p>\n<h3 id=\"banner-下拉动画\"><a href=\"#banner-下拉动画\" class=\"headerlink\" title=\"banner 下拉动画\"></a>banner 下拉动画</h3><p>我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY&gt;600 时，banner 从顶部出现并固定，当 scrollY&lt;600 时，banner 隐去。</p>\n<p>大体思路是给 <code>window</code> bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 <code>animate()</code> 函数，相比 css，控制起来更加灵活方便。</p>\n<pre><code class=\"javascript\">$(window).on(&#39;scroll&#39;, function() &#123;\n    let scrollPosition = $(this).scrollTop();\n    let $header = $(&#39;.hagoromo-header&#39;);        \n    \n    if ($(window).width() &gt; 800) &#123;\n        if (scrollPosition &lt; 200) &#123;\n            $header.finish();\n            $header.css(&#123;\n                &#39;top&#39;: &#39;0&#39;,\n            &#125;);\n        &#125;\n        if (scrollPosition &gt; 600 &amp;&amp; !$header.hasClass(&#39;hagoromo-header-sticky&#39;)) &#123;\n            $header.addClass(&#39;hagoromo-header-sticky&#39;);\n            $header.css(&#123;\n                &#39;top&#39;: &#39;-70px&#39;,\n            &#125;);\n            $header.animate(&#123;\n                top: &quot;0&quot;\n            &#125;,160)\n        &#125;\n        if (scrollPosition &lt; 550 &amp;&amp; $header.hasClass(&#39;hagoromo-header-sticky&#39;)) &#123;\n            $header.animate(&#123;\n                top: &quot;-70px&quot;\n            &#125;,160, function() &#123;\n                $header.removeClass(&#39;hagoromo-header-sticky&#39;);\n                $header.finish();\n                $header.css(&#39;top&#39;, &#39;0&#39;);\n            &#125;)\n        &#125;\n    &#125; else &#123;\n        if (scrollPosition &gt; 55) &#123;\n            $header.addClass(&#39;hagoromo-header-hidden&#39;)\n        &#125; else &#123;\n            $header.removeClass(&#39;hagoromo-header-hidden&#39;)\n        &#125;\n    &#125;\n&#125;);\n</code></pre>\n<p>其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 <code>finish()</code> ，强制结束之前动画。这样一来整体的效果就好多了。</p>\n<h3 id=\"coding-highlight-和-line-number-显示\"><a href=\"#coding-highlight-和-line-number-显示\" class=\"headerlink\" title=\"coding highlight 和 line number 显示\"></a>coding highlight 和 line number 显示</h3><p>hexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 <code>&lt;figure&gt;&lt;table&gt;</code> 这样形式。参考网上意见后，通常的解决方案是采取 <code>highlight.js</code>。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 <code>&lt;pre&gt;&lt;code&gt;</code> 形式。引入 <code>highlight.js</code>  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：</p>\n<pre><code class=\"javascript\">hljs.initHighlightingOnLoad();\n</code></pre>\n<p>这个函数是要写在自己 js 文件的 <code>$(document).ready()</code> <strong>外面</strong>。因为函数本身已经包含 onload 了。</p>\n<p> <code>highlight.js</code> 自身是没有 line number 显示的。这里需要另外一个扩展 <a href=\"https://github.com/wcoder/highlightjs-line-numbers.js/\">highlightjs-line-numbers.js</a>, 使用方法同  <code>highlight.js</code> 。初始化的时候同样要写在  <code>$(document).ready()</code> <strong>外面</strong>。</p>\n<h3 id=\"搜索功能的替代性实现\"><a href=\"#搜索功能的替代性实现\" class=\"headerlink\" title=\"搜索功能的替代性实现\"></a>搜索功能的替代性实现</h3><p>搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。</p>\n<p>第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。</p>\n<p>第二种暂时只是我个人想法。就是借助 Google 的 <a href=\"https://developers.google.com/custom-search/v1/overview\">Custom Search JSON API</a>。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。</p>\n<p>第三种，也就是我现在使用的比较简单的办法。记得 <a href=\"www.v2ex.com\">V2EX</a> 也是这么实现的。利用 Google 搜索中的 <code>site:</code> 语句。点击 <code>SEARCH</code> 后是直接打开 Google，展示 Google 的站内搜索结果。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。</p>\n<h2 id=\"番外\"><a href=\"#番外\" class=\"headerlink\" title=\"番外\"></a>番外</h2><h3 id=\"配置-favicon\"><a href=\"#配置-favicon\" class=\"headerlink\" title=\"配置 favicon\"></a>配置 favicon</h3><p>需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 <code>source</code> 文件夹下。在 <code>head.ejs</code> 中加入一条 <code>&lt;link&gt;</code> 来声明 favicon 地址：</p>\n<pre><code class=\"ejs\">&lt;% if (theme.favicon)&#123; %&gt;\n    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%- theme.favicon %&gt;&quot;&gt;\n&lt;% &#125; %&gt;\n</code></pre>\n<p>这里使用 if 结构是为了方便在 <code>config.yaml</code> 中进行配置。</p>\n<p>在 theme 的配置文件 <code>config.yaml</code> 中添加，</p>\n<pre><code class=\"yaml\">favicon: ./favicon.ico\n</code></pre>\n<p>即可。</p>\n<p>测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 <code>/Users/reyshawn/Library/Safari/Touch\\ Icons\\ Cache </code> 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 <code>&lt;head&gt;</code> 中加入下面两个 <code>&lt;link&gt;</code>:</p>\n<pre><code class=\"html\">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon.png&quot;&gt;\n&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;./favicon180x180.png&quot; sizes=&quot;180x180&quot;&gt;\n</code></pre>\n<p>同时要把 png 的icon 移动到 <code>source</code> 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon\">What is the best practice for creating a favicon on a web site?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone\">What size should apple-touch-icon.png be for iPad and iPhone?</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 <a href=\"https://github.com/getpelican/pelican\">Pelican</a> 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：</p>\n<blockquote>\n<p>两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。</p>\n</blockquote>\n<p>那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。</p>\n<p>目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 <a href=\"https://hexo.io/themes/index.html\">Themes | Hexo</a> 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。</p>","more":"<h2 id=\"template-engine-的比较，swig，ejs-or-pug\"><a href=\"#template-engine-的比较，swig，ejs-or-pug\" class=\"headerlink\" title=\"template engine 的比较，swig，ejs or pug\"></a>template engine 的比较，swig，ejs or pug</h2><p>Hexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 <code>public</code> 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。</p>\n<p>目前可用的 template engine 有多种选择，在 <a href=\"https://js.libhunt.com/categories/13-templating-engines\">Awesome JS</a> 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。</p>\n<p>ejs 常用 pattern：</p>\n<ul>\n<li><code>&lt;% %&gt;</code>: 不输出任何内容，用于嵌套 if 或 for 控制语句；</li>\n<li><code>&lt;%- %&gt;</code>: 输出 raw html 文本；</li>\n<li><code>&lt;%= %&gt;</code>:  输出文本，html 中的 tag 如 <code>&lt;div&gt;</code> 会 escape 成 <code>&amp;lt;div&amp;gt;</code></li>\n</ul>\n<h2 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h2><p>这是我目前整个主题的文件结构。</p>\n<pre><code class=\"shell\">.\n├── _config.yml\n├── languages\n├── layout\n│   ├── _partials\n│   │   ├── footer.ejs\n│   │   ├── head.ejs\n│   │   ├── header.ejs\n│   │   ├── pagination.ejs\n│   │   └── sidebar.ejs\n│   ├── archive.ejs\n│   ├── category.ejs\n│   ├── index.ejs\n│   ├── layout.ejs\n│   ├── page.ejs\n│   ├── post.ejs\n│   └── tag.ejs\n├── scripts\n└── source\n    ├── css\n    │   ├── highlight.css\n    │   └── main.css\n    ├── images\n    │   ├── footer.png\n    │   └── logo.png\n    └── js\n        ├── highlight.min.js\n        ├── highlightjs-line-numbers.js\n        ├── jquery-3.3.1.min.js\n        └── main.js\n</code></pre>\n<p><code>layout</code> 里存放的是 <code>ejs</code> 模版文件。<code>source</code> 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。<code>languages</code> 和 <code>scripts</code> 这两个文件夹没有用到。</p>\n<p>在 ejs 里使用 source 中的文件：</p>\n<pre><code class=\"ejs\">&lt;%- js(&#39;js/main.js&#39;) %&gt;\n&lt;%- css(&#39;css/main.css&#39;) %&gt;\n&lt;img class=&quot;typology-logo&quot; src=&quot;/images/logo.png&quot; alt=&quot;hagoromo&quot; style=&quot;width: 125px;&quot;&gt;\n</code></pre>\n<p>因为 source 的里文件会原封不动的 copy 进 <code>public</code> 文件夹一份。所以可以直接以上述的形式进行引用。</p>\n<h2 id=\"测试环境搭建\"><a href=\"#测试环境搭建\" class=\"headerlink\" title=\"测试环境搭建\"></a>测试环境搭建</h2><p>最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 <code>hexo s</code> 进行本地测试。</p>\n<p>我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。</p>\n<h2 id=\"traps-不完全统计\"><a href=\"#traps-不完全统计\" class=\"headerlink\" title=\"traps 不完全统计\"></a>traps 不完全统计</h2><h3 id=\"archive-页面构建\"><a href=\"#archive-页面构建\" class=\"headerlink\" title=\"archive 页面构建\"></a>archive 页面构建</h3><p>我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 <code>partial(archive)</code>。loop 所有 posts 时使用 global variable <code>site.posts</code>。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 <code>site.posts</code> 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。</p>\n<p>实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：</p>\n<pre><code class=\"yaml\">archive_dir: archives\n</code></pre>\n<p>这样在执行完 <code>hexo g</code> 时候，会自动在 <code>public</code> 文件夹下生成一个 <code>archives</code> 文件，这个文件夹里的内容是和 template 文件 <code>archive.ejs</code> 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。</p>\n<pre><code class=\"ejs\">&lt;a href=&quot;/archives&quot;&gt;Archive&lt;/a&gt;\n</code></pre>\n<p>接下来整个 archive 的页面，就是在  <code>archive.ejs</code>  中进行的。在 archive 页面里，采用变量 <code>page.posts</code>，输出的 posts 刚好是按照时间顺序从近到远排列。</p>\n<h3 id=\"pagination-分页实现\"><a href=\"#pagination-分页实现\" class=\"headerlink\" title=\"pagination 分页实现\"></a>pagination 分页实现</h3><p>使用 pagination 分页功能，需要现在 config 里配置：</p>\n<pre><code class=\"yaml\">per_page: 10\npagination_dir: page\n</code></pre>\n<p>此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。</p>\n<pre><code class=\"ejs\">&lt;% if (page.total &gt; 1)&#123; %&gt;\n&lt;div class=&quot;hagoromo-pagination&quot;&gt;\n    &lt;nav class=&quot;navigation pagination&quot; role=&quot;navigation&quot;&gt;\n        &lt;% let prev_text = &quot;&amp;laquo; &quot; + __(&#39;prev&#39;); %&gt;\n        &lt;% let next_text = __(&#39;next&#39;) + &quot; &amp;raquo;&quot;; %&gt;\n        &lt;%- paginator(&#123;\n          prev_text: prev_text,\n          next_text: next_text\n        &#125;) %&gt;\n    &lt;/nav&gt;\n&lt;/div&gt;\n&lt;% &#125; %&gt;\n</code></pre>\n<p>如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 <code>paginator()</code> 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。</p>\n<h3 id=\"banner-下拉动画\"><a href=\"#banner-下拉动画\" class=\"headerlink\" title=\"banner 下拉动画\"></a>banner 下拉动画</h3><p>我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY&gt;600 时，banner 从顶部出现并固定，当 scrollY&lt;600 时，banner 隐去。</p>\n<p>大体思路是给 <code>window</code> bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 <code>animate()</code> 函数，相比 css，控制起来更加灵活方便。</p>\n<pre><code class=\"javascript\">$(window).on(&#39;scroll&#39;, function() &#123;\n    let scrollPosition = $(this).scrollTop();\n    let $header = $(&#39;.hagoromo-header&#39;);        \n    \n    if ($(window).width() &gt; 800) &#123;\n        if (scrollPosition &lt; 200) &#123;\n            $header.finish();\n            $header.css(&#123;\n                &#39;top&#39;: &#39;0&#39;,\n            &#125;);\n        &#125;\n        if (scrollPosition &gt; 600 &amp;&amp; !$header.hasClass(&#39;hagoromo-header-sticky&#39;)) &#123;\n            $header.addClass(&#39;hagoromo-header-sticky&#39;);\n            $header.css(&#123;\n                &#39;top&#39;: &#39;-70px&#39;,\n            &#125;);\n            $header.animate(&#123;\n                top: &quot;0&quot;\n            &#125;,160)\n        &#125;\n        if (scrollPosition &lt; 550 &amp;&amp; $header.hasClass(&#39;hagoromo-header-sticky&#39;)) &#123;\n            $header.animate(&#123;\n                top: &quot;-70px&quot;\n            &#125;,160, function() &#123;\n                $header.removeClass(&#39;hagoromo-header-sticky&#39;);\n                $header.finish();\n                $header.css(&#39;top&#39;, &#39;0&#39;);\n            &#125;)\n        &#125;\n    &#125; else &#123;\n        if (scrollPosition &gt; 55) &#123;\n            $header.addClass(&#39;hagoromo-header-hidden&#39;)\n        &#125; else &#123;\n            $header.removeClass(&#39;hagoromo-header-hidden&#39;)\n        &#125;\n    &#125;\n&#125;);\n</code></pre>\n<p>其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 <code>finish()</code> ，强制结束之前动画。这样一来整体的效果就好多了。</p>\n<h3 id=\"coding-highlight-和-line-number-显示\"><a href=\"#coding-highlight-和-line-number-显示\" class=\"headerlink\" title=\"coding highlight 和 line number 显示\"></a>coding highlight 和 line number 显示</h3><p>hexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 <code>&lt;figure&gt;&lt;table&gt;</code> 这样形式。参考网上意见后，通常的解决方案是采取 <code>highlight.js</code>。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 <code>&lt;pre&gt;&lt;code&gt;</code> 形式。引入 <code>highlight.js</code>  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：</p>\n<pre><code class=\"javascript\">hljs.initHighlightingOnLoad();\n</code></pre>\n<p>这个函数是要写在自己 js 文件的 <code>$(document).ready()</code> <strong>外面</strong>。因为函数本身已经包含 onload 了。</p>\n<p> <code>highlight.js</code> 自身是没有 line number 显示的。这里需要另外一个扩展 <a href=\"https://github.com/wcoder/highlightjs-line-numbers.js/\">highlightjs-line-numbers.js</a>, 使用方法同  <code>highlight.js</code> 。初始化的时候同样要写在  <code>$(document).ready()</code> <strong>外面</strong>。</p>\n<h3 id=\"搜索功能的替代性实现\"><a href=\"#搜索功能的替代性实现\" class=\"headerlink\" title=\"搜索功能的替代性实现\"></a>搜索功能的替代性实现</h3><p>搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。</p>\n<p>第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。</p>\n<p>第二种暂时只是我个人想法。就是借助 Google 的 <a href=\"https://developers.google.com/custom-search/v1/overview\">Custom Search JSON API</a>。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。</p>\n<p>第三种，也就是我现在使用的比较简单的办法。记得 <a href=\"www.v2ex.com\">V2EX</a> 也是这么实现的。利用 Google 搜索中的 <code>site:</code> 语句。点击 <code>SEARCH</code> 后是直接打开 Google，展示 Google 的站内搜索结果。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。</p>\n<h2 id=\"番外\"><a href=\"#番外\" class=\"headerlink\" title=\"番外\"></a>番外</h2><h3 id=\"配置-favicon\"><a href=\"#配置-favicon\" class=\"headerlink\" title=\"配置 favicon\"></a>配置 favicon</h3><p>需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 <code>source</code> 文件夹下。在 <code>head.ejs</code> 中加入一条 <code>&lt;link&gt;</code> 来声明 favicon 地址：</p>\n<pre><code class=\"ejs\">&lt;% if (theme.favicon)&#123; %&gt;\n    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%- theme.favicon %&gt;&quot;&gt;\n&lt;% &#125; %&gt;\n</code></pre>\n<p>这里使用 if 结构是为了方便在 <code>config.yaml</code> 中进行配置。</p>\n<p>在 theme 的配置文件 <code>config.yaml</code> 中添加，</p>\n<pre><code class=\"yaml\">favicon: ./favicon.ico\n</code></pre>\n<p>即可。</p>\n<p>测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 <code>/Users/reyshawn/Library/Safari/Touch\\ Icons\\ Cache </code> 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 <code>&lt;head&gt;</code> 中加入下面两个 <code>&lt;link&gt;</code>:</p>\n<pre><code class=\"html\">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon.png&quot;&gt;\n&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;./favicon180x180.png&quot; sizes=&quot;180x180&quot;&gt;\n</code></pre>\n<p>同时要把 png 的icon 移动到 <code>source</code> 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon\">What is the best practice for creating a favicon on a web site?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone\">What size should apple-touch-icon.png be for iPad and iPhone?</a></li>\n</ul>"},{"title":"「有目标，能坚持！」","date":"2017-01-05T12:23:15.000Z","_content":"\n## 碎片式学习\n\n最近花了￥30买了 Reeder，一个 RSS 阅读应用。用起来，左划右划的快捷操作，可以按照时间顺序排列的 feed，黑白风的 UI，各方面都要比 Feedly 出色。一个好的软件和应用，交互的好坏直接决定了你打开它的次数。显然，我更愿意打开 Reeder，甚至愿意直接在 Reeder 进行阅读。而以往所有的阅读活动都是在稍后读应用中进行的。但是在我用了有将近两年的 RSS 工具，我都没有意识到，这样的一种阅读活动，其实不比微博，twitter，高出多少，本质依然是碎片式的学习，碎片式的阅读，其内容来源也都是来自互联网快速烘焙的产品，哪怕依靠大厂，哪怕是 New Yorker，the economist，每篇文章的保存时间会有多久呢？<!-- more -->思来想去，这些互联网上的内容服务，最合适的内容形式还是「新闻」，「泛科普」以及「情感类」或「针砭时弊」类文章。所以，也是在最近，就在买了 Reeder 应用之后，才开始注意到碎片式的学习给自己带来的种种消极影响。以前都不曾注意。在知乎问题「[碎片化学习的意义？碎片化学习的原因？碎片化学习的最终目标？](https://www.zhihu.com/question/20238280/answer/81597965)」中，排名第一的答案这样评价碎片式学习的：\n>碎片化知识通过连续的新鲜内容，不断刺激你的大脑，让你始终处于「啊！又知道了新的东西」的喜悦中，从而难以自拔，这也就是我们难以抑制刷微博、刷朋友圈的缘故，因为我们只需要付出很少，就可以沉浸在「获得了新东西」的刺激里面。**--V弦上的咏叹调**\n\n## RSS 使用指导\n\n在思考 RSS 功用时自然想到了所谓「浅层阅读」和「深层阅读」的问题，自己在笔记里关于这两种阅读是这样描述的：\n>关于最近所遇到的问题，微博，rss，微信，twitter，等等这些碎片化工具，只能占生活的 10 %， 它们只是用来调解学习和锻炼的，同时作为信息收集的重要工具。这里主要收集的信息是，有价值的书，电影，音乐。关于工作内容的消息，无人机领域的变化等等。对于收集来的信息进行二次加工和整理，要么放进 instapaper 阅读，主要是练习语言。要么是在 onenote 里写成文章发表等。但信息收集只占 10%，所以，RSS 的位置就等同于微博的位置，远没有达到系统学习高度。其余的 90% 就是系统化学习，全身心的，枯燥的，需要不停思考，不停练习，不停重复，不停 debug 的学习过程。这过程会很累。完成任务，或间隙休息调整，读读微博或者 RSS。\n\n所以 RSS 不是一个好的学习工具，它只是一个信息收集的工具。而它的信息收集功能其实也可以被其他更有效的工具代替。而当把 RSS 拿作语言学习，则又是另外一回事。作为语言学习的 RSS，则是正襟危坐的坐在电脑前，认认真真记录，理解所阅读的每一句外文信息，并不时摘录好词好句。而后还要不断复习背诵。作为语言学习时，其实跟是不是通过 RSS 获取文章，和使用 RSS 已经没有什么关系了。\n\n我在「少数派」看到了 JailbreakHum 对于 RSS 的这样的描述：\n>但 RSS 不是这样的，RSS 重，真正的 RSS 使用者只会因为一个网站产出的大部分内容乃至频率都合自己口味，不想错过哪怕一条可能对自己有用的文章才会去订阅。我们订阅这样的网站，就是为了能够篇篇不漏地看这个网站产出的内容，起码要看标题。所以，就需要「未读数」来提醒我们有多少篇还没读，不清空未读数，我们会有一种压力和负罪感，我们会觉得该吸收的东西没有吸收到。**--JailbreakHum**\n\n于是我就把我订阅的那些更新频率高的，自己基本很少打开看，或者本身兴趣不大的，都 unfollow 了。确实，RSS 里只适合订阅哪些你本人相当熟悉，不愿意错过每一篇文章的源。而不适合订阅那些更新频率相当高，自己又不熟悉的源。\n\n## 浅层阅读与深层阅读\n\n所以一般的阅读，我想能够分三个维度去考量：\n* 浅层阅读 - 微博，微信，RSS \n* 深层阅读 - 小说，非虚构类文学，严肃文学，实体书，instapaper （有时兼顾语言学习之用）\n* 专业学习的阅读 - 专业书籍，需要不断推演，思考，画重点，作笔记，并在之后不断回顾复习\n\n浅层阅读，不经过大脑，浏览关键字，主要思考信息是否有认真阅读的价值，这也是信息爆炸时代最基本的特。浅层，深层，专业系统化学习，其各自时间应该控制在 1:3:6 的比例。浅层阅读主要在移动设备上进行，深层阅读部分在平板，部分需要深度处理的内容在电脑上。专业只是学习需要，平板和电脑配合使用。平板作为辅助工具。\n\n要对抗碎片划的学习，因为碎片化意味着不系统，意味着浮于表面，意味着如果长时间投入就是浪费时间。所以碎片化阅读最好的方式就是利用活动与活动的间隙进行。\n\n## Habitica 带来的启示\n\n在知乎上看到的，之所以会感到信息爆炸，\n* 一，是目标不够明确，目标明确，找到的信息都是自己需要的信息，不会觉得信息很多。\n* 二，是爱不深，兴趣不够。综合来看，应该尽量限制自己的兴趣，同时加强在专业方面的学习。\n\n对于第一点，自己最近在使用 [Habitica](https://habitica.com/) 时也是深有体会。Habitica 是一款把 to do list 这种效率软件包装成 RPG 游戏的应用。整体设计游戏化做的非常棒，在使用的过程中，自己也渐渐发现目标是非常重要的。以前人们常说，什么什么需要坚持，需要有毅力。在不断地失败又实践的过程中，我渐渐发现所谓的「坚持」不过是事情的结果，而不是事情的原因。我们对某件事的坚持，是因为我们有坚持它的动力，有目标，能坚持。而一般的效率软件则是帮助人们来找到目标的。而 Habitica 之所以比一般的效率软件好，就在与它的游戏化人生的概念。其实人生本身就是一场 RPG 角色扮演游戏。\n\n![](https://s-media-cache-ak0.pinimg.com/564x/de/99/d3/de99d3be6709eecc9ad13f762db29cd1.jpg)\n\n今天是二〇一七年的第五天，我相信对于我，这一年一定会迎来一场创作的大爆发。我先在在使用 Habitica，而我也想不出会有什么原因会让我停下来不用它，大概会一直用下去吧，在名为「the Road of Life」的游戏中继续升级打怪。\n\n\n\n","source":"_posts/I-O-20-「有目标，能坚持！」.md","raw":"---\ntitle: '「有目标，能坚持！」'\ndate: 2017-01-05 20:23:15\ntags: \ncategories: \"I/O\"\n---\n\n## 碎片式学习\n\n最近花了￥30买了 Reeder，一个 RSS 阅读应用。用起来，左划右划的快捷操作，可以按照时间顺序排列的 feed，黑白风的 UI，各方面都要比 Feedly 出色。一个好的软件和应用，交互的好坏直接决定了你打开它的次数。显然，我更愿意打开 Reeder，甚至愿意直接在 Reeder 进行阅读。而以往所有的阅读活动都是在稍后读应用中进行的。但是在我用了有将近两年的 RSS 工具，我都没有意识到，这样的一种阅读活动，其实不比微博，twitter，高出多少，本质依然是碎片式的学习，碎片式的阅读，其内容来源也都是来自互联网快速烘焙的产品，哪怕依靠大厂，哪怕是 New Yorker，the economist，每篇文章的保存时间会有多久呢？<!-- more -->思来想去，这些互联网上的内容服务，最合适的内容形式还是「新闻」，「泛科普」以及「情感类」或「针砭时弊」类文章。所以，也是在最近，就在买了 Reeder 应用之后，才开始注意到碎片式的学习给自己带来的种种消极影响。以前都不曾注意。在知乎问题「[碎片化学习的意义？碎片化学习的原因？碎片化学习的最终目标？](https://www.zhihu.com/question/20238280/answer/81597965)」中，排名第一的答案这样评价碎片式学习的：\n>碎片化知识通过连续的新鲜内容，不断刺激你的大脑，让你始终处于「啊！又知道了新的东西」的喜悦中，从而难以自拔，这也就是我们难以抑制刷微博、刷朋友圈的缘故，因为我们只需要付出很少，就可以沉浸在「获得了新东西」的刺激里面。**--V弦上的咏叹调**\n\n## RSS 使用指导\n\n在思考 RSS 功用时自然想到了所谓「浅层阅读」和「深层阅读」的问题，自己在笔记里关于这两种阅读是这样描述的：\n>关于最近所遇到的问题，微博，rss，微信，twitter，等等这些碎片化工具，只能占生活的 10 %， 它们只是用来调解学习和锻炼的，同时作为信息收集的重要工具。这里主要收集的信息是，有价值的书，电影，音乐。关于工作内容的消息，无人机领域的变化等等。对于收集来的信息进行二次加工和整理，要么放进 instapaper 阅读，主要是练习语言。要么是在 onenote 里写成文章发表等。但信息收集只占 10%，所以，RSS 的位置就等同于微博的位置，远没有达到系统学习高度。其余的 90% 就是系统化学习，全身心的，枯燥的，需要不停思考，不停练习，不停重复，不停 debug 的学习过程。这过程会很累。完成任务，或间隙休息调整，读读微博或者 RSS。\n\n所以 RSS 不是一个好的学习工具，它只是一个信息收集的工具。而它的信息收集功能其实也可以被其他更有效的工具代替。而当把 RSS 拿作语言学习，则又是另外一回事。作为语言学习的 RSS，则是正襟危坐的坐在电脑前，认认真真记录，理解所阅读的每一句外文信息，并不时摘录好词好句。而后还要不断复习背诵。作为语言学习时，其实跟是不是通过 RSS 获取文章，和使用 RSS 已经没有什么关系了。\n\n我在「少数派」看到了 JailbreakHum 对于 RSS 的这样的描述：\n>但 RSS 不是这样的，RSS 重，真正的 RSS 使用者只会因为一个网站产出的大部分内容乃至频率都合自己口味，不想错过哪怕一条可能对自己有用的文章才会去订阅。我们订阅这样的网站，就是为了能够篇篇不漏地看这个网站产出的内容，起码要看标题。所以，就需要「未读数」来提醒我们有多少篇还没读，不清空未读数，我们会有一种压力和负罪感，我们会觉得该吸收的东西没有吸收到。**--JailbreakHum**\n\n于是我就把我订阅的那些更新频率高的，自己基本很少打开看，或者本身兴趣不大的，都 unfollow 了。确实，RSS 里只适合订阅哪些你本人相当熟悉，不愿意错过每一篇文章的源。而不适合订阅那些更新频率相当高，自己又不熟悉的源。\n\n## 浅层阅读与深层阅读\n\n所以一般的阅读，我想能够分三个维度去考量：\n* 浅层阅读 - 微博，微信，RSS \n* 深层阅读 - 小说，非虚构类文学，严肃文学，实体书，instapaper （有时兼顾语言学习之用）\n* 专业学习的阅读 - 专业书籍，需要不断推演，思考，画重点，作笔记，并在之后不断回顾复习\n\n浅层阅读，不经过大脑，浏览关键字，主要思考信息是否有认真阅读的价值，这也是信息爆炸时代最基本的特。浅层，深层，专业系统化学习，其各自时间应该控制在 1:3:6 的比例。浅层阅读主要在移动设备上进行，深层阅读部分在平板，部分需要深度处理的内容在电脑上。专业只是学习需要，平板和电脑配合使用。平板作为辅助工具。\n\n要对抗碎片划的学习，因为碎片化意味着不系统，意味着浮于表面，意味着如果长时间投入就是浪费时间。所以碎片化阅读最好的方式就是利用活动与活动的间隙进行。\n\n## Habitica 带来的启示\n\n在知乎上看到的，之所以会感到信息爆炸，\n* 一，是目标不够明确，目标明确，找到的信息都是自己需要的信息，不会觉得信息很多。\n* 二，是爱不深，兴趣不够。综合来看，应该尽量限制自己的兴趣，同时加强在专业方面的学习。\n\n对于第一点，自己最近在使用 [Habitica](https://habitica.com/) 时也是深有体会。Habitica 是一款把 to do list 这种效率软件包装成 RPG 游戏的应用。整体设计游戏化做的非常棒，在使用的过程中，自己也渐渐发现目标是非常重要的。以前人们常说，什么什么需要坚持，需要有毅力。在不断地失败又实践的过程中，我渐渐发现所谓的「坚持」不过是事情的结果，而不是事情的原因。我们对某件事的坚持，是因为我们有坚持它的动力，有目标，能坚持。而一般的效率软件则是帮助人们来找到目标的。而 Habitica 之所以比一般的效率软件好，就在与它的游戏化人生的概念。其实人生本身就是一场 RPG 角色扮演游戏。\n\n![](https://s-media-cache-ak0.pinimg.com/564x/de/99/d3/de99d3be6709eecc9ad13f762db29cd1.jpg)\n\n今天是二〇一七年的第五天，我相信对于我，这一年一定会迎来一场创作的大爆发。我先在在使用 Habitica，而我也想不出会有什么原因会让我停下来不用它，大概会一直用下去吧，在名为「the Road of Life」的游戏中继续升级打怪。\n\n\n\n","slug":"I-O-20-「有目标，能坚持！」","published":1,"updated":"2019-01-20T09:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx260015rg1v6e994ti1","content":"<h2 id=\"碎片式学习\"><a href=\"#碎片式学习\" class=\"headerlink\" title=\"碎片式学习\"></a>碎片式学习</h2><p>最近花了￥30买了 Reeder，一个 RSS 阅读应用。用起来，左划右划的快捷操作，可以按照时间顺序排列的 feed，黑白风的 UI，各方面都要比 Feedly 出色。一个好的软件和应用，交互的好坏直接决定了你打开它的次数。显然，我更愿意打开 Reeder，甚至愿意直接在 Reeder 进行阅读。而以往所有的阅读活动都是在稍后读应用中进行的。但是在我用了有将近两年的 RSS 工具，我都没有意识到，这样的一种阅读活动，其实不比微博，twitter，高出多少，本质依然是碎片式的学习，碎片式的阅读，其内容来源也都是来自互联网快速烘焙的产品，哪怕依靠大厂，哪怕是 New Yorker，the economist，每篇文章的保存时间会有多久呢？<span id=\"more\"></span>思来想去，这些互联网上的内容服务，最合适的内容形式还是「新闻」，「泛科普」以及「情感类」或「针砭时弊」类文章。所以，也是在最近，就在买了 Reeder 应用之后，才开始注意到碎片式的学习给自己带来的种种消极影响。以前都不曾注意。在知乎问题「<a href=\"https://www.zhihu.com/question/20238280/answer/81597965\">碎片化学习的意义？碎片化学习的原因？碎片化学习的最终目标？</a>」中，排名第一的答案这样评价碎片式学习的：</p>\n<blockquote>\n<p>碎片化知识通过连续的新鲜内容，不断刺激你的大脑，让你始终处于「啊！又知道了新的东西」的喜悦中，从而难以自拔，这也就是我们难以抑制刷微博、刷朋友圈的缘故，因为我们只需要付出很少，就可以沉浸在「获得了新东西」的刺激里面。**–V弦上的咏叹调**</p>\n</blockquote>\n<h2 id=\"RSS-使用指导\"><a href=\"#RSS-使用指导\" class=\"headerlink\" title=\"RSS 使用指导\"></a>RSS 使用指导</h2><p>在思考 RSS 功用时自然想到了所谓「浅层阅读」和「深层阅读」的问题，自己在笔记里关于这两种阅读是这样描述的：</p>\n<blockquote>\n<p>关于最近所遇到的问题，微博，rss，微信，twitter，等等这些碎片化工具，只能占生活的 10 %， 它们只是用来调解学习和锻炼的，同时作为信息收集的重要工具。这里主要收集的信息是，有价值的书，电影，音乐。关于工作内容的消息，无人机领域的变化等等。对于收集来的信息进行二次加工和整理，要么放进 instapaper 阅读，主要是练习语言。要么是在 onenote 里写成文章发表等。但信息收集只占 10%，所以，RSS 的位置就等同于微博的位置，远没有达到系统学习高度。其余的 90% 就是系统化学习，全身心的，枯燥的，需要不停思考，不停练习，不停重复，不停 debug 的学习过程。这过程会很累。完成任务，或间隙休息调整，读读微博或者 RSS。</p>\n</blockquote>\n<p>所以 RSS 不是一个好的学习工具，它只是一个信息收集的工具。而它的信息收集功能其实也可以被其他更有效的工具代替。而当把 RSS 拿作语言学习，则又是另外一回事。作为语言学习的 RSS，则是正襟危坐的坐在电脑前，认认真真记录，理解所阅读的每一句外文信息，并不时摘录好词好句。而后还要不断复习背诵。作为语言学习时，其实跟是不是通过 RSS 获取文章，和使用 RSS 已经没有什么关系了。</p>\n<p>我在「少数派」看到了 JailbreakHum 对于 RSS 的这样的描述：</p>\n<blockquote>\n<p>但 RSS 不是这样的，RSS 重，真正的 RSS 使用者只会因为一个网站产出的大部分内容乃至频率都合自己口味，不想错过哪怕一条可能对自己有用的文章才会去订阅。我们订阅这样的网站，就是为了能够篇篇不漏地看这个网站产出的内容，起码要看标题。所以，就需要「未读数」来提醒我们有多少篇还没读，不清空未读数，我们会有一种压力和负罪感，我们会觉得该吸收的东西没有吸收到。**–JailbreakHum**</p>\n</blockquote>\n<p>于是我就把我订阅的那些更新频率高的，自己基本很少打开看，或者本身兴趣不大的，都 unfollow 了。确实，RSS 里只适合订阅哪些你本人相当熟悉，不愿意错过每一篇文章的源。而不适合订阅那些更新频率相当高，自己又不熟悉的源。</p>\n<h2 id=\"浅层阅读与深层阅读\"><a href=\"#浅层阅读与深层阅读\" class=\"headerlink\" title=\"浅层阅读与深层阅读\"></a>浅层阅读与深层阅读</h2><p>所以一般的阅读，我想能够分三个维度去考量：</p>\n<ul>\n<li>浅层阅读 - 微博，微信，RSS </li>\n<li>深层阅读 - 小说，非虚构类文学，严肃文学，实体书，instapaper （有时兼顾语言学习之用）</li>\n<li>专业学习的阅读 - 专业书籍，需要不断推演，思考，画重点，作笔记，并在之后不断回顾复习</li>\n</ul>\n<p>浅层阅读，不经过大脑，浏览关键字，主要思考信息是否有认真阅读的价值，这也是信息爆炸时代最基本的特。浅层，深层，专业系统化学习，其各自时间应该控制在 1:3:6 的比例。浅层阅读主要在移动设备上进行，深层阅读部分在平板，部分需要深度处理的内容在电脑上。专业只是学习需要，平板和电脑配合使用。平板作为辅助工具。</p>\n<p>要对抗碎片划的学习，因为碎片化意味着不系统，意味着浮于表面，意味着如果长时间投入就是浪费时间。所以碎片化阅读最好的方式就是利用活动与活动的间隙进行。</p>\n<h2 id=\"Habitica-带来的启示\"><a href=\"#Habitica-带来的启示\" class=\"headerlink\" title=\"Habitica 带来的启示\"></a>Habitica 带来的启示</h2><p>在知乎上看到的，之所以会感到信息爆炸，</p>\n<ul>\n<li>一，是目标不够明确，目标明确，找到的信息都是自己需要的信息，不会觉得信息很多。</li>\n<li>二，是爱不深，兴趣不够。综合来看，应该尽量限制自己的兴趣，同时加强在专业方面的学习。</li>\n</ul>\n<p>对于第一点，自己最近在使用 <a href=\"https://habitica.com/\">Habitica</a> 时也是深有体会。Habitica 是一款把 to do list 这种效率软件包装成 RPG 游戏的应用。整体设计游戏化做的非常棒，在使用的过程中，自己也渐渐发现目标是非常重要的。以前人们常说，什么什么需要坚持，需要有毅力。在不断地失败又实践的过程中，我渐渐发现所谓的「坚持」不过是事情的结果，而不是事情的原因。我们对某件事的坚持，是因为我们有坚持它的动力，有目标，能坚持。而一般的效率软件则是帮助人们来找到目标的。而 Habitica 之所以比一般的效率软件好，就在与它的游戏化人生的概念。其实人生本身就是一场 RPG 角色扮演游戏。</p>\n<p><img src=\"https://s-media-cache-ak0.pinimg.com/564x/de/99/d3/de99d3be6709eecc9ad13f762db29cd1.jpg\"></p>\n<p>今天是二〇一七年的第五天，我相信对于我，这一年一定会迎来一场创作的大爆发。我先在在使用 Habitica，而我也想不出会有什么原因会让我停下来不用它，大概会一直用下去吧，在名为「the Road of Life」的游戏中继续升级打怪。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"碎片式学习\"><a href=\"#碎片式学习\" class=\"headerlink\" title=\"碎片式学习\"></a>碎片式学习</h2><p>最近花了￥30买了 Reeder，一个 RSS 阅读应用。用起来，左划右划的快捷操作，可以按照时间顺序排列的 feed，黑白风的 UI，各方面都要比 Feedly 出色。一个好的软件和应用，交互的好坏直接决定了你打开它的次数。显然，我更愿意打开 Reeder，甚至愿意直接在 Reeder 进行阅读。而以往所有的阅读活动都是在稍后读应用中进行的。但是在我用了有将近两年的 RSS 工具，我都没有意识到，这样的一种阅读活动，其实不比微博，twitter，高出多少，本质依然是碎片式的学习，碎片式的阅读，其内容来源也都是来自互联网快速烘焙的产品，哪怕依靠大厂，哪怕是 New Yorker，the economist，每篇文章的保存时间会有多久呢？","more":"思来想去，这些互联网上的内容服务，最合适的内容形式还是「新闻」，「泛科普」以及「情感类」或「针砭时弊」类文章。所以，也是在最近，就在买了 Reeder 应用之后，才开始注意到碎片式的学习给自己带来的种种消极影响。以前都不曾注意。在知乎问题「<a href=\"https://www.zhihu.com/question/20238280/answer/81597965\">碎片化学习的意义？碎片化学习的原因？碎片化学习的最终目标？</a>」中，排名第一的答案这样评价碎片式学习的：</p>\n<blockquote>\n<p>碎片化知识通过连续的新鲜内容，不断刺激你的大脑，让你始终处于「啊！又知道了新的东西」的喜悦中，从而难以自拔，这也就是我们难以抑制刷微博、刷朋友圈的缘故，因为我们只需要付出很少，就可以沉浸在「获得了新东西」的刺激里面。**–V弦上的咏叹调**</p>\n</blockquote>\n<h2 id=\"RSS-使用指导\"><a href=\"#RSS-使用指导\" class=\"headerlink\" title=\"RSS 使用指导\"></a>RSS 使用指导</h2><p>在思考 RSS 功用时自然想到了所谓「浅层阅读」和「深层阅读」的问题，自己在笔记里关于这两种阅读是这样描述的：</p>\n<blockquote>\n<p>关于最近所遇到的问题，微博，rss，微信，twitter，等等这些碎片化工具，只能占生活的 10 %， 它们只是用来调解学习和锻炼的，同时作为信息收集的重要工具。这里主要收集的信息是，有价值的书，电影，音乐。关于工作内容的消息，无人机领域的变化等等。对于收集来的信息进行二次加工和整理，要么放进 instapaper 阅读，主要是练习语言。要么是在 onenote 里写成文章发表等。但信息收集只占 10%，所以，RSS 的位置就等同于微博的位置，远没有达到系统学习高度。其余的 90% 就是系统化学习，全身心的，枯燥的，需要不停思考，不停练习，不停重复，不停 debug 的学习过程。这过程会很累。完成任务，或间隙休息调整，读读微博或者 RSS。</p>\n</blockquote>\n<p>所以 RSS 不是一个好的学习工具，它只是一个信息收集的工具。而它的信息收集功能其实也可以被其他更有效的工具代替。而当把 RSS 拿作语言学习，则又是另外一回事。作为语言学习的 RSS，则是正襟危坐的坐在电脑前，认认真真记录，理解所阅读的每一句外文信息，并不时摘录好词好句。而后还要不断复习背诵。作为语言学习时，其实跟是不是通过 RSS 获取文章，和使用 RSS 已经没有什么关系了。</p>\n<p>我在「少数派」看到了 JailbreakHum 对于 RSS 的这样的描述：</p>\n<blockquote>\n<p>但 RSS 不是这样的，RSS 重，真正的 RSS 使用者只会因为一个网站产出的大部分内容乃至频率都合自己口味，不想错过哪怕一条可能对自己有用的文章才会去订阅。我们订阅这样的网站，就是为了能够篇篇不漏地看这个网站产出的内容，起码要看标题。所以，就需要「未读数」来提醒我们有多少篇还没读，不清空未读数，我们会有一种压力和负罪感，我们会觉得该吸收的东西没有吸收到。**–JailbreakHum**</p>\n</blockquote>\n<p>于是我就把我订阅的那些更新频率高的，自己基本很少打开看，或者本身兴趣不大的，都 unfollow 了。确实，RSS 里只适合订阅哪些你本人相当熟悉，不愿意错过每一篇文章的源。而不适合订阅那些更新频率相当高，自己又不熟悉的源。</p>\n<h2 id=\"浅层阅读与深层阅读\"><a href=\"#浅层阅读与深层阅读\" class=\"headerlink\" title=\"浅层阅读与深层阅读\"></a>浅层阅读与深层阅读</h2><p>所以一般的阅读，我想能够分三个维度去考量：</p>\n<ul>\n<li>浅层阅读 - 微博，微信，RSS </li>\n<li>深层阅读 - 小说，非虚构类文学，严肃文学，实体书，instapaper （有时兼顾语言学习之用）</li>\n<li>专业学习的阅读 - 专业书籍，需要不断推演，思考，画重点，作笔记，并在之后不断回顾复习</li>\n</ul>\n<p>浅层阅读，不经过大脑，浏览关键字，主要思考信息是否有认真阅读的价值，这也是信息爆炸时代最基本的特。浅层，深层，专业系统化学习，其各自时间应该控制在 1:3:6 的比例。浅层阅读主要在移动设备上进行，深层阅读部分在平板，部分需要深度处理的内容在电脑上。专业只是学习需要，平板和电脑配合使用。平板作为辅助工具。</p>\n<p>要对抗碎片划的学习，因为碎片化意味着不系统，意味着浮于表面，意味着如果长时间投入就是浪费时间。所以碎片化阅读最好的方式就是利用活动与活动的间隙进行。</p>\n<h2 id=\"Habitica-带来的启示\"><a href=\"#Habitica-带来的启示\" class=\"headerlink\" title=\"Habitica 带来的启示\"></a>Habitica 带来的启示</h2><p>在知乎上看到的，之所以会感到信息爆炸，</p>\n<ul>\n<li>一，是目标不够明确，目标明确，找到的信息都是自己需要的信息，不会觉得信息很多。</li>\n<li>二，是爱不深，兴趣不够。综合来看，应该尽量限制自己的兴趣，同时加强在专业方面的学习。</li>\n</ul>\n<p>对于第一点，自己最近在使用 <a href=\"https://habitica.com/\">Habitica</a> 时也是深有体会。Habitica 是一款把 to do list 这种效率软件包装成 RPG 游戏的应用。整体设计游戏化做的非常棒，在使用的过程中，自己也渐渐发现目标是非常重要的。以前人们常说，什么什么需要坚持，需要有毅力。在不断地失败又实践的过程中，我渐渐发现所谓的「坚持」不过是事情的结果，而不是事情的原因。我们对某件事的坚持，是因为我们有坚持它的动力，有目标，能坚持。而一般的效率软件则是帮助人们来找到目标的。而 Habitica 之所以比一般的效率软件好，就在与它的游戏化人生的概念。其实人生本身就是一场 RPG 角色扮演游戏。</p>\n<p><img src=\"https://s-media-cache-ak0.pinimg.com/564x/de/99/d3/de99d3be6709eecc9ad13f762db29cd1.jpg\"></p>\n<p>今天是二〇一七年的第五天，我相信对于我，这一年一定会迎来一场创作的大爆发。我先在在使用 Habitica，而我也想不出会有什么原因会让我停下来不用它，大概会一直用下去吧，在名为「the Road of Life」的游戏中继续升级打怪。</p>"},{"title":"Habitica 的量化人生","date":"2017-04-15T15:06:27.000Z","_content":"\n从去年十二月开始，自己一直在使用一款效率软件 Habitica 来进行管理生活。本来我已经对所有 to-do 类的效率应用都失去信心了。Habitica 别出心裁的「游戏化」概念真的戳中痛点。这也是它能够在众多效率类应用中有着明显区分度的原因。而在使用了几个月之后，我发现这种「游戏化」是一种很好的量化工具。它把你生活中大大小小的事件，量化为不同的价值。这样的价值则是通过「经验」、「金币」、「魔法值」、「生命值」来进行体现的。\n<!-- more -->\n\n![intro](/images/intro.jpg)\n<br>\n\n## 量化机制\n\nHabitica 的量化系统里有四个关键要素：\n\n- 生命值\n- 经验\n- 魔法值\n- 金币\n\n\n\n![value1](/images/value1.png)\n<br>\n![value2](/images/value2.png)\n<br>\n在 Habitica 的设定中，生命值永远都是 50，而升级所需要的经验值，则随着等级的增加而增加。因为升级补满生命值，而当生命值耗完，就会被降一级，并且丢失所有金币，以及随机丢失一些装备。这样下来，随着等级的增加，每升一级所需的经验值就越高，而生命值是不变的，这样难度是逐渐增加的。\n\n「生命值」可以理解为短期内的生活状态，如果短期内，生命值一直保持满血，未受到任何伤害，可以认为在最近一段时间内，在工作，学习或生活中保持一个比较高的效率。\n\n ![exp](/images/exp.png)\n<br>\n「经验值」可以反映一个较长时间段内工作状态变化。因为每天经验值都会增加，每天增加的量都是不一样的。有时候因为耗完「生命值」，「经验值」也会下降。这样通过观察「经验值-时间」曲线，就可以得出一段较长时间内工作学习效率的变化情况，并根据曲线适时进行调整。这样的工作状态是通过曲线的斜率反映出来的。斜率 $ k=\\Delta Exp/\\Delta t $ 的值越大，则表示该时间点 (更准确是当日) 的工作状态，效率越高。\n\n「魔法值」这一要素只有在触发技能时候才会起作用。而技能又与职业挂钩。Habitica 在十级以后又四个职业可以选，每种职业侧重不同，但都是为增加游戏化的趣味性。包括设计出 boss 战系统，各式装备。理论上都是游戏化中很重要的一环，但是本文主要讨论其中的「量化」概念，所以在此略过。\n\n「金币」这一要素是和 Habitica 里的奖励系统 ( Reward ) 有关联的。所以「金币」这一量其实是联系努力和休息消遣的重要桥梁。譬如我今天读了 30 页的书，获得 10 枚金币，而这 10 枚金币在奖励系统里刚好可以让我刷半个小时的微博。透过 Habitica 里的「金币」概念真正让你生活中经历的种种事件，有了具体的价值。当然，我们讨论价值，永远都在讨论它的相对意义，而非绝对意义。因为讨论一个事件价值的绝对意义就上升到了哲学领域。\n\n## FAQ\n以下简单说一下几个我在实践 Habitica 里碰到的几个问题\n\n**如何定义事件，习惯，怎样标记习惯的完成?**<br>\n在「习惯系统」里，我们往往要定义一件通用性的事件来作为习惯。当然可以通过定义阅读 10 页来作为一个习惯，而我一般通过时间来进行量化。比如写作，则根据写作的时长，定义每二十分钟记一次正向习惯，这样根据写作投入的时长来获取等量的报酬，经验，金币。同理，在设置「学习」，「阅读」习惯时也是一样。\n\n**在奖励系统里如何定义  Reward?**<br>\n我最初几乎对每一个休息消遣的事件，都定义一个 Reward，比如刷微博 10 金币，刷朋友圈 5 金币，看电影 30 金币。这样一下定义了七八个事件，而且还是有很多事件没有覆盖掉。甚至有时候，我可能又刷微博，又刷朋友圈。在实践中并不好处理。而我希望我的系统要尽量简化。所以我把上述事件全部去掉，只添加两个 Reward，，依旧通过时间进行量化，一个写作「劳逸结合」，规定 10 金币休息 25 分钟，25 分钟内可以做任何想做的事情。另一个写作「要颓废了」，规定 50 金币休息 150 分钟。\n\n![Reward](/images/Reward.png)","source":"_posts/I-O-21-Habitica 的量化人生.md","raw":"---\ntitle: 'Habitica 的量化人生'\ndate: 2017-04-15 23:06:27\ntags: \n\ncategories: \"I/O\"\n---\n\n从去年十二月开始，自己一直在使用一款效率软件 Habitica 来进行管理生活。本来我已经对所有 to-do 类的效率应用都失去信心了。Habitica 别出心裁的「游戏化」概念真的戳中痛点。这也是它能够在众多效率类应用中有着明显区分度的原因。而在使用了几个月之后，我发现这种「游戏化」是一种很好的量化工具。它把你生活中大大小小的事件，量化为不同的价值。这样的价值则是通过「经验」、「金币」、「魔法值」、「生命值」来进行体现的。\n<!-- more -->\n\n![intro](/images/intro.jpg)\n<br>\n\n## 量化机制\n\nHabitica 的量化系统里有四个关键要素：\n\n- 生命值\n- 经验\n- 魔法值\n- 金币\n\n\n\n![value1](/images/value1.png)\n<br>\n![value2](/images/value2.png)\n<br>\n在 Habitica 的设定中，生命值永远都是 50，而升级所需要的经验值，则随着等级的增加而增加。因为升级补满生命值，而当生命值耗完，就会被降一级，并且丢失所有金币，以及随机丢失一些装备。这样下来，随着等级的增加，每升一级所需的经验值就越高，而生命值是不变的，这样难度是逐渐增加的。\n\n「生命值」可以理解为短期内的生活状态，如果短期内，生命值一直保持满血，未受到任何伤害，可以认为在最近一段时间内，在工作，学习或生活中保持一个比较高的效率。\n\n ![exp](/images/exp.png)\n<br>\n「经验值」可以反映一个较长时间段内工作状态变化。因为每天经验值都会增加，每天增加的量都是不一样的。有时候因为耗完「生命值」，「经验值」也会下降。这样通过观察「经验值-时间」曲线，就可以得出一段较长时间内工作学习效率的变化情况，并根据曲线适时进行调整。这样的工作状态是通过曲线的斜率反映出来的。斜率 $ k=\\Delta Exp/\\Delta t $ 的值越大，则表示该时间点 (更准确是当日) 的工作状态，效率越高。\n\n「魔法值」这一要素只有在触发技能时候才会起作用。而技能又与职业挂钩。Habitica 在十级以后又四个职业可以选，每种职业侧重不同，但都是为增加游戏化的趣味性。包括设计出 boss 战系统，各式装备。理论上都是游戏化中很重要的一环，但是本文主要讨论其中的「量化」概念，所以在此略过。\n\n「金币」这一要素是和 Habitica 里的奖励系统 ( Reward ) 有关联的。所以「金币」这一量其实是联系努力和休息消遣的重要桥梁。譬如我今天读了 30 页的书，获得 10 枚金币，而这 10 枚金币在奖励系统里刚好可以让我刷半个小时的微博。透过 Habitica 里的「金币」概念真正让你生活中经历的种种事件，有了具体的价值。当然，我们讨论价值，永远都在讨论它的相对意义，而非绝对意义。因为讨论一个事件价值的绝对意义就上升到了哲学领域。\n\n## FAQ\n以下简单说一下几个我在实践 Habitica 里碰到的几个问题\n\n**如何定义事件，习惯，怎样标记习惯的完成?**<br>\n在「习惯系统」里，我们往往要定义一件通用性的事件来作为习惯。当然可以通过定义阅读 10 页来作为一个习惯，而我一般通过时间来进行量化。比如写作，则根据写作的时长，定义每二十分钟记一次正向习惯，这样根据写作投入的时长来获取等量的报酬，经验，金币。同理，在设置「学习」，「阅读」习惯时也是一样。\n\n**在奖励系统里如何定义  Reward?**<br>\n我最初几乎对每一个休息消遣的事件，都定义一个 Reward，比如刷微博 10 金币，刷朋友圈 5 金币，看电影 30 金币。这样一下定义了七八个事件，而且还是有很多事件没有覆盖掉。甚至有时候，我可能又刷微博，又刷朋友圈。在实践中并不好处理。而我希望我的系统要尽量简化。所以我把上述事件全部去掉，只添加两个 Reward，，依旧通过时间进行量化，一个写作「劳逸结合」，规定 10 金币休息 25 分钟，25 分钟内可以做任何想做的事情。另一个写作「要颓废了」，规定 50 金币休息 150 分钟。\n\n![Reward](/images/Reward.png)","slug":"I-O-21-Habitica 的量化人生","published":1,"updated":"2019-01-23T01:48:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx260018rg1v3z08d6x2","content":"<p>从去年十二月开始，自己一直在使用一款效率软件 Habitica 来进行管理生活。本来我已经对所有 to-do 类的效率应用都失去信心了。Habitica 别出心裁的「游戏化」概念真的戳中痛点。这也是它能够在众多效率类应用中有着明显区分度的原因。而在使用了几个月之后，我发现这种「游戏化」是一种很好的量化工具。它把你生活中大大小小的事件，量化为不同的价值。这样的价值则是通过「经验」、「金币」、「魔法值」、「生命值」来进行体现的。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/images/intro.jpg\" alt=\"intro\"><br><br></p>\n<h2 id=\"量化机制\"><a href=\"#量化机制\" class=\"headerlink\" title=\"量化机制\"></a>量化机制</h2><p>Habitica 的量化系统里有四个关键要素：</p>\n<ul>\n<li>生命值</li>\n<li>经验</li>\n<li>魔法值</li>\n<li>金币</li>\n</ul>\n<p><img src=\"/images/value1.png\" alt=\"value1\"><br><br><br><img src=\"/images/value2.png\" alt=\"value2\"><br><br><br>在 Habitica 的设定中，生命值永远都是 50，而升级所需要的经验值，则随着等级的增加而增加。因为升级补满生命值，而当生命值耗完，就会被降一级，并且丢失所有金币，以及随机丢失一些装备。这样下来，随着等级的增加，每升一级所需的经验值就越高，而生命值是不变的，这样难度是逐渐增加的。</p>\n<p>「生命值」可以理解为短期内的生活状态，如果短期内，生命值一直保持满血，未受到任何伤害，可以认为在最近一段时间内，在工作，学习或生活中保持一个比较高的效率。</p>\n<p> <img src=\"/images/exp.png\" alt=\"exp\"><br><br><br>「经验值」可以反映一个较长时间段内工作状态变化。因为每天经验值都会增加，每天增加的量都是不一样的。有时候因为耗完「生命值」，「经验值」也会下降。这样通过观察「经验值-时间」曲线，就可以得出一段较长时间内工作学习效率的变化情况，并根据曲线适时进行调整。这样的工作状态是通过曲线的斜率反映出来的。斜率 $ k=\\Delta Exp/\\Delta t $ 的值越大，则表示该时间点 (更准确是当日) 的工作状态，效率越高。</p>\n<p>「魔法值」这一要素只有在触发技能时候才会起作用。而技能又与职业挂钩。Habitica 在十级以后又四个职业可以选，每种职业侧重不同，但都是为增加游戏化的趣味性。包括设计出 boss 战系统，各式装备。理论上都是游戏化中很重要的一环，但是本文主要讨论其中的「量化」概念，所以在此略过。</p>\n<p>「金币」这一要素是和 Habitica 里的奖励系统 ( Reward ) 有关联的。所以「金币」这一量其实是联系努力和休息消遣的重要桥梁。譬如我今天读了 30 页的书，获得 10 枚金币，而这 10 枚金币在奖励系统里刚好可以让我刷半个小时的微博。透过 Habitica 里的「金币」概念真正让你生活中经历的种种事件，有了具体的价值。当然，我们讨论价值，永远都在讨论它的相对意义，而非绝对意义。因为讨论一个事件价值的绝对意义就上升到了哲学领域。</p>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><p>以下简单说一下几个我在实践 Habitica 里碰到的几个问题</p>\n<p><strong>如何定义事件，习惯，怎样标记习惯的完成?</strong><br><br>在「习惯系统」里，我们往往要定义一件通用性的事件来作为习惯。当然可以通过定义阅读 10 页来作为一个习惯，而我一般通过时间来进行量化。比如写作，则根据写作的时长，定义每二十分钟记一次正向习惯，这样根据写作投入的时长来获取等量的报酬，经验，金币。同理，在设置「学习」，「阅读」习惯时也是一样。</p>\n<p><strong>在奖励系统里如何定义  Reward?</strong><br><br>我最初几乎对每一个休息消遣的事件，都定义一个 Reward，比如刷微博 10 金币，刷朋友圈 5 金币，看电影 30 金币。这样一下定义了七八个事件，而且还是有很多事件没有覆盖掉。甚至有时候，我可能又刷微博，又刷朋友圈。在实践中并不好处理。而我希望我的系统要尽量简化。所以我把上述事件全部去掉，只添加两个 Reward，，依旧通过时间进行量化，一个写作「劳逸结合」，规定 10 金币休息 25 分钟，25 分钟内可以做任何想做的事情。另一个写作「要颓废了」，规定 50 金币休息 150 分钟。</p>\n<p><img src=\"/images/Reward.png\" alt=\"Reward\"></p>\n","site":{"data":{}},"excerpt":"<p>从去年十二月开始，自己一直在使用一款效率软件 Habitica 来进行管理生活。本来我已经对所有 to-do 类的效率应用都失去信心了。Habitica 别出心裁的「游戏化」概念真的戳中痛点。这也是它能够在众多效率类应用中有着明显区分度的原因。而在使用了几个月之后，我发现这种「游戏化」是一种很好的量化工具。它把你生活中大大小小的事件，量化为不同的价值。这样的价值则是通过「经验」、「金币」、「魔法值」、「生命值」来进行体现的。</p>","more":"<p><img src=\"/images/intro.jpg\" alt=\"intro\"><br><br></p>\n<h2 id=\"量化机制\"><a href=\"#量化机制\" class=\"headerlink\" title=\"量化机制\"></a>量化机制</h2><p>Habitica 的量化系统里有四个关键要素：</p>\n<ul>\n<li>生命值</li>\n<li>经验</li>\n<li>魔法值</li>\n<li>金币</li>\n</ul>\n<p><img src=\"/images/value1.png\" alt=\"value1\"><br><br><br><img src=\"/images/value2.png\" alt=\"value2\"><br><br><br>在 Habitica 的设定中，生命值永远都是 50，而升级所需要的经验值，则随着等级的增加而增加。因为升级补满生命值，而当生命值耗完，就会被降一级，并且丢失所有金币，以及随机丢失一些装备。这样下来，随着等级的增加，每升一级所需的经验值就越高，而生命值是不变的，这样难度是逐渐增加的。</p>\n<p>「生命值」可以理解为短期内的生活状态，如果短期内，生命值一直保持满血，未受到任何伤害，可以认为在最近一段时间内，在工作，学习或生活中保持一个比较高的效率。</p>\n<p> <img src=\"/images/exp.png\" alt=\"exp\"><br><br><br>「经验值」可以反映一个较长时间段内工作状态变化。因为每天经验值都会增加，每天增加的量都是不一样的。有时候因为耗完「生命值」，「经验值」也会下降。这样通过观察「经验值-时间」曲线，就可以得出一段较长时间内工作学习效率的变化情况，并根据曲线适时进行调整。这样的工作状态是通过曲线的斜率反映出来的。斜率 $ k=\\Delta Exp/\\Delta t $ 的值越大，则表示该时间点 (更准确是当日) 的工作状态，效率越高。</p>\n<p>「魔法值」这一要素只有在触发技能时候才会起作用。而技能又与职业挂钩。Habitica 在十级以后又四个职业可以选，每种职业侧重不同，但都是为增加游戏化的趣味性。包括设计出 boss 战系统，各式装备。理论上都是游戏化中很重要的一环，但是本文主要讨论其中的「量化」概念，所以在此略过。</p>\n<p>「金币」这一要素是和 Habitica 里的奖励系统 ( Reward ) 有关联的。所以「金币」这一量其实是联系努力和休息消遣的重要桥梁。譬如我今天读了 30 页的书，获得 10 枚金币，而这 10 枚金币在奖励系统里刚好可以让我刷半个小时的微博。透过 Habitica 里的「金币」概念真正让你生活中经历的种种事件，有了具体的价值。当然，我们讨论价值，永远都在讨论它的相对意义，而非绝对意义。因为讨论一个事件价值的绝对意义就上升到了哲学领域。</p>\n<h2 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h2><p>以下简单说一下几个我在实践 Habitica 里碰到的几个问题</p>\n<p><strong>如何定义事件，习惯，怎样标记习惯的完成?</strong><br><br>在「习惯系统」里，我们往往要定义一件通用性的事件来作为习惯。当然可以通过定义阅读 10 页来作为一个习惯，而我一般通过时间来进行量化。比如写作，则根据写作的时长，定义每二十分钟记一次正向习惯，这样根据写作投入的时长来获取等量的报酬，经验，金币。同理，在设置「学习」，「阅读」习惯时也是一样。</p>\n<p><strong>在奖励系统里如何定义  Reward?</strong><br><br>我最初几乎对每一个休息消遣的事件，都定义一个 Reward，比如刷微博 10 金币，刷朋友圈 5 金币，看电影 30 金币。这样一下定义了七八个事件，而且还是有很多事件没有覆盖掉。甚至有时候，我可能又刷微博，又刷朋友圈。在实践中并不好处理。而我希望我的系统要尽量简化。所以我把上述事件全部去掉，只添加两个 Reward，，依旧通过时间进行量化，一个写作「劳逸结合」，规定 10 金币休息 25 分钟，25 分钟内可以做任何想做的事情。另一个写作「要颓废了」，规定 50 金币休息 150 分钟。</p>\n<p><img src=\"/images/Reward.png\" alt=\"Reward\"></p>"},{"title":"端午","date":"2017-05-31T15:59:17.000Z","_content":"## 关于端午的几段记忆\n\n其实现在想想，最后悔的大概是大学本科时代，没有像现在这样，对时间规划，时间管理有非常深的思考，没有在本科就把英文学得足够的好，没有在大一大二就开始接触播客，开始阅读英文教材。我每次站在现在去回望过去，都总会觉得过去的自己幼稚到不行，很难想象过去的自己在看着过去的过去的时候，也是一样的想法。\n\n时值端午。如果不是在社交网络上看到些许的关键词，远离中文社会很长时间的我是感受不到任何节日的气息的。我想分享几段个人关于端午的几段记忆，或许也是，关于端午我能想起来的全部事情。\n<!-- more -->\n记忆里所有关于端午的记忆，除去那篇『离骚』，总是和吃粽子有关。赛龙舟， 悬艾叶配香囊，在我们那个小地方都是见不到的。一般的粽子也都不是自家制作，都是购自街边的小摊贩。摊贩上一般是放一个盆，盆里盛着温水，盆上堆满一个个包好的粽子，都只有一种口味。那时候小学放学，步行回家，端午时节就有这些卖粽子的摊贩出现，有时候是母亲，有时候是自己，会去那里买一两个粽子来，摊主会把外面的艾叶取掉，然后是把一个不带艾叶的粽子用塑料袋装起来，就这样掂回家。在家中把没有艾叶的粽子放到盘子里，洒上白糖，就直接拿着勺子吃了。这在当时实在不是什么稀罕的食物，直到我可能离家很久之后吧。后来就有了速冻的粽子，记忆里比较深刻的是三全出过的一款「龙舟粽」，当时的他们的广告词我现在都还记得。有了速冻粽子之后，街边卖粽子的摊贩就很少了。也可能是我上了初中后，骑车上下学，对周围的事物不怎么留心了吧。后来的这种速冻粽子，经常冷不丁出现在家里的餐桌上，一年四季，并不是只有端午才能吃到了。通常是早餐，母亲煮粥的时候，会馏一个小粽子，或者咸鸭蛋。再者就是晚餐的时候，早上或者之前没有吃的会继续馏，直到一个粽子会被馏了很多次，表面的艾草颜色都有些斑驳了，因为每次都被人遗忘。\n\n高中就已经离家在外了。当时学业压力很重。三年一心做题，都没怎么关注过窗外事吧。每日的三餐都是在高中学校的食堂，除了周末能够去躺姥姥姥爷家，能吃几顿好吃的。端午那天，食堂的窗口会专门卖粽子，自己当时也会去买一个来吧，口味什么的都不重要了，只是作为一种节日上的重要的仪式吧。上了大学，大学第一年，二〇一二年，离第一代 iPhone 发布已经过去了五年时间，然而移动互联网还依然在风口。 当年拥有了第一款智能手机，也是从高中解放之后，进入大学总是一直在关注窗外事吧。也许是移动互联网兴起的缘故，这一年的端午节，突然就出现了「咸粽子」，并且在网上有了粽子版本的「甜咸之争」。而对于我从小都是吃的甜粽子长大的人，无疑是非常颠覆的。我在想，一定是移动互联网的兴起，才能让这样的「甜咸之争」迅速的传播。在以前，可能只是有少部分人同时知道甜粽子和咸粽子的存在。大部分一辈子只是生活在北方，或者大部分一辈子只是生活在南方的人，他们一辈子见到的粽子，可能就只有一种。哪怕其中的几个人偶然接触到了另一种的粽子，如果仅凭几个人之力，也是无法达到尽人皆知的社会性事件的。我上大学的第二年才第一次尝了咸粽子，肉馅的粽子。那时已经到了二〇一四年了，当时是在新校区的最后一个学期，那个学期自己要应付很多事情，学生会的工作，社团的排练，微软方面的任务，当时还在追求一个女生，所以成绩上几乎的大范围的溃败。这种溃败甚至已经波及到了体育课。我体育课选择的是篮球，在最后的上篮考试中成绩很差，需要在下一节课重新测试。于是我就只好在周内找一个时间去操场练球，当时叫了一个同学，也是大学难得的能聊得来的同学吧。叫他过来帮我传球，然后我接球三步上篮。这样练习了很久，都累了，旁边是「星天苑」的餐厅，我去那里买了俩粽子，其中一个买了一个肉馅的。这个肉馅的粽子一直被放到晚上十点，我回到寝室才把它吃了。嗯，那是第一次吃咸粽子。\n\n今年是二〇一七年，距离第一代 iPhone 发布都已经过去十年了。我兜兜转转已经毕业。毕业之后的一年里，没有找工作，没有读研究生，没有谈恋爱，没有旅行，也没有待在家里。跟很多好朋友，同学，朋友，也没能够频繁的保持联系。因为对门的张叔刚从国内回来，中午煮了四个粽子，他自己吃掉两个，给我留了两个。就在几个小时前，我自己其实有蒸好米饭，热了一个小菜，是中午去超市时买的。但米饭只吃了一点。把张叔留的两个粽子有在锅里煮了一下。第一个是咸粽子，夹的有蛋黄和牛肉，第二个是甜的，夹的是红枣。也是在剥去艾叶的时候，才突然想到从小到大的这些事情，才想起来把这些事情记下来。时值端午，如果不是在社交网络看到的些许关键词，我应该是不会意识到端午节的。今日在 twitter 上的 [Chih-Hao Tsai](https://twitter.com/hao520) 这样写道：\n\n>年節食俗可以休矣。我們早已過了那個平日吃不飽、過節吃到飽的時代。行為抽離原本的脈絡就蠢了。何不重建新習俗，例如運動，為節日帶來更多價值。\n\n可是，年节带来的远非饭桌上的食物。更是一个端由，能想起一些事情的端由，能约上心仪女子的一个端由，能够自我反思的端由，以及偷的半日清闲的端由。当我真的想着顺着「端午」这条线往前捋的时候，一个非常恐怖的事情是，大概十年前的事情都已经记得非常不清楚了，再久远些，十五年前，已经是完全模糊到什么也看不清了。这种模糊带来的可能就是看老照片时候的陌生和惊喜感，而当时拍下那一张张照片时自己当时的所思所想，已无法回溯。而文首提到的，每当我站在现在去观望过去的自己，总是觉得过去幼稚的不行。但有时候，幼稚也是感动，成熟也是妥协。\n\n***\n\n## 目前的状态以及之后的计划\n\n目前的个人状态还是很棒的，至少在时间管理的问题上，解决过去一两年自己都没能解决的问题。而且能真实的感到自己对时间的利用率成倍的增加。而未来的几个月，七月，八月，想把本科所学的东西好好整理整理，不想一毕业就把东西还给老师，最近找到了很多不错的外文教材，想借着这三个月时间好好读一读，把一些忘掉的知识，柯西，拉普拉斯等等都拾起来。","source":"_posts/I-O-22-端午.md","raw":"---\ntitle: '端午'\ndate: 2017-05-31 23:59:17\ntags:\ncategories: \n- \"I/O\"\n---\n## 关于端午的几段记忆\n\n其实现在想想，最后悔的大概是大学本科时代，没有像现在这样，对时间规划，时间管理有非常深的思考，没有在本科就把英文学得足够的好，没有在大一大二就开始接触播客，开始阅读英文教材。我每次站在现在去回望过去，都总会觉得过去的自己幼稚到不行，很难想象过去的自己在看着过去的过去的时候，也是一样的想法。\n\n时值端午。如果不是在社交网络上看到些许的关键词，远离中文社会很长时间的我是感受不到任何节日的气息的。我想分享几段个人关于端午的几段记忆，或许也是，关于端午我能想起来的全部事情。\n<!-- more -->\n记忆里所有关于端午的记忆，除去那篇『离骚』，总是和吃粽子有关。赛龙舟， 悬艾叶配香囊，在我们那个小地方都是见不到的。一般的粽子也都不是自家制作，都是购自街边的小摊贩。摊贩上一般是放一个盆，盆里盛着温水，盆上堆满一个个包好的粽子，都只有一种口味。那时候小学放学，步行回家，端午时节就有这些卖粽子的摊贩出现，有时候是母亲，有时候是自己，会去那里买一两个粽子来，摊主会把外面的艾叶取掉，然后是把一个不带艾叶的粽子用塑料袋装起来，就这样掂回家。在家中把没有艾叶的粽子放到盘子里，洒上白糖，就直接拿着勺子吃了。这在当时实在不是什么稀罕的食物，直到我可能离家很久之后吧。后来就有了速冻的粽子，记忆里比较深刻的是三全出过的一款「龙舟粽」，当时的他们的广告词我现在都还记得。有了速冻粽子之后，街边卖粽子的摊贩就很少了。也可能是我上了初中后，骑车上下学，对周围的事物不怎么留心了吧。后来的这种速冻粽子，经常冷不丁出现在家里的餐桌上，一年四季，并不是只有端午才能吃到了。通常是早餐，母亲煮粥的时候，会馏一个小粽子，或者咸鸭蛋。再者就是晚餐的时候，早上或者之前没有吃的会继续馏，直到一个粽子会被馏了很多次，表面的艾草颜色都有些斑驳了，因为每次都被人遗忘。\n\n高中就已经离家在外了。当时学业压力很重。三年一心做题，都没怎么关注过窗外事吧。每日的三餐都是在高中学校的食堂，除了周末能够去躺姥姥姥爷家，能吃几顿好吃的。端午那天，食堂的窗口会专门卖粽子，自己当时也会去买一个来吧，口味什么的都不重要了，只是作为一种节日上的重要的仪式吧。上了大学，大学第一年，二〇一二年，离第一代 iPhone 发布已经过去了五年时间，然而移动互联网还依然在风口。 当年拥有了第一款智能手机，也是从高中解放之后，进入大学总是一直在关注窗外事吧。也许是移动互联网兴起的缘故，这一年的端午节，突然就出现了「咸粽子」，并且在网上有了粽子版本的「甜咸之争」。而对于我从小都是吃的甜粽子长大的人，无疑是非常颠覆的。我在想，一定是移动互联网的兴起，才能让这样的「甜咸之争」迅速的传播。在以前，可能只是有少部分人同时知道甜粽子和咸粽子的存在。大部分一辈子只是生活在北方，或者大部分一辈子只是生活在南方的人，他们一辈子见到的粽子，可能就只有一种。哪怕其中的几个人偶然接触到了另一种的粽子，如果仅凭几个人之力，也是无法达到尽人皆知的社会性事件的。我上大学的第二年才第一次尝了咸粽子，肉馅的粽子。那时已经到了二〇一四年了，当时是在新校区的最后一个学期，那个学期自己要应付很多事情，学生会的工作，社团的排练，微软方面的任务，当时还在追求一个女生，所以成绩上几乎的大范围的溃败。这种溃败甚至已经波及到了体育课。我体育课选择的是篮球，在最后的上篮考试中成绩很差，需要在下一节课重新测试。于是我就只好在周内找一个时间去操场练球，当时叫了一个同学，也是大学难得的能聊得来的同学吧。叫他过来帮我传球，然后我接球三步上篮。这样练习了很久，都累了，旁边是「星天苑」的餐厅，我去那里买了俩粽子，其中一个买了一个肉馅的。这个肉馅的粽子一直被放到晚上十点，我回到寝室才把它吃了。嗯，那是第一次吃咸粽子。\n\n今年是二〇一七年，距离第一代 iPhone 发布都已经过去十年了。我兜兜转转已经毕业。毕业之后的一年里，没有找工作，没有读研究生，没有谈恋爱，没有旅行，也没有待在家里。跟很多好朋友，同学，朋友，也没能够频繁的保持联系。因为对门的张叔刚从国内回来，中午煮了四个粽子，他自己吃掉两个，给我留了两个。就在几个小时前，我自己其实有蒸好米饭，热了一个小菜，是中午去超市时买的。但米饭只吃了一点。把张叔留的两个粽子有在锅里煮了一下。第一个是咸粽子，夹的有蛋黄和牛肉，第二个是甜的，夹的是红枣。也是在剥去艾叶的时候，才突然想到从小到大的这些事情，才想起来把这些事情记下来。时值端午，如果不是在社交网络看到的些许关键词，我应该是不会意识到端午节的。今日在 twitter 上的 [Chih-Hao Tsai](https://twitter.com/hao520) 这样写道：\n\n>年節食俗可以休矣。我們早已過了那個平日吃不飽、過節吃到飽的時代。行為抽離原本的脈絡就蠢了。何不重建新習俗，例如運動，為節日帶來更多價值。\n\n可是，年节带来的远非饭桌上的食物。更是一个端由，能想起一些事情的端由，能约上心仪女子的一个端由，能够自我反思的端由，以及偷的半日清闲的端由。当我真的想着顺着「端午」这条线往前捋的时候，一个非常恐怖的事情是，大概十年前的事情都已经记得非常不清楚了，再久远些，十五年前，已经是完全模糊到什么也看不清了。这种模糊带来的可能就是看老照片时候的陌生和惊喜感，而当时拍下那一张张照片时自己当时的所思所想，已无法回溯。而文首提到的，每当我站在现在去观望过去的自己，总是觉得过去幼稚的不行。但有时候，幼稚也是感动，成熟也是妥协。\n\n***\n\n## 目前的状态以及之后的计划\n\n目前的个人状态还是很棒的，至少在时间管理的问题上，解决过去一两年自己都没能解决的问题。而且能真实的感到自己对时间的利用率成倍的增加。而未来的几个月，七月，八月，想把本科所学的东西好好整理整理，不想一毕业就把东西还给老师，最近找到了很多不错的外文教材，想借着这三个月时间好好读一读，把一些忘掉的知识，柯西，拉普拉斯等等都拾起来。","slug":"I-O-22-端午","published":1,"updated":"2019-01-20T09:32:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx26001crg1vaggfavxk","content":"<h2 id=\"关于端午的几段记忆\"><a href=\"#关于端午的几段记忆\" class=\"headerlink\" title=\"关于端午的几段记忆\"></a>关于端午的几段记忆</h2><p>其实现在想想，最后悔的大概是大学本科时代，没有像现在这样，对时间规划，时间管理有非常深的思考，没有在本科就把英文学得足够的好，没有在大一大二就开始接触播客，开始阅读英文教材。我每次站在现在去回望过去，都总会觉得过去的自己幼稚到不行，很难想象过去的自己在看着过去的过去的时候，也是一样的想法。</p>\n<p>时值端午。如果不是在社交网络上看到些许的关键词，远离中文社会很长时间的我是感受不到任何节日的气息的。我想分享几段个人关于端午的几段记忆，或许也是，关于端午我能想起来的全部事情。</p>\n<span id=\"more\"></span>\n<p>记忆里所有关于端午的记忆，除去那篇『离骚』，总是和吃粽子有关。赛龙舟， 悬艾叶配香囊，在我们那个小地方都是见不到的。一般的粽子也都不是自家制作，都是购自街边的小摊贩。摊贩上一般是放一个盆，盆里盛着温水，盆上堆满一个个包好的粽子，都只有一种口味。那时候小学放学，步行回家，端午时节就有这些卖粽子的摊贩出现，有时候是母亲，有时候是自己，会去那里买一两个粽子来，摊主会把外面的艾叶取掉，然后是把一个不带艾叶的粽子用塑料袋装起来，就这样掂回家。在家中把没有艾叶的粽子放到盘子里，洒上白糖，就直接拿着勺子吃了。这在当时实在不是什么稀罕的食物，直到我可能离家很久之后吧。后来就有了速冻的粽子，记忆里比较深刻的是三全出过的一款「龙舟粽」，当时的他们的广告词我现在都还记得。有了速冻粽子之后，街边卖粽子的摊贩就很少了。也可能是我上了初中后，骑车上下学，对周围的事物不怎么留心了吧。后来的这种速冻粽子，经常冷不丁出现在家里的餐桌上，一年四季，并不是只有端午才能吃到了。通常是早餐，母亲煮粥的时候，会馏一个小粽子，或者咸鸭蛋。再者就是晚餐的时候，早上或者之前没有吃的会继续馏，直到一个粽子会被馏了很多次，表面的艾草颜色都有些斑驳了，因为每次都被人遗忘。</p>\n<p>高中就已经离家在外了。当时学业压力很重。三年一心做题，都没怎么关注过窗外事吧。每日的三餐都是在高中学校的食堂，除了周末能够去躺姥姥姥爷家，能吃几顿好吃的。端午那天，食堂的窗口会专门卖粽子，自己当时也会去买一个来吧，口味什么的都不重要了，只是作为一种节日上的重要的仪式吧。上了大学，大学第一年，二〇一二年，离第一代 iPhone 发布已经过去了五年时间，然而移动互联网还依然在风口。 当年拥有了第一款智能手机，也是从高中解放之后，进入大学总是一直在关注窗外事吧。也许是移动互联网兴起的缘故，这一年的端午节，突然就出现了「咸粽子」，并且在网上有了粽子版本的「甜咸之争」。而对于我从小都是吃的甜粽子长大的人，无疑是非常颠覆的。我在想，一定是移动互联网的兴起，才能让这样的「甜咸之争」迅速的传播。在以前，可能只是有少部分人同时知道甜粽子和咸粽子的存在。大部分一辈子只是生活在北方，或者大部分一辈子只是生活在南方的人，他们一辈子见到的粽子，可能就只有一种。哪怕其中的几个人偶然接触到了另一种的粽子，如果仅凭几个人之力，也是无法达到尽人皆知的社会性事件的。我上大学的第二年才第一次尝了咸粽子，肉馅的粽子。那时已经到了二〇一四年了，当时是在新校区的最后一个学期，那个学期自己要应付很多事情，学生会的工作，社团的排练，微软方面的任务，当时还在追求一个女生，所以成绩上几乎的大范围的溃败。这种溃败甚至已经波及到了体育课。我体育课选择的是篮球，在最后的上篮考试中成绩很差，需要在下一节课重新测试。于是我就只好在周内找一个时间去操场练球，当时叫了一个同学，也是大学难得的能聊得来的同学吧。叫他过来帮我传球，然后我接球三步上篮。这样练习了很久，都累了，旁边是「星天苑」的餐厅，我去那里买了俩粽子，其中一个买了一个肉馅的。这个肉馅的粽子一直被放到晚上十点，我回到寝室才把它吃了。嗯，那是第一次吃咸粽子。</p>\n<p>今年是二〇一七年，距离第一代 iPhone 发布都已经过去十年了。我兜兜转转已经毕业。毕业之后的一年里，没有找工作，没有读研究生，没有谈恋爱，没有旅行，也没有待在家里。跟很多好朋友，同学，朋友，也没能够频繁的保持联系。因为对门的张叔刚从国内回来，中午煮了四个粽子，他自己吃掉两个，给我留了两个。就在几个小时前，我自己其实有蒸好米饭，热了一个小菜，是中午去超市时买的。但米饭只吃了一点。把张叔留的两个粽子有在锅里煮了一下。第一个是咸粽子，夹的有蛋黄和牛肉，第二个是甜的，夹的是红枣。也是在剥去艾叶的时候，才突然想到从小到大的这些事情，才想起来把这些事情记下来。时值端午，如果不是在社交网络看到的些许关键词，我应该是不会意识到端午节的。今日在 twitter 上的 <a href=\"https://twitter.com/hao520\">Chih-Hao Tsai</a> 这样写道：</p>\n<blockquote>\n<p>年節食俗可以休矣。我們早已過了那個平日吃不飽、過節吃到飽的時代。行為抽離原本的脈絡就蠢了。何不重建新習俗，例如運動，為節日帶來更多價值。</p>\n</blockquote>\n<p>可是，年节带来的远非饭桌上的食物。更是一个端由，能想起一些事情的端由，能约上心仪女子的一个端由，能够自我反思的端由，以及偷的半日清闲的端由。当我真的想着顺着「端午」这条线往前捋的时候，一个非常恐怖的事情是，大概十年前的事情都已经记得非常不清楚了，再久远些，十五年前，已经是完全模糊到什么也看不清了。这种模糊带来的可能就是看老照片时候的陌生和惊喜感，而当时拍下那一张张照片时自己当时的所思所想，已无法回溯。而文首提到的，每当我站在现在去观望过去的自己，总是觉得过去幼稚的不行。但有时候，幼稚也是感动，成熟也是妥协。</p>\n<hr>\n<h2 id=\"目前的状态以及之后的计划\"><a href=\"#目前的状态以及之后的计划\" class=\"headerlink\" title=\"目前的状态以及之后的计划\"></a>目前的状态以及之后的计划</h2><p>目前的个人状态还是很棒的，至少在时间管理的问题上，解决过去一两年自己都没能解决的问题。而且能真实的感到自己对时间的利用率成倍的增加。而未来的几个月，七月，八月，想把本科所学的东西好好整理整理，不想一毕业就把东西还给老师，最近找到了很多不错的外文教材，想借着这三个月时间好好读一读，把一些忘掉的知识，柯西，拉普拉斯等等都拾起来。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于端午的几段记忆\"><a href=\"#关于端午的几段记忆\" class=\"headerlink\" title=\"关于端午的几段记忆\"></a>关于端午的几段记忆</h2><p>其实现在想想，最后悔的大概是大学本科时代，没有像现在这样，对时间规划，时间管理有非常深的思考，没有在本科就把英文学得足够的好，没有在大一大二就开始接触播客，开始阅读英文教材。我每次站在现在去回望过去，都总会觉得过去的自己幼稚到不行，很难想象过去的自己在看着过去的过去的时候，也是一样的想法。</p>\n<p>时值端午。如果不是在社交网络上看到些许的关键词，远离中文社会很长时间的我是感受不到任何节日的气息的。我想分享几段个人关于端午的几段记忆，或许也是，关于端午我能想起来的全部事情。</p>","more":"<p>记忆里所有关于端午的记忆，除去那篇『离骚』，总是和吃粽子有关。赛龙舟， 悬艾叶配香囊，在我们那个小地方都是见不到的。一般的粽子也都不是自家制作，都是购自街边的小摊贩。摊贩上一般是放一个盆，盆里盛着温水，盆上堆满一个个包好的粽子，都只有一种口味。那时候小学放学，步行回家，端午时节就有这些卖粽子的摊贩出现，有时候是母亲，有时候是自己，会去那里买一两个粽子来，摊主会把外面的艾叶取掉，然后是把一个不带艾叶的粽子用塑料袋装起来，就这样掂回家。在家中把没有艾叶的粽子放到盘子里，洒上白糖，就直接拿着勺子吃了。这在当时实在不是什么稀罕的食物，直到我可能离家很久之后吧。后来就有了速冻的粽子，记忆里比较深刻的是三全出过的一款「龙舟粽」，当时的他们的广告词我现在都还记得。有了速冻粽子之后，街边卖粽子的摊贩就很少了。也可能是我上了初中后，骑车上下学，对周围的事物不怎么留心了吧。后来的这种速冻粽子，经常冷不丁出现在家里的餐桌上，一年四季，并不是只有端午才能吃到了。通常是早餐，母亲煮粥的时候，会馏一个小粽子，或者咸鸭蛋。再者就是晚餐的时候，早上或者之前没有吃的会继续馏，直到一个粽子会被馏了很多次，表面的艾草颜色都有些斑驳了，因为每次都被人遗忘。</p>\n<p>高中就已经离家在外了。当时学业压力很重。三年一心做题，都没怎么关注过窗外事吧。每日的三餐都是在高中学校的食堂，除了周末能够去躺姥姥姥爷家，能吃几顿好吃的。端午那天，食堂的窗口会专门卖粽子，自己当时也会去买一个来吧，口味什么的都不重要了，只是作为一种节日上的重要的仪式吧。上了大学，大学第一年，二〇一二年，离第一代 iPhone 发布已经过去了五年时间，然而移动互联网还依然在风口。 当年拥有了第一款智能手机，也是从高中解放之后，进入大学总是一直在关注窗外事吧。也许是移动互联网兴起的缘故，这一年的端午节，突然就出现了「咸粽子」，并且在网上有了粽子版本的「甜咸之争」。而对于我从小都是吃的甜粽子长大的人，无疑是非常颠覆的。我在想，一定是移动互联网的兴起，才能让这样的「甜咸之争」迅速的传播。在以前，可能只是有少部分人同时知道甜粽子和咸粽子的存在。大部分一辈子只是生活在北方，或者大部分一辈子只是生活在南方的人，他们一辈子见到的粽子，可能就只有一种。哪怕其中的几个人偶然接触到了另一种的粽子，如果仅凭几个人之力，也是无法达到尽人皆知的社会性事件的。我上大学的第二年才第一次尝了咸粽子，肉馅的粽子。那时已经到了二〇一四年了，当时是在新校区的最后一个学期，那个学期自己要应付很多事情，学生会的工作，社团的排练，微软方面的任务，当时还在追求一个女生，所以成绩上几乎的大范围的溃败。这种溃败甚至已经波及到了体育课。我体育课选择的是篮球，在最后的上篮考试中成绩很差，需要在下一节课重新测试。于是我就只好在周内找一个时间去操场练球，当时叫了一个同学，也是大学难得的能聊得来的同学吧。叫他过来帮我传球，然后我接球三步上篮。这样练习了很久，都累了，旁边是「星天苑」的餐厅，我去那里买了俩粽子，其中一个买了一个肉馅的。这个肉馅的粽子一直被放到晚上十点，我回到寝室才把它吃了。嗯，那是第一次吃咸粽子。</p>\n<p>今年是二〇一七年，距离第一代 iPhone 发布都已经过去十年了。我兜兜转转已经毕业。毕业之后的一年里，没有找工作，没有读研究生，没有谈恋爱，没有旅行，也没有待在家里。跟很多好朋友，同学，朋友，也没能够频繁的保持联系。因为对门的张叔刚从国内回来，中午煮了四个粽子，他自己吃掉两个，给我留了两个。就在几个小时前，我自己其实有蒸好米饭，热了一个小菜，是中午去超市时买的。但米饭只吃了一点。把张叔留的两个粽子有在锅里煮了一下。第一个是咸粽子，夹的有蛋黄和牛肉，第二个是甜的，夹的是红枣。也是在剥去艾叶的时候，才突然想到从小到大的这些事情，才想起来把这些事情记下来。时值端午，如果不是在社交网络看到的些许关键词，我应该是不会意识到端午节的。今日在 twitter 上的 <a href=\"https://twitter.com/hao520\">Chih-Hao Tsai</a> 这样写道：</p>\n<blockquote>\n<p>年節食俗可以休矣。我們早已過了那個平日吃不飽、過節吃到飽的時代。行為抽離原本的脈絡就蠢了。何不重建新習俗，例如運動，為節日帶來更多價值。</p>\n</blockquote>\n<p>可是，年节带来的远非饭桌上的食物。更是一个端由，能想起一些事情的端由，能约上心仪女子的一个端由，能够自我反思的端由，以及偷的半日清闲的端由。当我真的想着顺着「端午」这条线往前捋的时候，一个非常恐怖的事情是，大概十年前的事情都已经记得非常不清楚了，再久远些，十五年前，已经是完全模糊到什么也看不清了。这种模糊带来的可能就是看老照片时候的陌生和惊喜感，而当时拍下那一张张照片时自己当时的所思所想，已无法回溯。而文首提到的，每当我站在现在去观望过去的自己，总是觉得过去幼稚的不行。但有时候，幼稚也是感动，成熟也是妥协。</p>\n<hr>\n<h2 id=\"目前的状态以及之后的计划\"><a href=\"#目前的状态以及之后的计划\" class=\"headerlink\" title=\"目前的状态以及之后的计划\"></a>目前的状态以及之后的计划</h2><p>目前的个人状态还是很棒的，至少在时间管理的问题上，解决过去一两年自己都没能解决的问题。而且能真实的感到自己对时间的利用率成倍的增加。而未来的几个月，七月，八月，想把本科所学的东西好好整理整理，不想一毕业就把东西还给老师，最近找到了很多不错的外文教材，想借着这三个月时间好好读一读，把一些忘掉的知识，柯西，拉普拉斯等等都拾起来。</p>"},{"title":"「骑着白马入地狱，叼着纸烟进天堂」","date":"2017-09-10T15:57:00.000Z","_content":"\n- 這一年在德國的生活回顧\n- 『孤獨指南』\n- 直播節目，心理療傷，自我慰藉\n- 語言學習的瓶頸\n- 當學習少了儀式感\n\n## 畢業一年\n\n來之前，沒曾想到自己會在德語考試上停留這麼久。\n\n二〇一六年九月到二〇一七年九月。\n\n二〇一六年九月底到德國，處理很多事情，落戶，銀行卡，房屋合同，保險，找房，還有房屋的衛生問題，自己又盲目的報名了十一月份的考試，當時由於整個大四下忙於畢設，疏於德語的學習，等我到德國時，德語退步很大，加上剛來的不適應，十一月考試結果特別差。然後十二月找房，一月份搬入新家。二月份的時候又考了一次，結果較上次有很大進步，到三月份，自己在 Tandem 的六個月語言課程結束，然後是面臨四月的考試，那時的狀態也是最焦慮，最混亂的，當時覺得如果考試考不過就全完了，巨大的壓力和焦慮也導致了考前複習的極度混亂，甚至一度的通過上網來麻痺自己，緩解焦慮，清楚的記得考前的一晚都還在看著 BiliBili 網站的視頻，想要逃避現實。四月底的那次考試考完，反倒讓我開始反思自己的學習模式，然後是五月份自己開始了極度自律的一個月，每週統計，效率上很高，直到六月二號開始，黃同學的到來，我那極度自律的狀態也隨即結束了。從六月二號到六月十四號又回到考前的極度緊張和焦慮，加之考前一天得知四月的考試結果，頂着巨大的壓力和焦慮又去考了六月那一場。雖然五月份自己極度的自律地在複習，但複習方向以聽力，口語為主，沒有很集中的背單詞和準備句式，考試最終還是在寫作上吃了虧。\n\n<!--more-->\n\n好吧，到此為止，算是經歷的最大的磨難了麼？還不是。六月下旬開始申請學校，直到六月底，算是把三所學校的材料都寄了出去。七月開始，德語的學習是學學停停，然後抽時間看看書，練習練習編程，做一做算法題，看了Dunkirk 電影，但時間上並沒有像五月那樣極度的自律，而是一種比較輕鬆的狀態，到七月底，也可能是受周圍同學的影響吧，狀態差到，在我過去二十三年都前所未有。好友黃同學已經收到幾個學校的錄取了，另一位比我來德國還要晚一些的白同學，六月份的考試成功通過了。好吧，當時我在想，已經在德國九個月了，畢業已經一年了。我當時的房屋合同是到八月底，而我當時的簽證是到九月二十號，我原本計劃是拿到學校錄取後延簽。而如果我拿不到學校錄取，我覺我是時候「滾」回去了。\n\n諸位可能沒法感同身受我當時的心情。對了，來德國之後，和國內的朋友同學都不怎麼聯繫了，唯獨胡小姐，偶有交谈，甚至還會打電話打很長時間，五月份還一起讀書，在一個軟件裏相互交換閱讀讀書筆記來着，六月份因爲一次不愉快的聊天，就相互刪除了聯繫方式。胡小姐和我之間的故事，若展開來講，估計可以寫一本小說了。當然我也並不是第一次被胡小姐從聯繫人刪除，只是，因爲當時的狀態，我個人單方面也不想再有聯繫了。於是我把朋友圈關了，我把「通過任何帳號加我爲好友」的功能關掉，這樣就不會有任何人能加到我了。\n\n七月底開始到八月十五號拿到第一個學校的錄取，這中間我經歷了人生的第一次 limbo。我不知道在哪，不知道要幹嘛，沒有任何信心去想象明天。耳朵裏一直插着耳機，放着人聲。最初的幾天是每天都在失眠，我不得不看一些無關的信息來分散我的注意力，支撐到身體撐不下去的時候，才能夠睡着，然而等待我的又是一個又一個噩夢。無論夢到什麼，對我來說都是一個噩夢。夢到故鄉，好友，夢到往日的榮光和失敗。於是，看電子屏幕久了，眼睛會痛，因爲我很早就有慢性結膜炎。耳機放耳朵裏久了，耳朵也會痛，有可能是細菌發炎什麼的，總之掏耳朵時痛的不行。最痛苦的時候，一個人躺在床上，眼睛疼痛的淚流不止，耳朵裏一直帶着耳機，裏面傳出人聲。\n\n而這所有的一切，都找不到一個人來講，不能和父母講，因爲不能讓他們擔心。朋友裏唯一能與之傾訴的人，已經刪除了聯繫人，自己單方面也不想再去聯繫。我單方面的斷絕所有的社交聯繫，譬如關朋友圈，儘量少的和任何人接觸，這些其實是當時極度脆弱的自己，對自我的一種保護。\n\n後來自己思考，任何的痛苦和黑暗都不是永久的。總會過去。八月中旬之後事情才有轉機。拿到第一個學校的錄取後就是開始着手延簽，着手延期房屋合同，去外觀局整夜排隊。考試報名，複習，預訂車票，找住處，考試，到今天，已經考完了 KIT 的 DSH 筆試部分。\n\n是不是每個人人生中都要經歷這樣一場最痛苦的絕望。我看到拓詞的創始人薛淡在[「决不放弃，死磕到底 - 拓词 CEO 薛淡的一封信」](https://www.towords.com/announcement)裏這樣描述自己當時深處逆境的狀態：\n\n>  在茫茫戈壁上，我确信自己想清楚了一点，拓词之于我就是我的另一个孩子，他是我生命的一部分，是我六年生命的一个结晶，他实际是我第一次创业的全部…除非再也没有任何人需要他，除非完全没有任何复活的可能，除非没有我他也可以很好，否则我根本就不可能放弃，而经历了离开的放弃，经历了下架的放弃，我对放弃和坚持这两个名词有了切肤的手感。 \n>\n>\n>\n> 放弃的那一刻是容易的，而此后则是无尽的黑暗，坚持的那一刻是痛苦的，而此后力量会喷薄而来，我突然发现这居然是我人生的范式，那一刻，我泪流满面，天很蓝，戈壁很美…\n\n嗯，我相信每個人在他的人生裏都要經歷這麼一場 limbo，更加殘酷的是，有的人跨過了它，而有的人可能一輩子沒能走出來。\n\n## [孤獨指南](evernote:///view/48743637/s244/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/)\n\n自己從大學開始就經常獨自一人，在大學入學的時候，全校學生統一進行了一項心理測試，我的測試報告在各項都合格的情況下，唯獨有一項是具有一定的「社交攻擊性」。也許這是我後來不願與人合羣的原因，也許不是。總之是大學開始了長時間的一個人的狀態，來到德國後，這樣的狀態愈加明顯。於是我寫了這篇「孤獨指南」，其中按照順序羅列了一些一個人可以做的事件，包括但不限於：\n\n> - 当下最紧急，最迫切的任务；\n>\n> - 锻炼身体，平板支撑，俯卧撑等；\n>\n> - 做数学题；\n>\n> - 编程；\n>\n> - 进行文字形式的输出，创作；\n>\n> - 骑车外出兜风，打篮球；\n>\n> - 听英文播客，德语播客；\n>\n> - 读英文书，德语书；\n>\n> - 阅读 Pocket，Medium，或是经济学人，纽约客，自己感性趣的长篇外文分析文章，整理语料库；\n>\n> - 整理笔记； \n>\n>     …\n\n從上到下是按照花費精力的大小排序的。比如「做數學題」花費的精力多於「編程」花費的精力，依此類推。這樣當自己學習德語學累的時候，就可以按照這個表單進行之後的活動。\n\n這份指南的意義在於，一個人的時候不會直接去做諸如刷知乎，微博這些低價值的事情，而是按照自己的精力，儘可能地多做一些有意義，有價值的事，比如，寫作。\n\n在這份「孤獨指南」之前，心情低落總是尋求極度低價值的事情。在當自己心理還不夠強大的時候，總希望找到某種能陪伴的媒介。播客是一種，直播亦是。直播這樣一種強交互媒介形式，其作用大概有兩個：\n\n1. 消磨時間；\n2. 和主播的溝通建立某種聯繫，心理的陪伴；\n\n第二種功能對於我這樣一度有些社交恐懼的人，就很有療傷功效。我當然也很感謝，在我極度低落的時候，看了很多女流直播的遊戲視頻，算是幫我度過了一段艱難歲月吧。但這只是止痛劑，是摻了嗎啡的止痛劑。一次兩次，閾值不斷提高，真正的痛苦卻依然持續，止痛劑的劑量會不斷加大，病症一直沒能根除。所以我才最終有了這份指南。\n\n## 語言學習的瓶頸\n\n語言學習的瓶頸在於單詞量。而單詞量的積累，需要大量的精讀。這兩步做到了，才能往下進行聽力，口語和寫作的提升。這是我這一年來學習德語最大的感悟。因爲聽力的問題，一半是自己本身聽得數量，另一半就是單詞量。而且很少有單詞都掌握但卻聽不懂的情況。口語和寫作都屬於輸出形式，表達則更是依託在強大的單詞量的基礎，每一個單詞，背後都有着許多用法，許多表達。所以，任何語言的學習，時間分配大概是，30% 的語法學習，70% 的單詞量積累。\n\n另外，在我看來，單詞量擴充的唯一方式就是閱讀，因爲只有通過語境獲得的語義，才是最自然的，最直接的，最深刻的。也只有這樣，你才能日後直到怎樣使用它。而且我非常不建議通過大量閱讀詞典的例句來積累單詞，因爲那樣的語境是割裂的。我們希求的語境一定是一條連續的線，可以往前追溯。\n\n所以我開始了大量的精讀，建立了所謂的「德語語料庫」，目前爲止積累了大概三千多的詞條。並且也同樣模式建立了「英語語料庫」和「中文語料庫」，中文語料庫這個，是自己發現自己在大學之後，過多的強調外語的學習，而忽略了中文，其實中文才是最應該好好學習的。現在來看目前的輿論風向往往是，因爲長期在英文環境裏，中文水準的下降，似乎都是一件特別值得驕傲的事。我覺得至少要做到的一點是，各個語言不要摻雜，德語裏不要混入英語，中文裏不要混入英語，講英語的話就好好只講英語。\n\n對於平復內心，我開始試着把桌子上的雜物都清理掉，把地板仔細擦上三遍。認認真真洗上一個熱水澡。認真整理電腦裏的各個文件夾，給 Evernote 裏的筆記認真歸類，打標籤。做的所有這一切，是希望營造一種儀式感。認真的把所有雜物都整理乾淨，把熵值降到最低。因爲我相信一點，你周圍的環境其實是你內心世界的真實反應。內心足夠平靜，你周圍的環境也足夠安靜，相反，內心亂糟糟，周圍肯定也亂糟糟。所以收拾心情的最好方式是整理家務，打掃房間，跑步，運動，出汗，然後清理自己的身體。\n\n\n\n## 後記\n\n弱冠之年，你是否還記得年少時的夢？十六歲離家，現在已有七年，一直努力，也曾經迷茫彷徨失意絕望，一直往西，從鄭州到西安，又一個人到了德國。我們總要在無數的可能性中選擇一種，努力的活着。順境逆境，最好的狀態可能就是，「不以物喜，不以己悲。」\n\n或者不如，\n\n「骑着白马入地狱，叼着纸烟进天堂。」","source":"_posts/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」.md","raw":"---\ntitle: '「骑着白马入地狱，叼着纸烟进天堂」'\ndate: 2017-09-10 23:57:00\ntags:\ncategories: 'I/O'\n---\n\n- 這一年在德國的生活回顧\n- 『孤獨指南』\n- 直播節目，心理療傷，自我慰藉\n- 語言學習的瓶頸\n- 當學習少了儀式感\n\n## 畢業一年\n\n來之前，沒曾想到自己會在德語考試上停留這麼久。\n\n二〇一六年九月到二〇一七年九月。\n\n二〇一六年九月底到德國，處理很多事情，落戶，銀行卡，房屋合同，保險，找房，還有房屋的衛生問題，自己又盲目的報名了十一月份的考試，當時由於整個大四下忙於畢設，疏於德語的學習，等我到德國時，德語退步很大，加上剛來的不適應，十一月考試結果特別差。然後十二月找房，一月份搬入新家。二月份的時候又考了一次，結果較上次有很大進步，到三月份，自己在 Tandem 的六個月語言課程結束，然後是面臨四月的考試，那時的狀態也是最焦慮，最混亂的，當時覺得如果考試考不過就全完了，巨大的壓力和焦慮也導致了考前複習的極度混亂，甚至一度的通過上網來麻痺自己，緩解焦慮，清楚的記得考前的一晚都還在看著 BiliBili 網站的視頻，想要逃避現實。四月底的那次考試考完，反倒讓我開始反思自己的學習模式，然後是五月份自己開始了極度自律的一個月，每週統計，效率上很高，直到六月二號開始，黃同學的到來，我那極度自律的狀態也隨即結束了。從六月二號到六月十四號又回到考前的極度緊張和焦慮，加之考前一天得知四月的考試結果，頂着巨大的壓力和焦慮又去考了六月那一場。雖然五月份自己極度的自律地在複習，但複習方向以聽力，口語為主，沒有很集中的背單詞和準備句式，考試最終還是在寫作上吃了虧。\n\n<!--more-->\n\n好吧，到此為止，算是經歷的最大的磨難了麼？還不是。六月下旬開始申請學校，直到六月底，算是把三所學校的材料都寄了出去。七月開始，德語的學習是學學停停，然後抽時間看看書，練習練習編程，做一做算法題，看了Dunkirk 電影，但時間上並沒有像五月那樣極度的自律，而是一種比較輕鬆的狀態，到七月底，也可能是受周圍同學的影響吧，狀態差到，在我過去二十三年都前所未有。好友黃同學已經收到幾個學校的錄取了，另一位比我來德國還要晚一些的白同學，六月份的考試成功通過了。好吧，當時我在想，已經在德國九個月了，畢業已經一年了。我當時的房屋合同是到八月底，而我當時的簽證是到九月二十號，我原本計劃是拿到學校錄取後延簽。而如果我拿不到學校錄取，我覺我是時候「滾」回去了。\n\n諸位可能沒法感同身受我當時的心情。對了，來德國之後，和國內的朋友同學都不怎麼聯繫了，唯獨胡小姐，偶有交谈，甚至還會打電話打很長時間，五月份還一起讀書，在一個軟件裏相互交換閱讀讀書筆記來着，六月份因爲一次不愉快的聊天，就相互刪除了聯繫方式。胡小姐和我之間的故事，若展開來講，估計可以寫一本小說了。當然我也並不是第一次被胡小姐從聯繫人刪除，只是，因爲當時的狀態，我個人單方面也不想再有聯繫了。於是我把朋友圈關了，我把「通過任何帳號加我爲好友」的功能關掉，這樣就不會有任何人能加到我了。\n\n七月底開始到八月十五號拿到第一個學校的錄取，這中間我經歷了人生的第一次 limbo。我不知道在哪，不知道要幹嘛，沒有任何信心去想象明天。耳朵裏一直插着耳機，放着人聲。最初的幾天是每天都在失眠，我不得不看一些無關的信息來分散我的注意力，支撐到身體撐不下去的時候，才能夠睡着，然而等待我的又是一個又一個噩夢。無論夢到什麼，對我來說都是一個噩夢。夢到故鄉，好友，夢到往日的榮光和失敗。於是，看電子屏幕久了，眼睛會痛，因爲我很早就有慢性結膜炎。耳機放耳朵裏久了，耳朵也會痛，有可能是細菌發炎什麼的，總之掏耳朵時痛的不行。最痛苦的時候，一個人躺在床上，眼睛疼痛的淚流不止，耳朵裏一直帶着耳機，裏面傳出人聲。\n\n而這所有的一切，都找不到一個人來講，不能和父母講，因爲不能讓他們擔心。朋友裏唯一能與之傾訴的人，已經刪除了聯繫人，自己單方面也不想再去聯繫。我單方面的斷絕所有的社交聯繫，譬如關朋友圈，儘量少的和任何人接觸，這些其實是當時極度脆弱的自己，對自我的一種保護。\n\n後來自己思考，任何的痛苦和黑暗都不是永久的。總會過去。八月中旬之後事情才有轉機。拿到第一個學校的錄取後就是開始着手延簽，着手延期房屋合同，去外觀局整夜排隊。考試報名，複習，預訂車票，找住處，考試，到今天，已經考完了 KIT 的 DSH 筆試部分。\n\n是不是每個人人生中都要經歷這樣一場最痛苦的絕望。我看到拓詞的創始人薛淡在[「决不放弃，死磕到底 - 拓词 CEO 薛淡的一封信」](https://www.towords.com/announcement)裏這樣描述自己當時深處逆境的狀態：\n\n>  在茫茫戈壁上，我确信自己想清楚了一点，拓词之于我就是我的另一个孩子，他是我生命的一部分，是我六年生命的一个结晶，他实际是我第一次创业的全部…除非再也没有任何人需要他，除非完全没有任何复活的可能，除非没有我他也可以很好，否则我根本就不可能放弃，而经历了离开的放弃，经历了下架的放弃，我对放弃和坚持这两个名词有了切肤的手感。 \n>\n>\n>\n> 放弃的那一刻是容易的，而此后则是无尽的黑暗，坚持的那一刻是痛苦的，而此后力量会喷薄而来，我突然发现这居然是我人生的范式，那一刻，我泪流满面，天很蓝，戈壁很美…\n\n嗯，我相信每個人在他的人生裏都要經歷這麼一場 limbo，更加殘酷的是，有的人跨過了它，而有的人可能一輩子沒能走出來。\n\n## [孤獨指南](evernote:///view/48743637/s244/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/)\n\n自己從大學開始就經常獨自一人，在大學入學的時候，全校學生統一進行了一項心理測試，我的測試報告在各項都合格的情況下，唯獨有一項是具有一定的「社交攻擊性」。也許這是我後來不願與人合羣的原因，也許不是。總之是大學開始了長時間的一個人的狀態，來到德國後，這樣的狀態愈加明顯。於是我寫了這篇「孤獨指南」，其中按照順序羅列了一些一個人可以做的事件，包括但不限於：\n\n> - 当下最紧急，最迫切的任务；\n>\n> - 锻炼身体，平板支撑，俯卧撑等；\n>\n> - 做数学题；\n>\n> - 编程；\n>\n> - 进行文字形式的输出，创作；\n>\n> - 骑车外出兜风，打篮球；\n>\n> - 听英文播客，德语播客；\n>\n> - 读英文书，德语书；\n>\n> - 阅读 Pocket，Medium，或是经济学人，纽约客，自己感性趣的长篇外文分析文章，整理语料库；\n>\n> - 整理笔记； \n>\n>     …\n\n從上到下是按照花費精力的大小排序的。比如「做數學題」花費的精力多於「編程」花費的精力，依此類推。這樣當自己學習德語學累的時候，就可以按照這個表單進行之後的活動。\n\n這份指南的意義在於，一個人的時候不會直接去做諸如刷知乎，微博這些低價值的事情，而是按照自己的精力，儘可能地多做一些有意義，有價值的事，比如，寫作。\n\n在這份「孤獨指南」之前，心情低落總是尋求極度低價值的事情。在當自己心理還不夠強大的時候，總希望找到某種能陪伴的媒介。播客是一種，直播亦是。直播這樣一種強交互媒介形式，其作用大概有兩個：\n\n1. 消磨時間；\n2. 和主播的溝通建立某種聯繫，心理的陪伴；\n\n第二種功能對於我這樣一度有些社交恐懼的人，就很有療傷功效。我當然也很感謝，在我極度低落的時候，看了很多女流直播的遊戲視頻，算是幫我度過了一段艱難歲月吧。但這只是止痛劑，是摻了嗎啡的止痛劑。一次兩次，閾值不斷提高，真正的痛苦卻依然持續，止痛劑的劑量會不斷加大，病症一直沒能根除。所以我才最終有了這份指南。\n\n## 語言學習的瓶頸\n\n語言學習的瓶頸在於單詞量。而單詞量的積累，需要大量的精讀。這兩步做到了，才能往下進行聽力，口語和寫作的提升。這是我這一年來學習德語最大的感悟。因爲聽力的問題，一半是自己本身聽得數量，另一半就是單詞量。而且很少有單詞都掌握但卻聽不懂的情況。口語和寫作都屬於輸出形式，表達則更是依託在強大的單詞量的基礎，每一個單詞，背後都有着許多用法，許多表達。所以，任何語言的學習，時間分配大概是，30% 的語法學習，70% 的單詞量積累。\n\n另外，在我看來，單詞量擴充的唯一方式就是閱讀，因爲只有通過語境獲得的語義，才是最自然的，最直接的，最深刻的。也只有這樣，你才能日後直到怎樣使用它。而且我非常不建議通過大量閱讀詞典的例句來積累單詞，因爲那樣的語境是割裂的。我們希求的語境一定是一條連續的線，可以往前追溯。\n\n所以我開始了大量的精讀，建立了所謂的「德語語料庫」，目前爲止積累了大概三千多的詞條。並且也同樣模式建立了「英語語料庫」和「中文語料庫」，中文語料庫這個，是自己發現自己在大學之後，過多的強調外語的學習，而忽略了中文，其實中文才是最應該好好學習的。現在來看目前的輿論風向往往是，因爲長期在英文環境裏，中文水準的下降，似乎都是一件特別值得驕傲的事。我覺得至少要做到的一點是，各個語言不要摻雜，德語裏不要混入英語，中文裏不要混入英語，講英語的話就好好只講英語。\n\n對於平復內心，我開始試着把桌子上的雜物都清理掉，把地板仔細擦上三遍。認認真真洗上一個熱水澡。認真整理電腦裏的各個文件夾，給 Evernote 裏的筆記認真歸類，打標籤。做的所有這一切，是希望營造一種儀式感。認真的把所有雜物都整理乾淨，把熵值降到最低。因爲我相信一點，你周圍的環境其實是你內心世界的真實反應。內心足夠平靜，你周圍的環境也足夠安靜，相反，內心亂糟糟，周圍肯定也亂糟糟。所以收拾心情的最好方式是整理家務，打掃房間，跑步，運動，出汗，然後清理自己的身體。\n\n\n\n## 後記\n\n弱冠之年，你是否還記得年少時的夢？十六歲離家，現在已有七年，一直努力，也曾經迷茫彷徨失意絕望，一直往西，從鄭州到西安，又一個人到了德國。我們總要在無數的可能性中選擇一種，努力的活着。順境逆境，最好的狀態可能就是，「不以物喜，不以己悲。」\n\n或者不如，\n\n「骑着白马入地狱，叼着纸烟进天堂。」","slug":"I-O-23-「骑着白马入地狱，叼着纸烟进天堂」","published":1,"updated":"2019-01-20T09:42:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx27001frg1vdlwi8fik","content":"<ul>\n<li>這一年在德國的生活回顧</li>\n<li>『孤獨指南』</li>\n<li>直播節目，心理療傷，自我慰藉</li>\n<li>語言學習的瓶頸</li>\n<li>當學習少了儀式感</li>\n</ul>\n<h2 id=\"畢業一年\"><a href=\"#畢業一年\" class=\"headerlink\" title=\"畢業一年\"></a>畢業一年</h2><p>來之前，沒曾想到自己會在德語考試上停留這麼久。</p>\n<p>二〇一六年九月到二〇一七年九月。</p>\n<p>二〇一六年九月底到德國，處理很多事情，落戶，銀行卡，房屋合同，保險，找房，還有房屋的衛生問題，自己又盲目的報名了十一月份的考試，當時由於整個大四下忙於畢設，疏於德語的學習，等我到德國時，德語退步很大，加上剛來的不適應，十一月考試結果特別差。然後十二月找房，一月份搬入新家。二月份的時候又考了一次，結果較上次有很大進步，到三月份，自己在 Tandem 的六個月語言課程結束，然後是面臨四月的考試，那時的狀態也是最焦慮，最混亂的，當時覺得如果考試考不過就全完了，巨大的壓力和焦慮也導致了考前複習的極度混亂，甚至一度的通過上網來麻痺自己，緩解焦慮，清楚的記得考前的一晚都還在看著 BiliBili 網站的視頻，想要逃避現實。四月底的那次考試考完，反倒讓我開始反思自己的學習模式，然後是五月份自己開始了極度自律的一個月，每週統計，效率上很高，直到六月二號開始，黃同學的到來，我那極度自律的狀態也隨即結束了。從六月二號到六月十四號又回到考前的極度緊張和焦慮，加之考前一天得知四月的考試結果，頂着巨大的壓力和焦慮又去考了六月那一場。雖然五月份自己極度的自律地在複習，但複習方向以聽力，口語為主，沒有很集中的背單詞和準備句式，考試最終還是在寫作上吃了虧。</p>\n<span id=\"more\"></span>\n\n<p>好吧，到此為止，算是經歷的最大的磨難了麼？還不是。六月下旬開始申請學校，直到六月底，算是把三所學校的材料都寄了出去。七月開始，德語的學習是學學停停，然後抽時間看看書，練習練習編程，做一做算法題，看了Dunkirk 電影，但時間上並沒有像五月那樣極度的自律，而是一種比較輕鬆的狀態，到七月底，也可能是受周圍同學的影響吧，狀態差到，在我過去二十三年都前所未有。好友黃同學已經收到幾個學校的錄取了，另一位比我來德國還要晚一些的白同學，六月份的考試成功通過了。好吧，當時我在想，已經在德國九個月了，畢業已經一年了。我當時的房屋合同是到八月底，而我當時的簽證是到九月二十號，我原本計劃是拿到學校錄取後延簽。而如果我拿不到學校錄取，我覺我是時候「滾」回去了。</p>\n<p>諸位可能沒法感同身受我當時的心情。對了，來德國之後，和國內的朋友同學都不怎麼聯繫了，唯獨胡小姐，偶有交谈，甚至還會打電話打很長時間，五月份還一起讀書，在一個軟件裏相互交換閱讀讀書筆記來着，六月份因爲一次不愉快的聊天，就相互刪除了聯繫方式。胡小姐和我之間的故事，若展開來講，估計可以寫一本小說了。當然我也並不是第一次被胡小姐從聯繫人刪除，只是，因爲當時的狀態，我個人單方面也不想再有聯繫了。於是我把朋友圈關了，我把「通過任何帳號加我爲好友」的功能關掉，這樣就不會有任何人能加到我了。</p>\n<p>七月底開始到八月十五號拿到第一個學校的錄取，這中間我經歷了人生的第一次 limbo。我不知道在哪，不知道要幹嘛，沒有任何信心去想象明天。耳朵裏一直插着耳機，放着人聲。最初的幾天是每天都在失眠，我不得不看一些無關的信息來分散我的注意力，支撐到身體撐不下去的時候，才能夠睡着，然而等待我的又是一個又一個噩夢。無論夢到什麼，對我來說都是一個噩夢。夢到故鄉，好友，夢到往日的榮光和失敗。於是，看電子屏幕久了，眼睛會痛，因爲我很早就有慢性結膜炎。耳機放耳朵裏久了，耳朵也會痛，有可能是細菌發炎什麼的，總之掏耳朵時痛的不行。最痛苦的時候，一個人躺在床上，眼睛疼痛的淚流不止，耳朵裏一直帶着耳機，裏面傳出人聲。</p>\n<p>而這所有的一切，都找不到一個人來講，不能和父母講，因爲不能讓他們擔心。朋友裏唯一能與之傾訴的人，已經刪除了聯繫人，自己單方面也不想再去聯繫。我單方面的斷絕所有的社交聯繫，譬如關朋友圈，儘量少的和任何人接觸，這些其實是當時極度脆弱的自己，對自我的一種保護。</p>\n<p>後來自己思考，任何的痛苦和黑暗都不是永久的。總會過去。八月中旬之後事情才有轉機。拿到第一個學校的錄取後就是開始着手延簽，着手延期房屋合同，去外觀局整夜排隊。考試報名，複習，預訂車票，找住處，考試，到今天，已經考完了 KIT 的 DSH 筆試部分。</p>\n<p>是不是每個人人生中都要經歷這樣一場最痛苦的絕望。我看到拓詞的創始人薛淡在<a href=\"https://www.towords.com/announcement\">「决不放弃，死磕到底 - 拓词 CEO 薛淡的一封信」</a>裏這樣描述自己當時深處逆境的狀態：</p>\n<blockquote>\n<p> 在茫茫戈壁上，我确信自己想清楚了一点，拓词之于我就是我的另一个孩子，他是我生命的一部分，是我六年生命的一个结晶，他实际是我第一次创业的全部…除非再也没有任何人需要他，除非完全没有任何复活的可能，除非没有我他也可以很好，否则我根本就不可能放弃，而经历了离开的放弃，经历了下架的放弃，我对放弃和坚持这两个名词有了切肤的手感。 </p>\n<p>放弃的那一刻是容易的，而此后则是无尽的黑暗，坚持的那一刻是痛苦的，而此后力量会喷薄而来，我突然发现这居然是我人生的范式，那一刻，我泪流满面，天很蓝，戈壁很美…</p>\n</blockquote>\n<p>嗯，我相信每個人在他的人生裏都要經歷這麼一場 limbo，更加殘酷的是，有的人跨過了它，而有的人可能一輩子沒能走出來。</p>\n<h2 id=\"孤獨指南\"><a href=\"#孤獨指南\" class=\"headerlink\" title=\"孤獨指南\"></a><a href=\"evernote:///view/48743637/s244/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/\">孤獨指南</a></h2><p>自己從大學開始就經常獨自一人，在大學入學的時候，全校學生統一進行了一項心理測試，我的測試報告在各項都合格的情況下，唯獨有一項是具有一定的「社交攻擊性」。也許這是我後來不願與人合羣的原因，也許不是。總之是大學開始了長時間的一個人的狀態，來到德國後，這樣的狀態愈加明顯。於是我寫了這篇「孤獨指南」，其中按照順序羅列了一些一個人可以做的事件，包括但不限於：</p>\n<blockquote>\n<ul>\n<li><p>当下最紧急，最迫切的任务；</p>\n</li>\n<li><p>锻炼身体，平板支撑，俯卧撑等；</p>\n</li>\n<li><p>做数学题；</p>\n</li>\n<li><p>编程；</p>\n</li>\n<li><p>进行文字形式的输出，创作；</p>\n</li>\n<li><p>骑车外出兜风，打篮球；</p>\n</li>\n<li><p>听英文播客，德语播客；</p>\n</li>\n<li><p>读英文书，德语书；</p>\n</li>\n<li><p>阅读 Pocket，Medium，或是经济学人，纽约客，自己感性趣的长篇外文分析文章，整理语料库；</p>\n</li>\n<li><p>整理笔记； </p>\n<p>  …</p>\n</li>\n</ul>\n</blockquote>\n<p>從上到下是按照花費精力的大小排序的。比如「做數學題」花費的精力多於「編程」花費的精力，依此類推。這樣當自己學習德語學累的時候，就可以按照這個表單進行之後的活動。</p>\n<p>這份指南的意義在於，一個人的時候不會直接去做諸如刷知乎，微博這些低價值的事情，而是按照自己的精力，儘可能地多做一些有意義，有價值的事，比如，寫作。</p>\n<p>在這份「孤獨指南」之前，心情低落總是尋求極度低價值的事情。在當自己心理還不夠強大的時候，總希望找到某種能陪伴的媒介。播客是一種，直播亦是。直播這樣一種強交互媒介形式，其作用大概有兩個：</p>\n<ol>\n<li>消磨時間；</li>\n<li>和主播的溝通建立某種聯繫，心理的陪伴；</li>\n</ol>\n<p>第二種功能對於我這樣一度有些社交恐懼的人，就很有療傷功效。我當然也很感謝，在我極度低落的時候，看了很多女流直播的遊戲視頻，算是幫我度過了一段艱難歲月吧。但這只是止痛劑，是摻了嗎啡的止痛劑。一次兩次，閾值不斷提高，真正的痛苦卻依然持續，止痛劑的劑量會不斷加大，病症一直沒能根除。所以我才最終有了這份指南。</p>\n<h2 id=\"語言學習的瓶頸\"><a href=\"#語言學習的瓶頸\" class=\"headerlink\" title=\"語言學習的瓶頸\"></a>語言學習的瓶頸</h2><p>語言學習的瓶頸在於單詞量。而單詞量的積累，需要大量的精讀。這兩步做到了，才能往下進行聽力，口語和寫作的提升。這是我這一年來學習德語最大的感悟。因爲聽力的問題，一半是自己本身聽得數量，另一半就是單詞量。而且很少有單詞都掌握但卻聽不懂的情況。口語和寫作都屬於輸出形式，表達則更是依託在強大的單詞量的基礎，每一個單詞，背後都有着許多用法，許多表達。所以，任何語言的學習，時間分配大概是，30% 的語法學習，70% 的單詞量積累。</p>\n<p>另外，在我看來，單詞量擴充的唯一方式就是閱讀，因爲只有通過語境獲得的語義，才是最自然的，最直接的，最深刻的。也只有這樣，你才能日後直到怎樣使用它。而且我非常不建議通過大量閱讀詞典的例句來積累單詞，因爲那樣的語境是割裂的。我們希求的語境一定是一條連續的線，可以往前追溯。</p>\n<p>所以我開始了大量的精讀，建立了所謂的「德語語料庫」，目前爲止積累了大概三千多的詞條。並且也同樣模式建立了「英語語料庫」和「中文語料庫」，中文語料庫這個，是自己發現自己在大學之後，過多的強調外語的學習，而忽略了中文，其實中文才是最應該好好學習的。現在來看目前的輿論風向往往是，因爲長期在英文環境裏，中文水準的下降，似乎都是一件特別值得驕傲的事。我覺得至少要做到的一點是，各個語言不要摻雜，德語裏不要混入英語，中文裏不要混入英語，講英語的話就好好只講英語。</p>\n<p>對於平復內心，我開始試着把桌子上的雜物都清理掉，把地板仔細擦上三遍。認認真真洗上一個熱水澡。認真整理電腦裏的各個文件夾，給 Evernote 裏的筆記認真歸類，打標籤。做的所有這一切，是希望營造一種儀式感。認真的把所有雜物都整理乾淨，把熵值降到最低。因爲我相信一點，你周圍的環境其實是你內心世界的真實反應。內心足夠平靜，你周圍的環境也足夠安靜，相反，內心亂糟糟，周圍肯定也亂糟糟。所以收拾心情的最好方式是整理家務，打掃房間，跑步，運動，出汗，然後清理自己的身體。</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>弱冠之年，你是否還記得年少時的夢？十六歲離家，現在已有七年，一直努力，也曾經迷茫彷徨失意絕望，一直往西，從鄭州到西安，又一個人到了德國。我們總要在無數的可能性中選擇一種，努力的活着。順境逆境，最好的狀態可能就是，「不以物喜，不以己悲。」</p>\n<p>或者不如，</p>\n<p>「骑着白马入地狱，叼着纸烟进天堂。」</p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>這一年在德國的生活回顧</li>\n<li>『孤獨指南』</li>\n<li>直播節目，心理療傷，自我慰藉</li>\n<li>語言學習的瓶頸</li>\n<li>當學習少了儀式感</li>\n</ul>\n<h2 id=\"畢業一年\"><a href=\"#畢業一年\" class=\"headerlink\" title=\"畢業一年\"></a>畢業一年</h2><p>來之前，沒曾想到自己會在德語考試上停留這麼久。</p>\n<p>二〇一六年九月到二〇一七年九月。</p>\n<p>二〇一六年九月底到德國，處理很多事情，落戶，銀行卡，房屋合同，保險，找房，還有房屋的衛生問題，自己又盲目的報名了十一月份的考試，當時由於整個大四下忙於畢設，疏於德語的學習，等我到德國時，德語退步很大，加上剛來的不適應，十一月考試結果特別差。然後十二月找房，一月份搬入新家。二月份的時候又考了一次，結果較上次有很大進步，到三月份，自己在 Tandem 的六個月語言課程結束，然後是面臨四月的考試，那時的狀態也是最焦慮，最混亂的，當時覺得如果考試考不過就全完了，巨大的壓力和焦慮也導致了考前複習的極度混亂，甚至一度的通過上網來麻痺自己，緩解焦慮，清楚的記得考前的一晚都還在看著 BiliBili 網站的視頻，想要逃避現實。四月底的那次考試考完，反倒讓我開始反思自己的學習模式，然後是五月份自己開始了極度自律的一個月，每週統計，效率上很高，直到六月二號開始，黃同學的到來，我那極度自律的狀態也隨即結束了。從六月二號到六月十四號又回到考前的極度緊張和焦慮，加之考前一天得知四月的考試結果，頂着巨大的壓力和焦慮又去考了六月那一場。雖然五月份自己極度的自律地在複習，但複習方向以聽力，口語為主，沒有很集中的背單詞和準備句式，考試最終還是在寫作上吃了虧。</p>","more":"<p>好吧，到此為止，算是經歷的最大的磨難了麼？還不是。六月下旬開始申請學校，直到六月底，算是把三所學校的材料都寄了出去。七月開始，德語的學習是學學停停，然後抽時間看看書，練習練習編程，做一做算法題，看了Dunkirk 電影，但時間上並沒有像五月那樣極度的自律，而是一種比較輕鬆的狀態，到七月底，也可能是受周圍同學的影響吧，狀態差到，在我過去二十三年都前所未有。好友黃同學已經收到幾個學校的錄取了，另一位比我來德國還要晚一些的白同學，六月份的考試成功通過了。好吧，當時我在想，已經在德國九個月了，畢業已經一年了。我當時的房屋合同是到八月底，而我當時的簽證是到九月二十號，我原本計劃是拿到學校錄取後延簽。而如果我拿不到學校錄取，我覺我是時候「滾」回去了。</p>\n<p>諸位可能沒法感同身受我當時的心情。對了，來德國之後，和國內的朋友同學都不怎麼聯繫了，唯獨胡小姐，偶有交谈，甚至還會打電話打很長時間，五月份還一起讀書，在一個軟件裏相互交換閱讀讀書筆記來着，六月份因爲一次不愉快的聊天，就相互刪除了聯繫方式。胡小姐和我之間的故事，若展開來講，估計可以寫一本小說了。當然我也並不是第一次被胡小姐從聯繫人刪除，只是，因爲當時的狀態，我個人單方面也不想再有聯繫了。於是我把朋友圈關了，我把「通過任何帳號加我爲好友」的功能關掉，這樣就不會有任何人能加到我了。</p>\n<p>七月底開始到八月十五號拿到第一個學校的錄取，這中間我經歷了人生的第一次 limbo。我不知道在哪，不知道要幹嘛，沒有任何信心去想象明天。耳朵裏一直插着耳機，放着人聲。最初的幾天是每天都在失眠，我不得不看一些無關的信息來分散我的注意力，支撐到身體撐不下去的時候，才能夠睡着，然而等待我的又是一個又一個噩夢。無論夢到什麼，對我來說都是一個噩夢。夢到故鄉，好友，夢到往日的榮光和失敗。於是，看電子屏幕久了，眼睛會痛，因爲我很早就有慢性結膜炎。耳機放耳朵裏久了，耳朵也會痛，有可能是細菌發炎什麼的，總之掏耳朵時痛的不行。最痛苦的時候，一個人躺在床上，眼睛疼痛的淚流不止，耳朵裏一直帶着耳機，裏面傳出人聲。</p>\n<p>而這所有的一切，都找不到一個人來講，不能和父母講，因爲不能讓他們擔心。朋友裏唯一能與之傾訴的人，已經刪除了聯繫人，自己單方面也不想再去聯繫。我單方面的斷絕所有的社交聯繫，譬如關朋友圈，儘量少的和任何人接觸，這些其實是當時極度脆弱的自己，對自我的一種保護。</p>\n<p>後來自己思考，任何的痛苦和黑暗都不是永久的。總會過去。八月中旬之後事情才有轉機。拿到第一個學校的錄取後就是開始着手延簽，着手延期房屋合同，去外觀局整夜排隊。考試報名，複習，預訂車票，找住處，考試，到今天，已經考完了 KIT 的 DSH 筆試部分。</p>\n<p>是不是每個人人生中都要經歷這樣一場最痛苦的絕望。我看到拓詞的創始人薛淡在<a href=\"https://www.towords.com/announcement\">「决不放弃，死磕到底 - 拓词 CEO 薛淡的一封信」</a>裏這樣描述自己當時深處逆境的狀態：</p>\n<blockquote>\n<p> 在茫茫戈壁上，我确信自己想清楚了一点，拓词之于我就是我的另一个孩子，他是我生命的一部分，是我六年生命的一个结晶，他实际是我第一次创业的全部…除非再也没有任何人需要他，除非完全没有任何复活的可能，除非没有我他也可以很好，否则我根本就不可能放弃，而经历了离开的放弃，经历了下架的放弃，我对放弃和坚持这两个名词有了切肤的手感。 </p>\n<p>放弃的那一刻是容易的，而此后则是无尽的黑暗，坚持的那一刻是痛苦的，而此后力量会喷薄而来，我突然发现这居然是我人生的范式，那一刻，我泪流满面，天很蓝，戈壁很美…</p>\n</blockquote>\n<p>嗯，我相信每個人在他的人生裏都要經歷這麼一場 limbo，更加殘酷的是，有的人跨過了它，而有的人可能一輩子沒能走出來。</p>\n<h2 id=\"孤獨指南\"><a href=\"#孤獨指南\" class=\"headerlink\" title=\"孤獨指南\"></a><a href=\"evernote:///view/48743637/s244/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/6b27b649-8a5f-4c37-8f89-c8cc0d9fa84e/\">孤獨指南</a></h2><p>自己從大學開始就經常獨自一人，在大學入學的時候，全校學生統一進行了一項心理測試，我的測試報告在各項都合格的情況下，唯獨有一項是具有一定的「社交攻擊性」。也許這是我後來不願與人合羣的原因，也許不是。總之是大學開始了長時間的一個人的狀態，來到德國後，這樣的狀態愈加明顯。於是我寫了這篇「孤獨指南」，其中按照順序羅列了一些一個人可以做的事件，包括但不限於：</p>\n<blockquote>\n<ul>\n<li><p>当下最紧急，最迫切的任务；</p>\n</li>\n<li><p>锻炼身体，平板支撑，俯卧撑等；</p>\n</li>\n<li><p>做数学题；</p>\n</li>\n<li><p>编程；</p>\n</li>\n<li><p>进行文字形式的输出，创作；</p>\n</li>\n<li><p>骑车外出兜风，打篮球；</p>\n</li>\n<li><p>听英文播客，德语播客；</p>\n</li>\n<li><p>读英文书，德语书；</p>\n</li>\n<li><p>阅读 Pocket，Medium，或是经济学人，纽约客，自己感性趣的长篇外文分析文章，整理语料库；</p>\n</li>\n<li><p>整理笔记； </p>\n<p>  …</p>\n</li>\n</ul>\n</blockquote>\n<p>從上到下是按照花費精力的大小排序的。比如「做數學題」花費的精力多於「編程」花費的精力，依此類推。這樣當自己學習德語學累的時候，就可以按照這個表單進行之後的活動。</p>\n<p>這份指南的意義在於，一個人的時候不會直接去做諸如刷知乎，微博這些低價值的事情，而是按照自己的精力，儘可能地多做一些有意義，有價值的事，比如，寫作。</p>\n<p>在這份「孤獨指南」之前，心情低落總是尋求極度低價值的事情。在當自己心理還不夠強大的時候，總希望找到某種能陪伴的媒介。播客是一種，直播亦是。直播這樣一種強交互媒介形式，其作用大概有兩個：</p>\n<ol>\n<li>消磨時間；</li>\n<li>和主播的溝通建立某種聯繫，心理的陪伴；</li>\n</ol>\n<p>第二種功能對於我這樣一度有些社交恐懼的人，就很有療傷功效。我當然也很感謝，在我極度低落的時候，看了很多女流直播的遊戲視頻，算是幫我度過了一段艱難歲月吧。但這只是止痛劑，是摻了嗎啡的止痛劑。一次兩次，閾值不斷提高，真正的痛苦卻依然持續，止痛劑的劑量會不斷加大，病症一直沒能根除。所以我才最終有了這份指南。</p>\n<h2 id=\"語言學習的瓶頸\"><a href=\"#語言學習的瓶頸\" class=\"headerlink\" title=\"語言學習的瓶頸\"></a>語言學習的瓶頸</h2><p>語言學習的瓶頸在於單詞量。而單詞量的積累，需要大量的精讀。這兩步做到了，才能往下進行聽力，口語和寫作的提升。這是我這一年來學習德語最大的感悟。因爲聽力的問題，一半是自己本身聽得數量，另一半就是單詞量。而且很少有單詞都掌握但卻聽不懂的情況。口語和寫作都屬於輸出形式，表達則更是依託在強大的單詞量的基礎，每一個單詞，背後都有着許多用法，許多表達。所以，任何語言的學習，時間分配大概是，30% 的語法學習，70% 的單詞量積累。</p>\n<p>另外，在我看來，單詞量擴充的唯一方式就是閱讀，因爲只有通過語境獲得的語義，才是最自然的，最直接的，最深刻的。也只有這樣，你才能日後直到怎樣使用它。而且我非常不建議通過大量閱讀詞典的例句來積累單詞，因爲那樣的語境是割裂的。我們希求的語境一定是一條連續的線，可以往前追溯。</p>\n<p>所以我開始了大量的精讀，建立了所謂的「德語語料庫」，目前爲止積累了大概三千多的詞條。並且也同樣模式建立了「英語語料庫」和「中文語料庫」，中文語料庫這個，是自己發現自己在大學之後，過多的強調外語的學習，而忽略了中文，其實中文才是最應該好好學習的。現在來看目前的輿論風向往往是，因爲長期在英文環境裏，中文水準的下降，似乎都是一件特別值得驕傲的事。我覺得至少要做到的一點是，各個語言不要摻雜，德語裏不要混入英語，中文裏不要混入英語，講英語的話就好好只講英語。</p>\n<p>對於平復內心，我開始試着把桌子上的雜物都清理掉，把地板仔細擦上三遍。認認真真洗上一個熱水澡。認真整理電腦裏的各個文件夾，給 Evernote 裏的筆記認真歸類，打標籤。做的所有這一切，是希望營造一種儀式感。認真的把所有雜物都整理乾淨，把熵值降到最低。因爲我相信一點，你周圍的環境其實是你內心世界的真實反應。內心足夠平靜，你周圍的環境也足夠安靜，相反，內心亂糟糟，周圍肯定也亂糟糟。所以收拾心情的最好方式是整理家務，打掃房間，跑步，運動，出汗，然後清理自己的身體。</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>弱冠之年，你是否還記得年少時的夢？十六歲離家，現在已有七年，一直努力，也曾經迷茫彷徨失意絕望，一直往西，從鄭州到西安，又一個人到了德國。我們總要在無數的可能性中選擇一種，努力的活着。順境逆境，最好的狀態可能就是，「不以物喜，不以己悲。」</p>\n<p>或者不如，</p>\n<p>「骑着白马入地狱，叼着纸烟进天堂。」</p>"},{"title":"JavaScript: Semicolon 二三事","date":"2019-06-29T15:02:41.000Z","_content":"\n由于 JavaScript 拥有 *Automatic Semicolon Insertion* 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：\n\n```javascript\nlet i = 0\n\n(function test () {\n  console.log('hello')\n})()\n```\n\n这里会提示报错：\n\n```\nTypeError: 0 is not a function\n```\n\n观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。\n\n```javascript\nlet i = 0;\n\n(function test () {\n  console.log('hello')\n})()\n```\n\n关于 JavaScript 的 *Automatic Semicolon Insertion*，规则是这样的：\n\n<!--more-->\n\n1. 当下一行开头的代码和本行末尾的代码连不上；\n2. 当下一行是以 `}` 开头；\n3. 在整个文件末尾会加分号；\n4. 在 `return` 所在行末尾会加分号；\n5. 在 `break` 所在行末尾会加分号；\n6. 在 `throw` 所在行末尾会加分号；\n7. 在 `continue` 所在行末尾会加分号；\n\n上面这个例子，就是如果不在第一行加分号，则下一行以 `(` 开头，则会被当作函数调用。相似的情况还有：\n\n```javascript\nconst hey = 'hey'\nconst you = 'hey'\nconst heyYou = hey + ' ' + you\n\n['h', 'e', 'y'].forEach((letter) => console.log(letter))\n// Uncaught TypeError: Cannot read property 'forEach' of undefined\n```\n\n以及关于 return \n\n```javascript\n(() => {\n  return\n  {\n    color: 'white'\n  }\n})()\n// Instead, it’s undefined, because JavaScript inserts a semicolon after return.\n```\n\n以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。\n\nDr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：\n\n> - Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons *increase* the readability of code, because I’m so used to them.\n> - Don’t put postfix `++` (or postfix `--`) and its operand in separate lines.\n> - If the following statements have an argument, don’t put it in a separate line: `return`, `throw`, `break`, `continue`.\n> - For consistency (with `return`), if an opening brace or bracket is part of a statement, don’t put it in a separate line.\n\n\n\n参考文章：\n\n- [Semicolons in JavaScript](https://flaviocopes.com/javascript-automatic-semicolon-insertion/)\n- [Automatic semicolon insertion in JavaScript](https://2ality.com/2011/05/semicolon-insertion.html)","source":"_posts/JavaScript-Semicolon 二三事.md","raw":"---\ntitle: 'JavaScript: Semicolon 二三事'\ndate: 2019-06-29 23:02:41\ntags:\n- JavaScript\n---\n\n由于 JavaScript 拥有 *Automatic Semicolon Insertion* 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：\n\n```javascript\nlet i = 0\n\n(function test () {\n  console.log('hello')\n})()\n```\n\n这里会提示报错：\n\n```\nTypeError: 0 is not a function\n```\n\n观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。\n\n```javascript\nlet i = 0;\n\n(function test () {\n  console.log('hello')\n})()\n```\n\n关于 JavaScript 的 *Automatic Semicolon Insertion*，规则是这样的：\n\n<!--more-->\n\n1. 当下一行开头的代码和本行末尾的代码连不上；\n2. 当下一行是以 `}` 开头；\n3. 在整个文件末尾会加分号；\n4. 在 `return` 所在行末尾会加分号；\n5. 在 `break` 所在行末尾会加分号；\n6. 在 `throw` 所在行末尾会加分号；\n7. 在 `continue` 所在行末尾会加分号；\n\n上面这个例子，就是如果不在第一行加分号，则下一行以 `(` 开头，则会被当作函数调用。相似的情况还有：\n\n```javascript\nconst hey = 'hey'\nconst you = 'hey'\nconst heyYou = hey + ' ' + you\n\n['h', 'e', 'y'].forEach((letter) => console.log(letter))\n// Uncaught TypeError: Cannot read property 'forEach' of undefined\n```\n\n以及关于 return \n\n```javascript\n(() => {\n  return\n  {\n    color: 'white'\n  }\n})()\n// Instead, it’s undefined, because JavaScript inserts a semicolon after return.\n```\n\n以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。\n\nDr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：\n\n> - Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons *increase* the readability of code, because I’m so used to them.\n> - Don’t put postfix `++` (or postfix `--`) and its operand in separate lines.\n> - If the following statements have an argument, don’t put it in a separate line: `return`, `throw`, `break`, `continue`.\n> - For consistency (with `return`), if an opening brace or bracket is part of a statement, don’t put it in a separate line.\n\n\n\n参考文章：\n\n- [Semicolons in JavaScript](https://flaviocopes.com/javascript-automatic-semicolon-insertion/)\n- [Automatic semicolon insertion in JavaScript](https://2ality.com/2011/05/semicolon-insertion.html)","slug":"JavaScript-Semicolon 二三事","published":1,"updated":"2019-06-29T17:02:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx27001irg1vd2vl0v8z","content":"<p>由于 JavaScript 拥有 <em>Automatic Semicolon Insertion</em> 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：</p>\n<pre><code class=\"javascript\">let i = 0\n\n(function test () &#123;\n  console.log(&#39;hello&#39;)\n&#125;)()\n</code></pre>\n<p>这里会提示报错：</p>\n<pre><code>TypeError: 0 is not a function\n</code></pre>\n<p>观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。</p>\n<pre><code class=\"javascript\">let i = 0;\n\n(function test () &#123;\n  console.log(&#39;hello&#39;)\n&#125;)()\n</code></pre>\n<p>关于 JavaScript 的 <em>Automatic Semicolon Insertion</em>，规则是这样的：</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>当下一行开头的代码和本行末尾的代码连不上；</li>\n<li>当下一行是以 <code>&#125;</code> 开头；</li>\n<li>在整个文件末尾会加分号；</li>\n<li>在 <code>return</code> 所在行末尾会加分号；</li>\n<li>在 <code>break</code> 所在行末尾会加分号；</li>\n<li>在 <code>throw</code> 所在行末尾会加分号；</li>\n<li>在 <code>continue</code> 所在行末尾会加分号；</li>\n</ol>\n<p>上面这个例子，就是如果不在第一行加分号，则下一行以 <code>(</code> 开头，则会被当作函数调用。相似的情况还有：</p>\n<pre><code class=\"javascript\">const hey = &#39;hey&#39;\nconst you = &#39;hey&#39;\nconst heyYou = hey + &#39; &#39; + you\n\n[&#39;h&#39;, &#39;e&#39;, &#39;y&#39;].forEach((letter) =&gt; console.log(letter))\n// Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined\n</code></pre>\n<p>以及关于 return </p>\n<pre><code class=\"javascript\">(() =&gt; &#123;\n  return\n  &#123;\n    color: &#39;white&#39;\n  &#125;\n&#125;)()\n// Instead, it’s undefined, because JavaScript inserts a semicolon after return.\n</code></pre>\n<p>以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。</p>\n<p>Dr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：</p>\n<blockquote>\n<ul>\n<li>Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons <em>increase</em> the readability of code, because I’m so used to them.</li>\n<li>Don’t put postfix <code>++</code> (or postfix <code>--</code>) and its operand in separate lines.</li>\n<li>If the following statements have an argument, don’t put it in a separate line: <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>.</li>\n<li>For consistency (with <code>return</code>), if an opening brace or bracket is part of a statement, don’t put it in a separate line.</li>\n</ul>\n</blockquote>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://flaviocopes.com/javascript-automatic-semicolon-insertion/\">Semicolons in JavaScript</a></li>\n<li><a href=\"https://2ality.com/2011/05/semicolon-insertion.html\">Automatic semicolon insertion in JavaScript</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>由于 JavaScript 拥有 <em>Automatic Semicolon Insertion</em> 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：</p>\n<pre><code class=\"javascript\">let i = 0\n\n(function test () &#123;\n  console.log(&#39;hello&#39;)\n&#125;)()\n</code></pre>\n<p>这里会提示报错：</p>\n<pre><code>TypeError: 0 is not a function\n</code></pre>\n<p>观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。</p>\n<pre><code class=\"javascript\">let i = 0;\n\n(function test () &#123;\n  console.log(&#39;hello&#39;)\n&#125;)()\n</code></pre>\n<p>关于 JavaScript 的 <em>Automatic Semicolon Insertion</em>，规则是这样的：</p>","more":"<ol>\n<li>当下一行开头的代码和本行末尾的代码连不上；</li>\n<li>当下一行是以 <code>&#125;</code> 开头；</li>\n<li>在整个文件末尾会加分号；</li>\n<li>在 <code>return</code> 所在行末尾会加分号；</li>\n<li>在 <code>break</code> 所在行末尾会加分号；</li>\n<li>在 <code>throw</code> 所在行末尾会加分号；</li>\n<li>在 <code>continue</code> 所在行末尾会加分号；</li>\n</ol>\n<p>上面这个例子，就是如果不在第一行加分号，则下一行以 <code>(</code> 开头，则会被当作函数调用。相似的情况还有：</p>\n<pre><code class=\"javascript\">const hey = &#39;hey&#39;\nconst you = &#39;hey&#39;\nconst heyYou = hey + &#39; &#39; + you\n\n[&#39;h&#39;, &#39;e&#39;, &#39;y&#39;].forEach((letter) =&gt; console.log(letter))\n// Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined\n</code></pre>\n<p>以及关于 return </p>\n<pre><code class=\"javascript\">(() =&gt; &#123;\n  return\n  &#123;\n    color: &#39;white&#39;\n  &#125;\n&#125;)()\n// Instead, it’s undefined, because JavaScript inserts a semicolon after return.\n</code></pre>\n<p>以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。</p>\n<p>Dr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：</p>\n<blockquote>\n<ul>\n<li>Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons <em>increase</em> the readability of code, because I’m so used to them.</li>\n<li>Don’t put postfix <code>++</code> (or postfix <code>--</code>) and its operand in separate lines.</li>\n<li>If the following statements have an argument, don’t put it in a separate line: <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>.</li>\n<li>For consistency (with <code>return</code>), if an opening brace or bracket is part of a statement, don’t put it in a separate line.</li>\n</ul>\n</blockquote>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://flaviocopes.com/javascript-automatic-semicolon-insertion/\">Semicolons in JavaScript</a></li>\n<li><a href=\"https://2ality.com/2011/05/semicolon-insertion.html\">Automatic semicolon insertion in JavaScript</a></li>\n</ul>"},{"title":"JSON Web Token 的产生和认证","date":"2019-06-12T05:49:07.000Z","_content":"\n## Cookie-based vs Token-based\n\n有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：\n\ncookie-based authentication 的认证流程是:\n\n1. 用户填写 credentials，包括用户名，邮箱，密码这些内容；\n2. Server 服务器验证这些 credentials 是否正确，如果正确，则**认证成功**，创建一个 session 存储在数据库中；\n3. 将这个 session 的 session id 存储在浏览器端的 cookie 里；\n4. 接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；\n5. 一旦用户登出，client 端和 server 端的 session 均被摧毁；\n\ntoken-based authentication:\n\n1. 用户填写 credentials，包括用户名，邮箱，密码；\n2. Server 服务器验证这些 credentials 是否正确，如果**认证成功**，则返回一个 signed token；\n3. 这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；\n4. 接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。\n5. Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；\n\n![auto01](/images/auto01.png)\n\n为什么会说 token-based 更好：\n\n1. stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；\n2. cookie 对跨域 CORS 操作不友好，token 则没有这个问题；\n\n\n\n<!--more-->\n\n## JWT 如何产生的\n\n一条完整的 JWT 格式是这样的：`header.payload.signature`。\n\n第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：\n\n```javascript\nconst header = {\n    typ: \"JWT\",\n    alg: \"HS256\"\n}\n```\n\n`\"typ\"` 声明这是一个 JWT，`\"alg\"` 声明所有是用的 hash 算法；\n\n第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，\n\n```javascript\nconst payload = {\n    userId: \"b08f86af-35da-48f2-8fab-cef3904660bd\"\n}\n```\n\n对于 JWT 的 payload，会有一些标准，比如 `iss` 代表 issuer，`sub` 代表 subject，`exp` 代表 expiration time。\n\n第三步，创建 signature 签名。\n\n```javascript\nconst encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64')\nconst encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64')\n```\n\n将 header 和 payload 都使用 base64 编码。\n\n```javascript\nconst crypto = require('crypto')\nconst jwtSecret = 'secretKey'\n\nconst signature = crypto.createHmac('sha256', jwtSecret).update(encodedHeader + '.' + encodedPayload).digest('base64')\n```\n\nbase64 编码后的文本使用 `.` 连接，再进行 hash，hash 后的文本再进行 base64 编码。\n\n最终 JWT 为：\n\n```javascript\nconst jwt = `${encodedHeader}.${encodedPayload}.${signature}`\n```\n\n## JWT 的认证\n\n> The **very** important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is **not** encrypted. If I go to [jwt.io](https://jwt.io/), paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.\n>\n> — [Cookies vs. Tokens: The Definitive Guide](https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide)\n\n一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 `HttpOnly Cookie`，不同于传统 cookie，标有 `HttpOnly` 的 cookie 只能由 Server 端获取。\n\n登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 `Authorization` 里，以 Bearer 作为开头：\n\n```yaml\nAuthorization: Bearer <token>\n```\n\n服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：\n\n1. 验证 JWT 的格式是否正确；\n2. 验证 signature 签名；\n3. 验证在 payload 里的 standard claims；\n4. 验证许可权限范围；\n\n在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。\n\n> The API needs to check if the algorithm, as specified by the JWT header (property `alg`), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.\n>\n> To check if the signature matches the API's expectations, you have to decode the JWT and retrieve the `alg` property of the JWT header.\n>\n> Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:\n>\n> — [Verify Access Tokens for Custom APIs](https://auth0.com/docs/api-auth/tutorials/verify-access-token)\n\n\n\n## 在 express 里实际应用\n\n[Node.js API Authentication With JWT](https://www.youtube.com/watch?v=7nafaH9SddU)\n\n这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：\n\n```javascript\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\n\napp.get('/api', (req, res) => {\n  res.json({\n    messgae: 'welcome to the api'\n  })\n});\n\napp.post('/api/posts', verifyToken, (req, res) => {\n  jwt.verify(req.token, 'secretkey', (err, authData) => {\n    if (err) {\n      res.sendStatus(403);\n    } else {\n      res.json({\n        message: 'post created ...',\n        authData\n      })\n    }\n  })\n  \n})\n\napp.post('/api/login', (req, res) => {\n  // Mock user\n  const user = {\n    id: 1,\n    usernmae: 'brad',\n    email: 'brad@gamil.com'\n  }\n  jwt.sign({user}, 'secretkey', (err, token) => {\n    res.json({\n      token\n    })\n  });\n});\n\n// Format of Token\n// Authorization: Bearer <access_token>\n\n// Verify Token\n\nfunction verifyToken(req, res, next) {\n  // Get auth header value;\n  const bearerHeader = req.headers['authorization'];\n  // Check if bearer is undefined\n  if (typeof bearerHeader !== 'undefined') {\n    // Split at the space\n    const bearer = bearerHeader.split(' ');\n    // Get token from array\n    const bearerToken = bearer[1];\n    // Set the token\n    req.token = bearerToken;\n    // Next middleware\n    next();\n  } else {\n    // Forbidden\n    res.sendStatus(403);\n  }\n\n}\n\napp.listen(5000, () => console.log('server started on 5000'))\n```\n\n通过 `jwt.sign()` 进行签名。\n\n函数 `verifyToken`  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 `req.token`  里，具体的认证是通过 `jwt.verify()` 实现的。\n\n## HS256 vs RS256\n\n前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。\n\n> For `RS256`, the tenant's [JSON Web Key Set (JWKS)](https://auth0.com/docs/jwks) is used. Your tenant's JWKS is `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。\n\n![auth02](/images/auth02.png) \n\n参考：\n\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n- [Cookies vs. Tokens: The Definitive Guide](https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide)\n- [JSON Web Token (JWT) explained](https://flaviocopes.com/jwt/)\n- [5 Easy Steps to Understanding JSON Web Tokens (JWT)](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)\n- [Verify Access Tokens for Custom APIs](https://auth0.com/docs/api-auth/tutorials/verify-access-token)\n- [JSON Web Key Set](https://auth0.com/docs/jwks)\n- [JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519#section-7.2)\n\n","source":"_posts/JSON-Web-Token-的产生和认证.md","raw":"---\ntitle: JSON Web Token 的产生和认证\ndate: 2019-06-12 13:49:07\ntags:\n- JavaScript\n---\n\n## Cookie-based vs Token-based\n\n有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：\n\ncookie-based authentication 的认证流程是:\n\n1. 用户填写 credentials，包括用户名，邮箱，密码这些内容；\n2. Server 服务器验证这些 credentials 是否正确，如果正确，则**认证成功**，创建一个 session 存储在数据库中；\n3. 将这个 session 的 session id 存储在浏览器端的 cookie 里；\n4. 接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；\n5. 一旦用户登出，client 端和 server 端的 session 均被摧毁；\n\ntoken-based authentication:\n\n1. 用户填写 credentials，包括用户名，邮箱，密码；\n2. Server 服务器验证这些 credentials 是否正确，如果**认证成功**，则返回一个 signed token；\n3. 这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；\n4. 接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。\n5. Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；\n\n![auto01](/images/auto01.png)\n\n为什么会说 token-based 更好：\n\n1. stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；\n2. cookie 对跨域 CORS 操作不友好，token 则没有这个问题；\n\n\n\n<!--more-->\n\n## JWT 如何产生的\n\n一条完整的 JWT 格式是这样的：`header.payload.signature`。\n\n第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：\n\n```javascript\nconst header = {\n    typ: \"JWT\",\n    alg: \"HS256\"\n}\n```\n\n`\"typ\"` 声明这是一个 JWT，`\"alg\"` 声明所有是用的 hash 算法；\n\n第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，\n\n```javascript\nconst payload = {\n    userId: \"b08f86af-35da-48f2-8fab-cef3904660bd\"\n}\n```\n\n对于 JWT 的 payload，会有一些标准，比如 `iss` 代表 issuer，`sub` 代表 subject，`exp` 代表 expiration time。\n\n第三步，创建 signature 签名。\n\n```javascript\nconst encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64')\nconst encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64')\n```\n\n将 header 和 payload 都使用 base64 编码。\n\n```javascript\nconst crypto = require('crypto')\nconst jwtSecret = 'secretKey'\n\nconst signature = crypto.createHmac('sha256', jwtSecret).update(encodedHeader + '.' + encodedPayload).digest('base64')\n```\n\nbase64 编码后的文本使用 `.` 连接，再进行 hash，hash 后的文本再进行 base64 编码。\n\n最终 JWT 为：\n\n```javascript\nconst jwt = `${encodedHeader}.${encodedPayload}.${signature}`\n```\n\n## JWT 的认证\n\n> The **very** important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is **not** encrypted. If I go to [jwt.io](https://jwt.io/), paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.\n>\n> — [Cookies vs. Tokens: The Definitive Guide](https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide)\n\n一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 `HttpOnly Cookie`，不同于传统 cookie，标有 `HttpOnly` 的 cookie 只能由 Server 端获取。\n\n登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 `Authorization` 里，以 Bearer 作为开头：\n\n```yaml\nAuthorization: Bearer <token>\n```\n\n服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：\n\n1. 验证 JWT 的格式是否正确；\n2. 验证 signature 签名；\n3. 验证在 payload 里的 standard claims；\n4. 验证许可权限范围；\n\n在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。\n\n> The API needs to check if the algorithm, as specified by the JWT header (property `alg`), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.\n>\n> To check if the signature matches the API's expectations, you have to decode the JWT and retrieve the `alg` property of the JWT header.\n>\n> Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:\n>\n> — [Verify Access Tokens for Custom APIs](https://auth0.com/docs/api-auth/tutorials/verify-access-token)\n\n\n\n## 在 express 里实际应用\n\n[Node.js API Authentication With JWT](https://www.youtube.com/watch?v=7nafaH9SddU)\n\n这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：\n\n```javascript\nconst express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\n\napp.get('/api', (req, res) => {\n  res.json({\n    messgae: 'welcome to the api'\n  })\n});\n\napp.post('/api/posts', verifyToken, (req, res) => {\n  jwt.verify(req.token, 'secretkey', (err, authData) => {\n    if (err) {\n      res.sendStatus(403);\n    } else {\n      res.json({\n        message: 'post created ...',\n        authData\n      })\n    }\n  })\n  \n})\n\napp.post('/api/login', (req, res) => {\n  // Mock user\n  const user = {\n    id: 1,\n    usernmae: 'brad',\n    email: 'brad@gamil.com'\n  }\n  jwt.sign({user}, 'secretkey', (err, token) => {\n    res.json({\n      token\n    })\n  });\n});\n\n// Format of Token\n// Authorization: Bearer <access_token>\n\n// Verify Token\n\nfunction verifyToken(req, res, next) {\n  // Get auth header value;\n  const bearerHeader = req.headers['authorization'];\n  // Check if bearer is undefined\n  if (typeof bearerHeader !== 'undefined') {\n    // Split at the space\n    const bearer = bearerHeader.split(' ');\n    // Get token from array\n    const bearerToken = bearer[1];\n    // Set the token\n    req.token = bearerToken;\n    // Next middleware\n    next();\n  } else {\n    // Forbidden\n    res.sendStatus(403);\n  }\n\n}\n\napp.listen(5000, () => console.log('server started on 5000'))\n```\n\n通过 `jwt.sign()` 进行签名。\n\n函数 `verifyToken`  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 `req.token`  里，具体的认证是通过 `jwt.verify()` 实现的。\n\n## HS256 vs RS256\n\n前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。\n\n> For `RS256`, the tenant's [JSON Web Key Set (JWKS)](https://auth0.com/docs/jwks) is used. Your tenant's JWKS is `https://YOUR_DOMAIN/.well-known/jwks.json`.\n\n通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。\n\n![auth02](/images/auth02.png) \n\n参考：\n\n- [Introduction to JSON Web Tokens](https://jwt.io/introduction/)\n- [Cookies vs. Tokens: The Definitive Guide](https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide)\n- [JSON Web Token (JWT) explained](https://flaviocopes.com/jwt/)\n- [5 Easy Steps to Understanding JSON Web Tokens (JWT)](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)\n- [Verify Access Tokens for Custom APIs](https://auth0.com/docs/api-auth/tutorials/verify-access-token)\n- [JSON Web Key Set](https://auth0.com/docs/jwks)\n- [JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519#section-7.2)\n\n","slug":"JSON-Web-Token-的产生和认证","published":1,"updated":"2019-06-12T08:28:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx27001krg1v0c0u8xmc","content":"<h2 id=\"Cookie-based-vs-Token-based\"><a href=\"#Cookie-based-vs-Token-based\" class=\"headerlink\" title=\"Cookie-based vs Token-based\"></a>Cookie-based vs Token-based</h2><p>有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：</p>\n<p>cookie-based authentication 的认证流程是:</p>\n<ol>\n<li>用户填写 credentials，包括用户名，邮箱，密码这些内容；</li>\n<li>Server 服务器验证这些 credentials 是否正确，如果正确，则<strong>认证成功</strong>，创建一个 session 存储在数据库中；</li>\n<li>将这个 session 的 session id 存储在浏览器端的 cookie 里；</li>\n<li>接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；</li>\n<li>一旦用户登出，client 端和 server 端的 session 均被摧毁；</li>\n</ol>\n<p>token-based authentication:</p>\n<ol>\n<li>用户填写 credentials，包括用户名，邮箱，密码；</li>\n<li>Server 服务器验证这些 credentials 是否正确，如果<strong>认证成功</strong>，则返回一个 signed token；</li>\n<li>这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；</li>\n<li>接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。</li>\n<li>Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；</li>\n</ol>\n<p><img src=\"/images/auto01.png\" alt=\"auto01\"></p>\n<p>为什么会说 token-based 更好：</p>\n<ol>\n<li>stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；</li>\n<li>cookie 对跨域 CORS 操作不友好，token 则没有这个问题；</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"JWT-如何产生的\"><a href=\"#JWT-如何产生的\" class=\"headerlink\" title=\"JWT 如何产生的\"></a>JWT 如何产生的</h2><p>一条完整的 JWT 格式是这样的：<code>header.payload.signature</code>。</p>\n<p>第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：</p>\n<pre><code class=\"javascript\">const header = &#123;\n    typ: &quot;JWT&quot;,\n    alg: &quot;HS256&quot;\n&#125;\n</code></pre>\n<p><code>&quot;typ&quot;</code> 声明这是一个 JWT，<code>&quot;alg&quot;</code> 声明所有是用的 hash 算法；</p>\n<p>第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，</p>\n<pre><code class=\"javascript\">const payload = &#123;\n    userId: &quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;\n&#125;\n</code></pre>\n<p>对于 JWT 的 payload，会有一些标准，比如 <code>iss</code> 代表 issuer，<code>sub</code> 代表 subject，<code>exp</code> 代表 expiration time。</p>\n<p>第三步，创建 signature 签名。</p>\n<pre><code class=\"javascript\">const encodedHeader = Buffer.from(JSON.stringify(header)).toString(&#39;base64&#39;)\nconst encodedPayload = Buffer.from(JSON.stringify(payload)).toString(&#39;base64&#39;)\n</code></pre>\n<p>将 header 和 payload 都使用 base64 编码。</p>\n<pre><code class=\"javascript\">const crypto = require(&#39;crypto&#39;)\nconst jwtSecret = &#39;secretKey&#39;\n\nconst signature = crypto.createHmac(&#39;sha256&#39;, jwtSecret).update(encodedHeader + &#39;.&#39; + encodedPayload).digest(&#39;base64&#39;)\n</code></pre>\n<p>base64 编码后的文本使用 <code>.</code> 连接，再进行 hash，hash 后的文本再进行 base64 编码。</p>\n<p>最终 JWT 为：</p>\n<pre><code class=\"javascript\">const jwt = `$&#123;encodedHeader&#125;.$&#123;encodedPayload&#125;.$&#123;signature&#125;`\n</code></pre>\n<h2 id=\"JWT-的认证\"><a href=\"#JWT-的认证\" class=\"headerlink\" title=\"JWT 的认证\"></a>JWT 的认证</h2><blockquote>\n<p>The <strong>very</strong> important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is <strong>not</strong> encrypted. If I go to <a href=\"https://jwt.io/\">jwt.io</a>, paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.</p>\n<p>— <a href=\"https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide\">Cookies vs. Tokens: The Definitive Guide</a></p>\n</blockquote>\n<p>一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 <code>HttpOnly Cookie</code>，不同于传统 cookie，标有 <code>HttpOnly</code> 的 cookie 只能由 Server 端获取。</p>\n<p>登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 <code>Authorization</code> 里，以 Bearer 作为开头：</p>\n<pre><code class=\"yaml\">Authorization: Bearer &lt;token&gt;\n</code></pre>\n<p>服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：</p>\n<ol>\n<li>验证 JWT 的格式是否正确；</li>\n<li>验证 signature 签名；</li>\n<li>验证在 payload 里的 standard claims；</li>\n<li>验证许可权限范围；</li>\n</ol>\n<p>在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。</p>\n<blockquote>\n<p>The API needs to check if the algorithm, as specified by the JWT header (property <code>alg</code>), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.</p>\n<p>To check if the signature matches the API’s expectations, you have to decode the JWT and retrieve the <code>alg</code> property of the JWT header.</p>\n<p>Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:</p>\n<p>— <a href=\"https://auth0.com/docs/api-auth/tutorials/verify-access-token\">Verify Access Tokens for Custom APIs</a></p>\n</blockquote>\n<h2 id=\"在-express-里实际应用\"><a href=\"#在-express-里实际应用\" class=\"headerlink\" title=\"在 express 里实际应用\"></a>在 express 里实际应用</h2><p><a href=\"https://www.youtube.com/watch?v=7nafaH9SddU\">Node.js API Authentication With JWT</a></p>\n<p>这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：</p>\n<pre><code class=\"javascript\">const express = require(&#39;express&#39;);\nconst jwt = require(&#39;jsonwebtoken&#39;);\n\nconst app = express();\n\napp.get(&#39;/api&#39;, (req, res) =&gt; &#123;\n  res.json(&#123;\n    messgae: &#39;welcome to the api&#39;\n  &#125;)\n&#125;);\n\napp.post(&#39;/api/posts&#39;, verifyToken, (req, res) =&gt; &#123;\n  jwt.verify(req.token, &#39;secretkey&#39;, (err, authData) =&gt; &#123;\n    if (err) &#123;\n      res.sendStatus(403);\n    &#125; else &#123;\n      res.json(&#123;\n        message: &#39;post created ...&#39;,\n        authData\n      &#125;)\n    &#125;\n  &#125;)\n  \n&#125;)\n\napp.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;\n  // Mock user\n  const user = &#123;\n    id: 1,\n    usernmae: &#39;brad&#39;,\n    email: &#39;brad@gamil.com&#39;\n  &#125;\n  jwt.sign(&#123;user&#125;, &#39;secretkey&#39;, (err, token) =&gt; &#123;\n    res.json(&#123;\n      token\n    &#125;)\n  &#125;);\n&#125;);\n\n// Format of Token\n// Authorization: Bearer &lt;access_token&gt;\n\n// Verify Token\n\nfunction verifyToken(req, res, next) &#123;\n  // Get auth header value;\n  const bearerHeader = req.headers[&#39;authorization&#39;];\n  // Check if bearer is undefined\n  if (typeof bearerHeader !== &#39;undefined&#39;) &#123;\n    // Split at the space\n    const bearer = bearerHeader.split(&#39; &#39;);\n    // Get token from array\n    const bearerToken = bearer[1];\n    // Set the token\n    req.token = bearerToken;\n    // Next middleware\n    next();\n  &#125; else &#123;\n    // Forbidden\n    res.sendStatus(403);\n  &#125;\n\n&#125;\n\napp.listen(5000, () =&gt; console.log(&#39;server started on 5000&#39;))\n</code></pre>\n<p>通过 <code>jwt.sign()</code> 进行签名。</p>\n<p>函数 <code>verifyToken</code>  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 <code>req.token</code>  里，具体的认证是通过 <code>jwt.verify()</code> 实现的。</p>\n<h2 id=\"HS256-vs-RS256\"><a href=\"#HS256-vs-RS256\" class=\"headerlink\" title=\"HS256 vs RS256\"></a>HS256 vs RS256</h2><p>前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。</p>\n<blockquote>\n<p>For <code>RS256</code>, the tenant’s <a href=\"https://auth0.com/docs/jwks\">JSON Web Key Set (JWKS)</a> is used. Your tenant’s JWKS is <code>https://YOUR_DOMAIN/.well-known/jwks.json</code>.</p>\n</blockquote>\n<p>通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。</p>\n<p><img src=\"/images/auth02.png\" alt=\"auth02\"> </p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://jwt.io/introduction/\">Introduction to JSON Web Tokens</a></li>\n<li><a href=\"https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide\">Cookies vs. Tokens: The Definitive Guide</a></li>\n<li><a href=\"https://flaviocopes.com/jwt/\">JSON Web Token (JWT) explained</a></li>\n<li><a href=\"https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec\">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li>\n<li><a href=\"https://auth0.com/docs/api-auth/tutorials/verify-access-token\">Verify Access Tokens for Custom APIs</a></li>\n<li><a href=\"https://auth0.com/docs/jwks\">JSON Web Key Set</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7519#section-7.2\">JSON Web Token (JWT)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Cookie-based-vs-Token-based\"><a href=\"#Cookie-based-vs-Token-based\" class=\"headerlink\" title=\"Cookie-based vs Token-based\"></a>Cookie-based vs Token-based</h2><p>有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：</p>\n<p>cookie-based authentication 的认证流程是:</p>\n<ol>\n<li>用户填写 credentials，包括用户名，邮箱，密码这些内容；</li>\n<li>Server 服务器验证这些 credentials 是否正确，如果正确，则<strong>认证成功</strong>，创建一个 session 存储在数据库中；</li>\n<li>将这个 session 的 session id 存储在浏览器端的 cookie 里；</li>\n<li>接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；</li>\n<li>一旦用户登出，client 端和 server 端的 session 均被摧毁；</li>\n</ol>\n<p>token-based authentication:</p>\n<ol>\n<li>用户填写 credentials，包括用户名，邮箱，密码；</li>\n<li>Server 服务器验证这些 credentials 是否正确，如果<strong>认证成功</strong>，则返回一个 signed token；</li>\n<li>这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；</li>\n<li>接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。</li>\n<li>Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；</li>\n</ol>\n<p><img src=\"/images/auto01.png\" alt=\"auto01\"></p>\n<p>为什么会说 token-based 更好：</p>\n<ol>\n<li>stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；</li>\n<li>cookie 对跨域 CORS 操作不友好，token 则没有这个问题；</li>\n</ol>","more":"<h2 id=\"JWT-如何产生的\"><a href=\"#JWT-如何产生的\" class=\"headerlink\" title=\"JWT 如何产生的\"></a>JWT 如何产生的</h2><p>一条完整的 JWT 格式是这样的：<code>header.payload.signature</code>。</p>\n<p>第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：</p>\n<pre><code class=\"javascript\">const header = &#123;\n    typ: &quot;JWT&quot;,\n    alg: &quot;HS256&quot;\n&#125;\n</code></pre>\n<p><code>&quot;typ&quot;</code> 声明这是一个 JWT，<code>&quot;alg&quot;</code> 声明所有是用的 hash 算法；</p>\n<p>第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，</p>\n<pre><code class=\"javascript\">const payload = &#123;\n    userId: &quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;\n&#125;\n</code></pre>\n<p>对于 JWT 的 payload，会有一些标准，比如 <code>iss</code> 代表 issuer，<code>sub</code> 代表 subject，<code>exp</code> 代表 expiration time。</p>\n<p>第三步，创建 signature 签名。</p>\n<pre><code class=\"javascript\">const encodedHeader = Buffer.from(JSON.stringify(header)).toString(&#39;base64&#39;)\nconst encodedPayload = Buffer.from(JSON.stringify(payload)).toString(&#39;base64&#39;)\n</code></pre>\n<p>将 header 和 payload 都使用 base64 编码。</p>\n<pre><code class=\"javascript\">const crypto = require(&#39;crypto&#39;)\nconst jwtSecret = &#39;secretKey&#39;\n\nconst signature = crypto.createHmac(&#39;sha256&#39;, jwtSecret).update(encodedHeader + &#39;.&#39; + encodedPayload).digest(&#39;base64&#39;)\n</code></pre>\n<p>base64 编码后的文本使用 <code>.</code> 连接，再进行 hash，hash 后的文本再进行 base64 编码。</p>\n<p>最终 JWT 为：</p>\n<pre><code class=\"javascript\">const jwt = `$&#123;encodedHeader&#125;.$&#123;encodedPayload&#125;.$&#123;signature&#125;`\n</code></pre>\n<h2 id=\"JWT-的认证\"><a href=\"#JWT-的认证\" class=\"headerlink\" title=\"JWT 的认证\"></a>JWT 的认证</h2><blockquote>\n<p>The <strong>very</strong> important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is <strong>not</strong> encrypted. If I go to <a href=\"https://jwt.io/\">jwt.io</a>, paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.</p>\n<p>— <a href=\"https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide\">Cookies vs. Tokens: The Definitive Guide</a></p>\n</blockquote>\n<p>一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 <code>HttpOnly Cookie</code>，不同于传统 cookie，标有 <code>HttpOnly</code> 的 cookie 只能由 Server 端获取。</p>\n<p>登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 <code>Authorization</code> 里，以 Bearer 作为开头：</p>\n<pre><code class=\"yaml\">Authorization: Bearer &lt;token&gt;\n</code></pre>\n<p>服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：</p>\n<ol>\n<li>验证 JWT 的格式是否正确；</li>\n<li>验证 signature 签名；</li>\n<li>验证在 payload 里的 standard claims；</li>\n<li>验证许可权限范围；</li>\n</ol>\n<p>在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。</p>\n<blockquote>\n<p>The API needs to check if the algorithm, as specified by the JWT header (property <code>alg</code>), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.</p>\n<p>To check if the signature matches the API’s expectations, you have to decode the JWT and retrieve the <code>alg</code> property of the JWT header.</p>\n<p>Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:</p>\n<p>— <a href=\"https://auth0.com/docs/api-auth/tutorials/verify-access-token\">Verify Access Tokens for Custom APIs</a></p>\n</blockquote>\n<h2 id=\"在-express-里实际应用\"><a href=\"#在-express-里实际应用\" class=\"headerlink\" title=\"在 express 里实际应用\"></a>在 express 里实际应用</h2><p><a href=\"https://www.youtube.com/watch?v=7nafaH9SddU\">Node.js API Authentication With JWT</a></p>\n<p>这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：</p>\n<pre><code class=\"javascript\">const express = require(&#39;express&#39;);\nconst jwt = require(&#39;jsonwebtoken&#39;);\n\nconst app = express();\n\napp.get(&#39;/api&#39;, (req, res) =&gt; &#123;\n  res.json(&#123;\n    messgae: &#39;welcome to the api&#39;\n  &#125;)\n&#125;);\n\napp.post(&#39;/api/posts&#39;, verifyToken, (req, res) =&gt; &#123;\n  jwt.verify(req.token, &#39;secretkey&#39;, (err, authData) =&gt; &#123;\n    if (err) &#123;\n      res.sendStatus(403);\n    &#125; else &#123;\n      res.json(&#123;\n        message: &#39;post created ...&#39;,\n        authData\n      &#125;)\n    &#125;\n  &#125;)\n  \n&#125;)\n\napp.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;\n  // Mock user\n  const user = &#123;\n    id: 1,\n    usernmae: &#39;brad&#39;,\n    email: &#39;brad@gamil.com&#39;\n  &#125;\n  jwt.sign(&#123;user&#125;, &#39;secretkey&#39;, (err, token) =&gt; &#123;\n    res.json(&#123;\n      token\n    &#125;)\n  &#125;);\n&#125;);\n\n// Format of Token\n// Authorization: Bearer &lt;access_token&gt;\n\n// Verify Token\n\nfunction verifyToken(req, res, next) &#123;\n  // Get auth header value;\n  const bearerHeader = req.headers[&#39;authorization&#39;];\n  // Check if bearer is undefined\n  if (typeof bearerHeader !== &#39;undefined&#39;) &#123;\n    // Split at the space\n    const bearer = bearerHeader.split(&#39; &#39;);\n    // Get token from array\n    const bearerToken = bearer[1];\n    // Set the token\n    req.token = bearerToken;\n    // Next middleware\n    next();\n  &#125; else &#123;\n    // Forbidden\n    res.sendStatus(403);\n  &#125;\n\n&#125;\n\napp.listen(5000, () =&gt; console.log(&#39;server started on 5000&#39;))\n</code></pre>\n<p>通过 <code>jwt.sign()</code> 进行签名。</p>\n<p>函数 <code>verifyToken</code>  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 <code>req.token</code>  里，具体的认证是通过 <code>jwt.verify()</code> 实现的。</p>\n<h2 id=\"HS256-vs-RS256\"><a href=\"#HS256-vs-RS256\" class=\"headerlink\" title=\"HS256 vs RS256\"></a>HS256 vs RS256</h2><p>前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。</p>\n<blockquote>\n<p>For <code>RS256</code>, the tenant’s <a href=\"https://auth0.com/docs/jwks\">JSON Web Key Set (JWKS)</a> is used. Your tenant’s JWKS is <code>https://YOUR_DOMAIN/.well-known/jwks.json</code>.</p>\n</blockquote>\n<p>通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。</p>\n<p><img src=\"/images/auth02.png\" alt=\"auth02\"> </p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://jwt.io/introduction/\">Introduction to JSON Web Tokens</a></li>\n<li><a href=\"https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide\">Cookies vs. Tokens: The Definitive Guide</a></li>\n<li><a href=\"https://flaviocopes.com/jwt/\">JSON Web Token (JWT) explained</a></li>\n<li><a href=\"https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec\">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li>\n<li><a href=\"https://auth0.com/docs/api-auth/tutorials/verify-access-token\">Verify Access Tokens for Custom APIs</a></li>\n<li><a href=\"https://auth0.com/docs/jwks\">JSON Web Key Set</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc7519#section-7.2\">JSON Web Token (JWT)</a></li>\n</ul>"},{"title":"JavaScript async and Promise","date":"2019-05-18T13:47:39.000Z","_content":"\n非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。\n\n## Event loop\n\nJavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是\n\n```javascript\n$.get('http://twitter.com')\n$.get('http://youtube.com')\n$.get('http://google.com')\n```\n\n在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 `setTimeout()` 函数时，程序似乎不会出现 blocking。\n\n```Javascript\nconsole.log('hi')\nsetTimeout(() => console.log('there'), 0)\nconsole.log('Welcome!')\n\n// output:\n// hi\n// Welcome\n// there\n```\n\n这里哪怕是设置 delay 为 0s， `setTimeout()` 里的函数也是在最后才执行，是怎么回事呢？\n\n在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 `setTimeout()` 函数就来自这些提供的 API 中。当我们 declare and call  一个  `setTimeout()` 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  `setTimeout()`  里定义的 callback 函数会进入到一个叫 `task queue` 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  `setTimeout()` 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。\n\n<!--more-->\n\n![Event Loop](/images/eventLoop.png)\n\n## Promise 的实现\n\nPromise 和   `setTimeout()` 的区别是，`setTimeout()` 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 `.then()` 的方法执行下一个任务。\n\n>Timeouts and Promises serve different purposes.\n>\n>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.\n>\n>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your `then()` call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.\n>\n>The reason the promise is executing before your timeout is that the promise isn't actually waiting for anything so it resolved right away.\n\n以下是来自 [Implementing](https://www.promisejs.org/implementing/)，对于 Promise object 的实现：\n\n最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 `console.log()`。\n\n```javascript\nlet PENDING = 0;\nlet FULFILLED = 1;\nlet REJECTED = 2;\n\nfunction Promise(fn) {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  let state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  let value = null;\n\n  // store sucess & failure handlers attached by calling .then or .done\n  let handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function resolve(result) {\n    try {\n      let then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject);\n        return ;\n      }\n      fulfill(result)\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  function handle(handler) {\n    if (state === PENDING) {\n      handlers.push(handler);\n    } else {\n      if (state === FULFILLED &&\n        typeof handler.onFulfilled === 'function') {\n        handler.onFulfilled(value);\n      }\n      if (state === REJECTED &&\n        typeof handler.onRejected === 'function') {\n        handler.onRejected(value);\n      }\n    }\n  }\n\n  this.done = function (onFulfilled, onRejected) {\n    // ensure we are always asynchronous\n    setTimeout(function () {\n      console.log('instantly implemented ⚠️')\n      handle({\n        onFulfilled: onFulfilled,\n        onRejected: onRejected\n      });\n    }, 0);\n  }\n  \n  doResolve(fn, resolve, reject)\n\n  this.then = function (onFulfilled, onRejected) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      return self.done(function (result) {\n        if (typeof onFulfilled === 'function') {\n          try {\n            return resolve(onFulfilled(result));\n          } catch (ex) {\n            return reject(ex);\n          }\n        } else {\n          return resolve(result);\n        }\n      }, function (error) {\n        if (typeof onRejected === 'function') {\n          try {\n            return resolve(onRejected(error));\n          } catch (ex) {\n            return reject(ex);\n          }\n        } else {\n          return reject(error);\n        }\n      });\n    });\n  }\n}\n\nfunction getThen(value) {\n  var t = typeof value;\n  if (value && (t === 'object' || t === 'function')) {\n    var then = value.then;\n    if (typeof then === 'function') {\n      return then;\n    }\n  }\n  return null;\n}\n\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n\n\nvar promise1 = new Promise(function(resolve, reject) {\n  setTimeout(function() {\n    resolve('foo');\n  }, 3000);\n});\n\npromise1.then(function(value) {\n  console.log(value)\n  // expected output: \"foo\"\n});\n\nconsole.log(promise1);\n```\n\n![Promise](/images/Promise.png)\n\n一些帮助理解这段代码的小 tips：\n\n1. `doResolve()` ，第一，会直接执行 `fn` 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 `resolve` 或是 `reject` function 仅执行一次。\n2. 每次声明 Promise object，都会先执行一次 `doResolve()` 函数；\n3. `.then()` 返回一个新的 Promise object，这个 Promise 会执行 `doResolve()`  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 `self.done()` 函数的执行结果；\n4. `.done()` 方法会 check state 的值，确定是否将 `resolve` 添加进 `handlers` 中；\n5. `resolve` 函数执行完毕后，将 `state` 从 `PENDING` 改为了 `FULFILLED`，同时 `handlers.forEach(handle)` 依次执行 `.then` 方法中添加进去的函数。\n6. `resolve` 和 `reject` 都会将值赋给 `value` 变量；\n7. `setTimeout(cb, 0)` 使用了上述提到的 event loop，此时 `cb` 会在几乎 0ms 的间隔时间后，进入 task queue。\n\n\n\n\n\n参考链接：\n\n- [What the heck is the event loop anyway? | Philip Roberts | JSConf EU](https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s)\n- [Async JS Crash Course - Callbacks, Promises, Async Await](https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s)\n\n- [Implementing](https://www.promisejs.org/implementing/)\n\n- [Basic Javascript promise implementation attempt](https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt)\n\n    ","source":"_posts/JavaScript-async-and-Promise.md","raw":"---\ntitle: 'JavaScript async and Promise'\ndate: \ntags: \n- JavaScript\ncategories: \n---\n\n非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。\n\n## Event loop\n\nJavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是\n\n```javascript\n$.get('http://twitter.com')\n$.get('http://youtube.com')\n$.get('http://google.com')\n```\n\n在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 `setTimeout()` 函数时，程序似乎不会出现 blocking。\n\n```Javascript\nconsole.log('hi')\nsetTimeout(() => console.log('there'), 0)\nconsole.log('Welcome!')\n\n// output:\n// hi\n// Welcome\n// there\n```\n\n这里哪怕是设置 delay 为 0s， `setTimeout()` 里的函数也是在最后才执行，是怎么回事呢？\n\n在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 `setTimeout()` 函数就来自这些提供的 API 中。当我们 declare and call  一个  `setTimeout()` 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  `setTimeout()`  里定义的 callback 函数会进入到一个叫 `task queue` 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  `setTimeout()` 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。\n\n<!--more-->\n\n![Event Loop](/images/eventLoop.png)\n\n## Promise 的实现\n\nPromise 和   `setTimeout()` 的区别是，`setTimeout()` 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 `.then()` 的方法执行下一个任务。\n\n>Timeouts and Promises serve different purposes.\n>\n>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.\n>\n>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your `then()` call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.\n>\n>The reason the promise is executing before your timeout is that the promise isn't actually waiting for anything so it resolved right away.\n\n以下是来自 [Implementing](https://www.promisejs.org/implementing/)，对于 Promise object 的实现：\n\n最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 `console.log()`。\n\n```javascript\nlet PENDING = 0;\nlet FULFILLED = 1;\nlet REJECTED = 2;\n\nfunction Promise(fn) {\n  // store state which can be PENDING, FULFILLED or REJECTED\n  let state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  let value = null;\n\n  // store sucess & failure handlers attached by calling .then or .done\n  let handlers = [];\n\n  function fulfill(result) {\n    state = FULFILLED;\n    value = result;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function reject(error) {\n    state = REJECTED;\n    value = error;\n    handlers.forEach(handle);\n    handlers = null;\n  }\n\n  function resolve(result) {\n    try {\n      let then = getThen(result);\n      if (then) {\n        doResolve(then.bind(result), resolve, reject);\n        return ;\n      }\n      fulfill(result)\n    } catch (e) {\n      reject(e);\n    }\n  }\n\n  function handle(handler) {\n    if (state === PENDING) {\n      handlers.push(handler);\n    } else {\n      if (state === FULFILLED &&\n        typeof handler.onFulfilled === 'function') {\n        handler.onFulfilled(value);\n      }\n      if (state === REJECTED &&\n        typeof handler.onRejected === 'function') {\n        handler.onRejected(value);\n      }\n    }\n  }\n\n  this.done = function (onFulfilled, onRejected) {\n    // ensure we are always asynchronous\n    setTimeout(function () {\n      console.log('instantly implemented ⚠️')\n      handle({\n        onFulfilled: onFulfilled,\n        onRejected: onRejected\n      });\n    }, 0);\n  }\n  \n  doResolve(fn, resolve, reject)\n\n  this.then = function (onFulfilled, onRejected) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      return self.done(function (result) {\n        if (typeof onFulfilled === 'function') {\n          try {\n            return resolve(onFulfilled(result));\n          } catch (ex) {\n            return reject(ex);\n          }\n        } else {\n          return resolve(result);\n        }\n      }, function (error) {\n        if (typeof onRejected === 'function') {\n          try {\n            return resolve(onRejected(error));\n          } catch (ex) {\n            return reject(ex);\n          }\n        } else {\n          return reject(error);\n        }\n      });\n    });\n  }\n}\n\nfunction getThen(value) {\n  var t = typeof value;\n  if (value && (t === 'object' || t === 'function')) {\n    var then = value.then;\n    if (typeof then === 'function') {\n      return then;\n    }\n  }\n  return null;\n}\n\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n\n\nvar promise1 = new Promise(function(resolve, reject) {\n  setTimeout(function() {\n    resolve('foo');\n  }, 3000);\n});\n\npromise1.then(function(value) {\n  console.log(value)\n  // expected output: \"foo\"\n});\n\nconsole.log(promise1);\n```\n\n![Promise](/images/Promise.png)\n\n一些帮助理解这段代码的小 tips：\n\n1. `doResolve()` ，第一，会直接执行 `fn` 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 `resolve` 或是 `reject` function 仅执行一次。\n2. 每次声明 Promise object，都会先执行一次 `doResolve()` 函数；\n3. `.then()` 返回一个新的 Promise object，这个 Promise 会执行 `doResolve()`  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 `self.done()` 函数的执行结果；\n4. `.done()` 方法会 check state 的值，确定是否将 `resolve` 添加进 `handlers` 中；\n5. `resolve` 函数执行完毕后，将 `state` 从 `PENDING` 改为了 `FULFILLED`，同时 `handlers.forEach(handle)` 依次执行 `.then` 方法中添加进去的函数。\n6. `resolve` 和 `reject` 都会将值赋给 `value` 变量；\n7. `setTimeout(cb, 0)` 使用了上述提到的 event loop，此时 `cb` 会在几乎 0ms 的间隔时间后，进入 task queue。\n\n\n\n\n\n参考链接：\n\n- [What the heck is the event loop anyway? | Philip Roberts | JSConf EU](https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s)\n- [Async JS Crash Course - Callbacks, Promises, Async Await](https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s)\n\n- [Implementing](https://www.promisejs.org/implementing/)\n\n- [Basic Javascript promise implementation attempt](https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt)\n\n    ","slug":"JavaScript-async-and-Promise","published":1,"updated":"2019-05-18T13:47:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx27001nrg1vb7asfy8b","content":"<p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p>\n<h2 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p>\n<pre><code class=\"javascript\">$.get(&#39;http://twitter.com&#39;)\n$.get(&#39;http://youtube.com&#39;)\n$.get(&#39;http://google.com&#39;)\n</code></pre>\n<p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p>\n<pre><code class=\"Javascript\">console.log(&#39;hi&#39;)\nsetTimeout(() =&gt; console.log(&#39;there&#39;), 0)\nconsole.log(&#39;Welcome!&#39;)\n\n// output:\n// hi\n// Welcome\n// there\n</code></pre>\n<p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p>\n<p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/images/eventLoop.png\" alt=\"Event Loop\"></p>\n<h2 id=\"Promise-的实现\"><a href=\"#Promise-的实现\" class=\"headerlink\" title=\"Promise 的实现\"></a>Promise 的实现</h2><p>Promise 和   <code>setTimeout()</code> 的区别是，<code>setTimeout()</code> 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 <code>.then()</code> 的方法执行下一个任务。</p>\n<blockquote>\n<p>Timeouts and Promises serve different purposes.</p>\n<p>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.</p>\n<p>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your <code>then()</code> call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.</p>\n<p>The reason the promise is executing before your timeout is that the promise isn’t actually waiting for anything so it resolved right away.</p>\n</blockquote>\n<p>以下是来自 <a href=\"https://www.promisejs.org/implementing/\">Implementing</a>，对于 Promise object 的实现：</p>\n<p>最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 <code>console.log()</code>。</p>\n<pre><code class=\"javascript\">let PENDING = 0;\nlet FULFILLED = 1;\nlet REJECTED = 2;\n\nfunction Promise(fn) &#123;\n  // store state which can be PENDING, FULFILLED or REJECTED\n  let state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  let value = null;\n\n  // store sucess &amp; failure handlers attached by calling .then or .done\n  let handlers = [];\n\n  function fulfill(result) &#123;\n    state = FULFILLED;\n    value = result;\n    handlers.forEach(handle);\n    handlers = null;\n  &#125;\n\n  function reject(error) &#123;\n    state = REJECTED;\n    value = error;\n    handlers.forEach(handle);\n    handlers = null;\n  &#125;\n\n  function resolve(result) &#123;\n    try &#123;\n      let then = getThen(result);\n      if (then) &#123;\n        doResolve(then.bind(result), resolve, reject);\n        return ;\n      &#125;\n      fulfill(result)\n    &#125; catch (e) &#123;\n      reject(e);\n    &#125;\n  &#125;\n\n  function handle(handler) &#123;\n    if (state === PENDING) &#123;\n      handlers.push(handler);\n    &#125; else &#123;\n      if (state === FULFILLED &amp;&amp;\n        typeof handler.onFulfilled === &#39;function&#39;) &#123;\n        handler.onFulfilled(value);\n      &#125;\n      if (state === REJECTED &amp;&amp;\n        typeof handler.onRejected === &#39;function&#39;) &#123;\n        handler.onRejected(value);\n      &#125;\n    &#125;\n  &#125;\n\n  this.done = function (onFulfilled, onRejected) &#123;\n    // ensure we are always asynchronous\n    setTimeout(function () &#123;\n      console.log(&#39;instantly implemented ⚠️&#39;)\n      handle(&#123;\n        onFulfilled: onFulfilled,\n        onRejected: onRejected\n      &#125;);\n    &#125;, 0);\n  &#125;\n  \n  doResolve(fn, resolve, reject)\n\n  this.then = function (onFulfilled, onRejected) &#123;\n    var self = this;\n    return new Promise(function (resolve, reject) &#123;\n      return self.done(function (result) &#123;\n        if (typeof onFulfilled === &#39;function&#39;) &#123;\n          try &#123;\n            return resolve(onFulfilled(result));\n          &#125; catch (ex) &#123;\n            return reject(ex);\n          &#125;\n        &#125; else &#123;\n          return resolve(result);\n        &#125;\n      &#125;, function (error) &#123;\n        if (typeof onRejected === &#39;function&#39;) &#123;\n          try &#123;\n            return resolve(onRejected(error));\n          &#125; catch (ex) &#123;\n            return reject(ex);\n          &#125;\n        &#125; else &#123;\n          return reject(error);\n        &#125;\n      &#125;);\n    &#125;);\n  &#125;\n&#125;\n\nfunction getThen(value) &#123;\n  var t = typeof value;\n  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) &#123;\n    var then = value.then;\n    if (typeof then === &#39;function&#39;) &#123;\n      return then;\n    &#125;\n  &#125;\n  return null;\n&#125;\n\nfunction doResolve(fn, onFulfilled, onRejected) &#123;\n  var done = false;\n  try &#123;\n    fn(function (value) &#123;\n      if (done) return\n      done = true\n      onFulfilled(value)\n    &#125;, function (reason) &#123;\n      if (done) return\n      done = true\n      onRejected(reason)\n    &#125;)\n  &#125; catch (ex) &#123;\n    if (done) return\n    done = true\n    onRejected(ex)\n  &#125;\n&#125;\n\n\nvar promise1 = new Promise(function(resolve, reject) &#123;\n  setTimeout(function() &#123;\n    resolve(&#39;foo&#39;);\n  &#125;, 3000);\n&#125;);\n\npromise1.then(function(value) &#123;\n  console.log(value)\n  // expected output: &quot;foo&quot;\n&#125;);\n\nconsole.log(promise1);\n</code></pre>\n<p><img src=\"/images/Promise.png\" alt=\"Promise\"></p>\n<p>一些帮助理解这段代码的小 tips：</p>\n<ol>\n<li><code>doResolve()</code> ，第一，会直接执行 <code>fn</code> 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 <code>resolve</code> 或是 <code>reject</code> function 仅执行一次。</li>\n<li>每次声明 Promise object，都会先执行一次 <code>doResolve()</code> 函数；</li>\n<li><code>.then()</code> 返回一个新的 Promise object，这个 Promise 会执行 <code>doResolve()</code>  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 <code>self.done()</code> 函数的执行结果；</li>\n<li><code>.done()</code> 方法会 check state 的值，确定是否将 <code>resolve</code> 添加进 <code>handlers</code> 中；</li>\n<li><code>resolve</code> 函数执行完毕后，将 <code>state</code> 从 <code>PENDING</code> 改为了 <code>FULFILLED</code>，同时 <code>handlers.forEach(handle)</code> 依次执行 <code>.then</code> 方法中添加进去的函数。</li>\n<li><code>resolve</code> 和 <code>reject</code> 都会将值赋给 <code>value</code> 变量；</li>\n<li><code>setTimeout(cb, 0)</code> 使用了上述提到的 event loop，此时 <code>cb</code> 会在几乎 0ms 的间隔时间后，进入 task queue。</li>\n</ol>\n<p>参考链接：</p>\n<ul>\n<li><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s\">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></p>\n</li>\n<li><p><a href=\"https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s\">Async JS Crash Course - Callbacks, Promises, Async Await</a></p>\n</li>\n<li><p><a href=\"https://www.promisejs.org/implementing/\">Implementing</a></p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt\">Basic Javascript promise implementation attempt</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p>\n<h2 id=\"Event-loop\"><a href=\"#Event-loop\" class=\"headerlink\" title=\"Event loop\"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p>\n<pre><code class=\"javascript\">$.get(&#39;http://twitter.com&#39;)\n$.get(&#39;http://youtube.com&#39;)\n$.get(&#39;http://google.com&#39;)\n</code></pre>\n<p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p>\n<pre><code class=\"Javascript\">console.log(&#39;hi&#39;)\nsetTimeout(() =&gt; console.log(&#39;there&#39;), 0)\nconsole.log(&#39;Welcome!&#39;)\n\n// output:\n// hi\n// Welcome\n// there\n</code></pre>\n<p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p>\n<p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p>","more":"<p><img src=\"/images/eventLoop.png\" alt=\"Event Loop\"></p>\n<h2 id=\"Promise-的实现\"><a href=\"#Promise-的实现\" class=\"headerlink\" title=\"Promise 的实现\"></a>Promise 的实现</h2><p>Promise 和   <code>setTimeout()</code> 的区别是，<code>setTimeout()</code> 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 <code>.then()</code> 的方法执行下一个任务。</p>\n<blockquote>\n<p>Timeouts and Promises serve different purposes.</p>\n<p>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.</p>\n<p>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your <code>then()</code> call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.</p>\n<p>The reason the promise is executing before your timeout is that the promise isn’t actually waiting for anything so it resolved right away.</p>\n</blockquote>\n<p>以下是来自 <a href=\"https://www.promisejs.org/implementing/\">Implementing</a>，对于 Promise object 的实现：</p>\n<p>最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 <code>console.log()</code>。</p>\n<pre><code class=\"javascript\">let PENDING = 0;\nlet FULFILLED = 1;\nlet REJECTED = 2;\n\nfunction Promise(fn) &#123;\n  // store state which can be PENDING, FULFILLED or REJECTED\n  let state = PENDING;\n\n  // store value or error once FULFILLED or REJECTED\n  let value = null;\n\n  // store sucess &amp; failure handlers attached by calling .then or .done\n  let handlers = [];\n\n  function fulfill(result) &#123;\n    state = FULFILLED;\n    value = result;\n    handlers.forEach(handle);\n    handlers = null;\n  &#125;\n\n  function reject(error) &#123;\n    state = REJECTED;\n    value = error;\n    handlers.forEach(handle);\n    handlers = null;\n  &#125;\n\n  function resolve(result) &#123;\n    try &#123;\n      let then = getThen(result);\n      if (then) &#123;\n        doResolve(then.bind(result), resolve, reject);\n        return ;\n      &#125;\n      fulfill(result)\n    &#125; catch (e) &#123;\n      reject(e);\n    &#125;\n  &#125;\n\n  function handle(handler) &#123;\n    if (state === PENDING) &#123;\n      handlers.push(handler);\n    &#125; else &#123;\n      if (state === FULFILLED &amp;&amp;\n        typeof handler.onFulfilled === &#39;function&#39;) &#123;\n        handler.onFulfilled(value);\n      &#125;\n      if (state === REJECTED &amp;&amp;\n        typeof handler.onRejected === &#39;function&#39;) &#123;\n        handler.onRejected(value);\n      &#125;\n    &#125;\n  &#125;\n\n  this.done = function (onFulfilled, onRejected) &#123;\n    // ensure we are always asynchronous\n    setTimeout(function () &#123;\n      console.log(&#39;instantly implemented ⚠️&#39;)\n      handle(&#123;\n        onFulfilled: onFulfilled,\n        onRejected: onRejected\n      &#125;);\n    &#125;, 0);\n  &#125;\n  \n  doResolve(fn, resolve, reject)\n\n  this.then = function (onFulfilled, onRejected) &#123;\n    var self = this;\n    return new Promise(function (resolve, reject) &#123;\n      return self.done(function (result) &#123;\n        if (typeof onFulfilled === &#39;function&#39;) &#123;\n          try &#123;\n            return resolve(onFulfilled(result));\n          &#125; catch (ex) &#123;\n            return reject(ex);\n          &#125;\n        &#125; else &#123;\n          return resolve(result);\n        &#125;\n      &#125;, function (error) &#123;\n        if (typeof onRejected === &#39;function&#39;) &#123;\n          try &#123;\n            return resolve(onRejected(error));\n          &#125; catch (ex) &#123;\n            return reject(ex);\n          &#125;\n        &#125; else &#123;\n          return reject(error);\n        &#125;\n      &#125;);\n    &#125;);\n  &#125;\n&#125;\n\nfunction getThen(value) &#123;\n  var t = typeof value;\n  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) &#123;\n    var then = value.then;\n    if (typeof then === &#39;function&#39;) &#123;\n      return then;\n    &#125;\n  &#125;\n  return null;\n&#125;\n\nfunction doResolve(fn, onFulfilled, onRejected) &#123;\n  var done = false;\n  try &#123;\n    fn(function (value) &#123;\n      if (done) return\n      done = true\n      onFulfilled(value)\n    &#125;, function (reason) &#123;\n      if (done) return\n      done = true\n      onRejected(reason)\n    &#125;)\n  &#125; catch (ex) &#123;\n    if (done) return\n    done = true\n    onRejected(ex)\n  &#125;\n&#125;\n\n\nvar promise1 = new Promise(function(resolve, reject) &#123;\n  setTimeout(function() &#123;\n    resolve(&#39;foo&#39;);\n  &#125;, 3000);\n&#125;);\n\npromise1.then(function(value) &#123;\n  console.log(value)\n  // expected output: &quot;foo&quot;\n&#125;);\n\nconsole.log(promise1);\n</code></pre>\n<p><img src=\"/images/Promise.png\" alt=\"Promise\"></p>\n<p>一些帮助理解这段代码的小 tips：</p>\n<ol>\n<li><code>doResolve()</code> ，第一，会直接执行 <code>fn</code> 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 <code>resolve</code> 或是 <code>reject</code> function 仅执行一次。</li>\n<li>每次声明 Promise object，都会先执行一次 <code>doResolve()</code> 函数；</li>\n<li><code>.then()</code> 返回一个新的 Promise object，这个 Promise 会执行 <code>doResolve()</code>  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 <code>self.done()</code> 函数的执行结果；</li>\n<li><code>.done()</code> 方法会 check state 的值，确定是否将 <code>resolve</code> 添加进 <code>handlers</code> 中；</li>\n<li><code>resolve</code> 函数执行完毕后，将 <code>state</code> 从 <code>PENDING</code> 改为了 <code>FULFILLED</code>，同时 <code>handlers.forEach(handle)</code> 依次执行 <code>.then</code> 方法中添加进去的函数。</li>\n<li><code>resolve</code> 和 <code>reject</code> 都会将值赋给 <code>value</code> 变量；</li>\n<li><code>setTimeout(cb, 0)</code> 使用了上述提到的 event loop，此时 <code>cb</code> 会在几乎 0ms 的间隔时间后，进入 task queue。</li>\n</ol>\n<p>参考链接：</p>\n<ul>\n<li><p><a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s\">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></p>\n</li>\n<li><p><a href=\"https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s\">Async JS Crash Course - Callbacks, Promises, Async Await</a></p>\n</li>\n<li><p><a href=\"https://www.promisejs.org/implementing/\">Implementing</a></p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt\">Basic Javascript promise implementation attempt</a></p>\n</li>\n</ul>"},{"title":"Lazy Evaluation, foldr | 5kyu","date":"2019-07-06T04:42:24.000Z","_content":"\n关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：\n\n```javascript\n// Evaluates with call-by-name strategy\n1 function callByName (a, b) {\n2  if (a === 1) {\n3    return 10\n4  }\n5  return a + b\n6 }\n// Evaluates with call-by-value strategy\n1 function callByValue (a, b) {\n2  if (a === 1) {\n3    return 10\n4  }\n5  return a + b\n6 }\n```\n\n两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；\n\n```shell\n> callByName (1, 2 + 3)\n> a === 1\n> return 10\n\n> callByValue(1, 2 + 3)\n> callByValue(1, 5)\n> a === 1\n> return 10\n```\n\n使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。\n\n实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：\n\n<!--more-->\n\n```javascript\n// Not lazy\nvar value = 1 + 1  // immediately evaluates to 2\n\n// Lazy\nvar lazyValue = () => 1 + 1  // Evaluates to 2 when lazyValue is *invoked*\n\n// Not lazy\nvar add = (x, y) => x + y\nvar result = add(1, 2)  // Immediately evaluates to 3\n\n// Lazy\nvar addLazy = (x, y) => () => x + y;\nvar result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.\n```\n\n理解了这一概念，就明白 codewars 上这道题目的用意了。\n\nhttps://www.codewars.com/kata/foldr/javascript\n\n题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 `reduceRight()` 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 `indexOf` 函数为例：\n\n```javascript\nconst indexOf = y => function (x, z) {\n  if (x === y) {\n    return 0\n  } else {\n    return z + 1 || -1\n  }\n};\n```\n\n`indexOf` 返回的是一个函数，比如 `indexOf(1)` 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：\n\n```javascript\nconst indexOf = y => function (x, () => someFunction()) {\n  if (x === y) {\n    return 0\n  } else {\n    return z() + 1 || -1\n  }\n};\n```\n\n这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，`indexOf` 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 `return z + 1 || -1`  改成 `return z() + 1 || -1`。\n\n所以，问题最终就变成了，如何将一个变量，比如 `z`，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 `Object.prototype.valueOf()`。\n\n> JavaScript calls the `valueOf` method to convert an object to a primitive value. You rarely need to invoke the `valueOf` method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\n使用 `valueOf()` ，可以\n\n```javascript\n> a = {}\n{}\n> a.valueOf = () => 3\n[Function]\n> a \n{ valueOf: [Function] }\n> a + 1\n4\n> a.valueOf = () => true\n[Function]\n> !a \nfalse\n> a && false \nfalse\n> \n```\n\n定义了 `valueOf` 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，`valueOf` 函数才会被调用。因此，我们只需要在调用 `indexOf` 函数时这样调用：\n\n```javascript\nindexOf(1)(1, {valueOf: () => someFunction()})\n```\n\n即可。依照这样的思路，这道 codewars 问题也就迎刃而解。\n\n\n\n\n\n参考链接：\n\n- [Lazy Evaluation in Javascript](https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7)\n- [Meaning of Lazy Evaluation in Javascript](https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript)\n- [Object.prototype.valueOf()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)","source":"_posts/Lazy-Evaluation.md","raw":"---\ntitle: Lazy Evaluation, foldr | 5kyu\ndate: 2019-07-06 12:42:24\ntags:\n- codewars\n- JavaScript\n---\n\n关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：\n\n```javascript\n// Evaluates with call-by-name strategy\n1 function callByName (a, b) {\n2  if (a === 1) {\n3    return 10\n4  }\n5  return a + b\n6 }\n// Evaluates with call-by-value strategy\n1 function callByValue (a, b) {\n2  if (a === 1) {\n3    return 10\n4  }\n5  return a + b\n6 }\n```\n\n两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；\n\n```shell\n> callByName (1, 2 + 3)\n> a === 1\n> return 10\n\n> callByValue(1, 2 + 3)\n> callByValue(1, 5)\n> a === 1\n> return 10\n```\n\n使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。\n\n实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：\n\n<!--more-->\n\n```javascript\n// Not lazy\nvar value = 1 + 1  // immediately evaluates to 2\n\n// Lazy\nvar lazyValue = () => 1 + 1  // Evaluates to 2 when lazyValue is *invoked*\n\n// Not lazy\nvar add = (x, y) => x + y\nvar result = add(1, 2)  // Immediately evaluates to 3\n\n// Lazy\nvar addLazy = (x, y) => () => x + y;\nvar result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.\n```\n\n理解了这一概念，就明白 codewars 上这道题目的用意了。\n\nhttps://www.codewars.com/kata/foldr/javascript\n\n题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 `reduceRight()` 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 `indexOf` 函数为例：\n\n```javascript\nconst indexOf = y => function (x, z) {\n  if (x === y) {\n    return 0\n  } else {\n    return z + 1 || -1\n  }\n};\n```\n\n`indexOf` 返回的是一个函数，比如 `indexOf(1)` 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：\n\n```javascript\nconst indexOf = y => function (x, () => someFunction()) {\n  if (x === y) {\n    return 0\n  } else {\n    return z() + 1 || -1\n  }\n};\n```\n\n这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，`indexOf` 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 `return z + 1 || -1`  改成 `return z() + 1 || -1`。\n\n所以，问题最终就变成了，如何将一个变量，比如 `z`，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 `Object.prototype.valueOf()`。\n\n> JavaScript calls the `valueOf` method to convert an object to a primitive value. You rarely need to invoke the `valueOf` method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\n使用 `valueOf()` ，可以\n\n```javascript\n> a = {}\n{}\n> a.valueOf = () => 3\n[Function]\n> a \n{ valueOf: [Function] }\n> a + 1\n4\n> a.valueOf = () => true\n[Function]\n> !a \nfalse\n> a && false \nfalse\n> \n```\n\n定义了 `valueOf` 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，`valueOf` 函数才会被调用。因此，我们只需要在调用 `indexOf` 函数时这样调用：\n\n```javascript\nindexOf(1)(1, {valueOf: () => someFunction()})\n```\n\n即可。依照这样的思路，这道 codewars 问题也就迎刃而解。\n\n\n\n\n\n参考链接：\n\n- [Lazy Evaluation in Javascript](https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7)\n- [Meaning of Lazy Evaluation in Javascript](https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript)\n- [Object.prototype.valueOf()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf)","slug":"Lazy-Evaluation","published":1,"updated":"2019-07-06T05:42:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx28001qrg1vheoz20of","content":"<p>关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：</p>\n<pre><code class=\"javascript\">// Evaluates with call-by-name strategy\n1 function callByName (a, b) &#123;\n2  if (a === 1) &#123;\n3    return 10\n4  &#125;\n5  return a + b\n6 &#125;\n// Evaluates with call-by-value strategy\n1 function callByValue (a, b) &#123;\n2  if (a === 1) &#123;\n3    return 10\n4  &#125;\n5  return a + b\n6 &#125;\n</code></pre>\n<p>两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；</p>\n<pre><code class=\"shell\">&gt; callByName (1, 2 + 3)\n&gt; a === 1\n&gt; return 10\n\n&gt; callByValue(1, 2 + 3)\n&gt; callByValue(1, 5)\n&gt; a === 1\n&gt; return 10\n</code></pre>\n<p>使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。</p>\n<p>实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：</p>\n<span id=\"more\"></span>\n\n<pre><code class=\"javascript\">// Not lazy\nvar value = 1 + 1  // immediately evaluates to 2\n\n// Lazy\nvar lazyValue = () =&gt; 1 + 1  // Evaluates to 2 when lazyValue is *invoked*\n\n// Not lazy\nvar add = (x, y) =&gt; x + y\nvar result = add(1, 2)  // Immediately evaluates to 3\n\n// Lazy\nvar addLazy = (x, y) =&gt; () =&gt; x + y;\nvar result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.\n</code></pre>\n<p>理解了这一概念，就明白 codewars 上这道题目的用意了。</p>\n<p><a href=\"https://www.codewars.com/kata/foldr/javascript\">https://www.codewars.com/kata/foldr/javascript</a></p>\n<p>题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 <code>reduceRight()</code> 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 <code>indexOf</code> 函数为例：</p>\n<pre><code class=\"javascript\">const indexOf = y =&gt; function (x, z) &#123;\n  if (x === y) &#123;\n    return 0\n  &#125; else &#123;\n    return z + 1 || -1\n  &#125;\n&#125;;\n</code></pre>\n<p><code>indexOf</code> 返回的是一个函数，比如 <code>indexOf(1)</code> 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：</p>\n<pre><code class=\"javascript\">const indexOf = y =&gt; function (x, () =&gt; someFunction()) &#123;\n  if (x === y) &#123;\n    return 0\n  &#125; else &#123;\n    return z() + 1 || -1\n  &#125;\n&#125;;\n</code></pre>\n<p>这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，<code>indexOf</code> 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 <code>return z + 1 || -1</code>  改成 <code>return z() + 1 || -1</code>。</p>\n<p>所以，问题最终就变成了，如何将一个变量，比如 <code>z</code>，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 <code>Object.prototype.valueOf()</code>。</p>\n<blockquote>\n<p>JavaScript calls the <code>valueOf</code> method to convert an object to a primitive value. You rarely need to invoke the <code>valueOf</code> method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</p>\n</blockquote>\n<p>使用 <code>valueOf()</code> ，可以</p>\n<pre><code class=\"javascript\">&gt; a = &#123;&#125;\n&#123;&#125;\n&gt; a.valueOf = () =&gt; 3\n[Function]\n&gt; a \n&#123; valueOf: [Function] &#125;\n&gt; a + 1\n4\n&gt; a.valueOf = () =&gt; true\n[Function]\n&gt; !a \nfalse\n&gt; a &amp;&amp; false \nfalse\n&gt; \n</code></pre>\n<p>定义了 <code>valueOf</code> 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，<code>valueOf</code> 函数才会被调用。因此，我们只需要在调用 <code>indexOf</code> 函数时这样调用：</p>\n<pre><code class=\"javascript\">indexOf(1)(1, &#123;valueOf: () =&gt; someFunction()&#125;)\n</code></pre>\n<p>即可。依照这样的思路，这道 codewars 问题也就迎刃而解。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7\">Lazy Evaluation in Javascript</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript\">Meaning of Lazy Evaluation in Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">Object.prototype.valueOf()</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：</p>\n<pre><code class=\"javascript\">// Evaluates with call-by-name strategy\n1 function callByName (a, b) &#123;\n2  if (a === 1) &#123;\n3    return 10\n4  &#125;\n5  return a + b\n6 &#125;\n// Evaluates with call-by-value strategy\n1 function callByValue (a, b) &#123;\n2  if (a === 1) &#123;\n3    return 10\n4  &#125;\n5  return a + b\n6 &#125;\n</code></pre>\n<p>两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；</p>\n<pre><code class=\"shell\">&gt; callByName (1, 2 + 3)\n&gt; a === 1\n&gt; return 10\n\n&gt; callByValue(1, 2 + 3)\n&gt; callByValue(1, 5)\n&gt; a === 1\n&gt; return 10\n</code></pre>\n<p>使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。</p>\n<p>实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：</p>","more":"<pre><code class=\"javascript\">// Not lazy\nvar value = 1 + 1  // immediately evaluates to 2\n\n// Lazy\nvar lazyValue = () =&gt; 1 + 1  // Evaluates to 2 when lazyValue is *invoked*\n\n// Not lazy\nvar add = (x, y) =&gt; x + y\nvar result = add(1, 2)  // Immediately evaluates to 3\n\n// Lazy\nvar addLazy = (x, y) =&gt; () =&gt; x + y;\nvar result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.\n</code></pre>\n<p>理解了这一概念，就明白 codewars 上这道题目的用意了。</p>\n<p><a href=\"https://www.codewars.com/kata/foldr/javascript\">https://www.codewars.com/kata/foldr/javascript</a></p>\n<p>题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 <code>reduceRight()</code> 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 <code>indexOf</code> 函数为例：</p>\n<pre><code class=\"javascript\">const indexOf = y =&gt; function (x, z) &#123;\n  if (x === y) &#123;\n    return 0\n  &#125; else &#123;\n    return z + 1 || -1\n  &#125;\n&#125;;\n</code></pre>\n<p><code>indexOf</code> 返回的是一个函数，比如 <code>indexOf(1)</code> 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：</p>\n<pre><code class=\"javascript\">const indexOf = y =&gt; function (x, () =&gt; someFunction()) &#123;\n  if (x === y) &#123;\n    return 0\n  &#125; else &#123;\n    return z() + 1 || -1\n  &#125;\n&#125;;\n</code></pre>\n<p>这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，<code>indexOf</code> 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 <code>return z + 1 || -1</code>  改成 <code>return z() + 1 || -1</code>。</p>\n<p>所以，问题最终就变成了，如何将一个变量，比如 <code>z</code>，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 <code>Object.prototype.valueOf()</code>。</p>\n<blockquote>\n<p>JavaScript calls the <code>valueOf</code> method to convert an object to a primitive value. You rarely need to invoke the <code>valueOf</code> method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</p>\n</blockquote>\n<p>使用 <code>valueOf()</code> ，可以</p>\n<pre><code class=\"javascript\">&gt; a = &#123;&#125;\n&#123;&#125;\n&gt; a.valueOf = () =&gt; 3\n[Function]\n&gt; a \n&#123; valueOf: [Function] &#125;\n&gt; a + 1\n4\n&gt; a.valueOf = () =&gt; true\n[Function]\n&gt; !a \nfalse\n&gt; a &amp;&amp; false \nfalse\n&gt; \n</code></pre>\n<p>定义了 <code>valueOf</code> 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，<code>valueOf</code> 函数才会被调用。因此，我们只需要在调用 <code>indexOf</code> 函数时这样调用：</p>\n<pre><code class=\"javascript\">indexOf(1)(1, &#123;valueOf: () =&gt; someFunction()&#125;)\n</code></pre>\n<p>即可。依照这样的思路，这道 codewars 问题也就迎刃而解。</p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7\">Lazy Evaluation in Javascript</a></li>\n<li><a href=\"https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript\">Meaning of Lazy Evaluation in Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">Object.prototype.valueOf()</a></li>\n</ul>"},{"title":"iPadOS 使用体验","date":"2019-06-05T03:25:19.000Z","_content":"\n今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 [Installing Apple Beta Software](https://developer.apple.com/support/beta-software/install-beta/) 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在[这里](https://www.udid.in/install-beta)下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。\n\n具体的安装教程也可以参考这个 [YouTube 视频](https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl%2Cwn)。\n\n下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。\n\n<!--more-->\n\n## Safari\n\n### Always Request Desktop Page\n\n永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：\n\n- 在 bilibili.com 可以调整更高清的分辨率；\n- 可以在 repl.it 上在线 coding 了；\n\n![repl](/images/repl.png)\n\nbilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。\n\n理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。\n\n可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。\n\n### 下载\n\nSafari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。\n\n## 手势交互\n\n手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。\n\n### 截图 / 长截图\n\n两种截图方式：\n\n1. power button + volume button；\n2. 使用 Apple Pencil 在屏幕左下角或右下角向上拉；\n\n第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。\n\n### 文字选取高亮 / 光标移动\n\n在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。\n\n### copy / paste\n\n我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。\n\n通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。\n\n## 外接存储\n\n是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。\n\n不清楚各位有没有连接 APFS 格式机械硬盘成功的。\n\n![ipad files bug](/images/ipad files bug.png)\n\n## UI 变化\n\n苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡\n\n![iOS13 tab 1](/images/iOS13 tab 1.png)\n\n![iOS13 tab 2](/images/iOS13 tab 2.png)\n\n![iOS13 tab 3](/images/iOS13 tab 3.png)\n\n## 关于 iPad 的未来\n\n1. Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。\n2. 会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。\n3. 内存会更多，将来可以后台多任务运行的数量会增多。\n\n最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。","source":"_posts/iPadOS-使用体验.md","raw":"---\ntitle: iPadOS 使用体验\ndate: 2019-06-05 11:25:19\ntags:\n---\n\n今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 [Installing Apple Beta Software](https://developer.apple.com/support/beta-software/install-beta/) 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在[这里](https://www.udid.in/install-beta)下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。\n\n具体的安装教程也可以参考这个 [YouTube 视频](https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl%2Cwn)。\n\n下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。\n\n<!--more-->\n\n## Safari\n\n### Always Request Desktop Page\n\n永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：\n\n- 在 bilibili.com 可以调整更高清的分辨率；\n- 可以在 repl.it 上在线 coding 了；\n\n![repl](/images/repl.png)\n\nbilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。\n\n理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。\n\n可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。\n\n### 下载\n\nSafari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。\n\n## 手势交互\n\n手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。\n\n### 截图 / 长截图\n\n两种截图方式：\n\n1. power button + volume button；\n2. 使用 Apple Pencil 在屏幕左下角或右下角向上拉；\n\n第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。\n\n### 文字选取高亮 / 光标移动\n\n在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。\n\n### copy / paste\n\n我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。\n\n通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。\n\n## 外接存储\n\n是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。\n\n不清楚各位有没有连接 APFS 格式机械硬盘成功的。\n\n![ipad files bug](/images/ipad files bug.png)\n\n## UI 变化\n\n苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡\n\n![iOS13 tab 1](/images/iOS13 tab 1.png)\n\n![iOS13 tab 2](/images/iOS13 tab 2.png)\n\n![iOS13 tab 3](/images/iOS13 tab 3.png)\n\n## 关于 iPad 的未来\n\n1. Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。\n2. 会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。\n3. 内存会更多，将来可以后台多任务运行的数量会增多。\n\n最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。","slug":"iPadOS-使用体验","published":1,"updated":"2019-06-05T04:09:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx28001urg1v69qn8m74","content":"<p>今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 <a href=\"https://developer.apple.com/support/beta-software/install-beta/\">Installing Apple Beta Software</a> 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在<a href=\"https://www.udid.in/install-beta\">这里</a>下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。</p>\n<p>具体的安装教程也可以参考这个 <a href=\"https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl,wn\">YouTube 视频</a>。</p>\n<p>下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Safari\"><a href=\"#Safari\" class=\"headerlink\" title=\"Safari\"></a>Safari</h2><h3 id=\"Always-Request-Desktop-Page\"><a href=\"#Always-Request-Desktop-Page\" class=\"headerlink\" title=\"Always Request Desktop Page\"></a>Always Request Desktop Page</h3><p>永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：</p>\n<ul>\n<li>在 bilibili.com 可以调整更高清的分辨率；</li>\n<li>可以在 repl.it 上在线 coding 了；</li>\n</ul>\n<p><img src=\"/images/repl.png\" alt=\"repl\"></p>\n<p>bilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。</p>\n<p>理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。</p>\n<p>可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>Safari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。</p>\n<h2 id=\"手势交互\"><a href=\"#手势交互\" class=\"headerlink\" title=\"手势交互\"></a>手势交互</h2><p>手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。</p>\n<h3 id=\"截图-长截图\"><a href=\"#截图-长截图\" class=\"headerlink\" title=\"截图 / 长截图\"></a>截图 / 长截图</h3><p>两种截图方式：</p>\n<ol>\n<li>power button + volume button；</li>\n<li>使用 Apple Pencil 在屏幕左下角或右下角向上拉；</li>\n</ol>\n<p>第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。</p>\n<h3 id=\"文字选取高亮-光标移动\"><a href=\"#文字选取高亮-光标移动\" class=\"headerlink\" title=\"文字选取高亮 / 光标移动\"></a>文字选取高亮 / 光标移动</h3><p>在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。</p>\n<h3 id=\"copy-paste\"><a href=\"#copy-paste\" class=\"headerlink\" title=\"copy / paste\"></a>copy / paste</h3><p>我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。</p>\n<p>通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。</p>\n<h2 id=\"外接存储\"><a href=\"#外接存储\" class=\"headerlink\" title=\"外接存储\"></a>外接存储</h2><p>是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。</p>\n<p>不清楚各位有没有连接 APFS 格式机械硬盘成功的。</p>\n<p>![ipad files bug](/images/ipad files bug.png)</p>\n<h2 id=\"UI-变化\"><a href=\"#UI-变化\" class=\"headerlink\" title=\"UI 变化\"></a>UI 变化</h2><p>苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡</p>\n<p>![iOS13 tab 1](/images/iOS13 tab 1.png)</p>\n<p>![iOS13 tab 2](/images/iOS13 tab 2.png)</p>\n<p>![iOS13 tab 3](/images/iOS13 tab 3.png)</p>\n<h2 id=\"关于-iPad-的未来\"><a href=\"#关于-iPad-的未来\" class=\"headerlink\" title=\"关于 iPad 的未来\"></a>关于 iPad 的未来</h2><ol>\n<li>Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。</li>\n<li>会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。</li>\n<li>内存会更多，将来可以后台多任务运行的数量会增多。</li>\n</ol>\n<p>最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。</p>\n","site":{"data":{}},"excerpt":"<p>今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 <a href=\"https://developer.apple.com/support/beta-software/install-beta/\">Installing Apple Beta Software</a> 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在<a href=\"https://www.udid.in/install-beta\">这里</a>下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。</p>\n<p>具体的安装教程也可以参考这个 <a href=\"https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl,wn\">YouTube 视频</a>。</p>\n<p>下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。</p>","more":"<h2 id=\"Safari\"><a href=\"#Safari\" class=\"headerlink\" title=\"Safari\"></a>Safari</h2><h3 id=\"Always-Request-Desktop-Page\"><a href=\"#Always-Request-Desktop-Page\" class=\"headerlink\" title=\"Always Request Desktop Page\"></a>Always Request Desktop Page</h3><p>永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：</p>\n<ul>\n<li>在 bilibili.com 可以调整更高清的分辨率；</li>\n<li>可以在 repl.it 上在线 coding 了；</li>\n</ul>\n<p><img src=\"/images/repl.png\" alt=\"repl\"></p>\n<p>bilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。</p>\n<p>理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。</p>\n<p>可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>Safari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。</p>\n<h2 id=\"手势交互\"><a href=\"#手势交互\" class=\"headerlink\" title=\"手势交互\"></a>手势交互</h2><p>手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。</p>\n<h3 id=\"截图-长截图\"><a href=\"#截图-长截图\" class=\"headerlink\" title=\"截图 / 长截图\"></a>截图 / 长截图</h3><p>两种截图方式：</p>\n<ol>\n<li>power button + volume button；</li>\n<li>使用 Apple Pencil 在屏幕左下角或右下角向上拉；</li>\n</ol>\n<p>第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。</p>\n<h3 id=\"文字选取高亮-光标移动\"><a href=\"#文字选取高亮-光标移动\" class=\"headerlink\" title=\"文字选取高亮 / 光标移动\"></a>文字选取高亮 / 光标移动</h3><p>在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。</p>\n<h3 id=\"copy-paste\"><a href=\"#copy-paste\" class=\"headerlink\" title=\"copy / paste\"></a>copy / paste</h3><p>我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。</p>\n<p>通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。</p>\n<h2 id=\"外接存储\"><a href=\"#外接存储\" class=\"headerlink\" title=\"外接存储\"></a>外接存储</h2><p>是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。</p>\n<p>不清楚各位有没有连接 APFS 格式机械硬盘成功的。</p>\n<p>![ipad files bug](/images/ipad files bug.png)</p>\n<h2 id=\"UI-变化\"><a href=\"#UI-变化\" class=\"headerlink\" title=\"UI 变化\"></a>UI 变化</h2><p>苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡</p>\n<p>![iOS13 tab 1](/images/iOS13 tab 1.png)</p>\n<p>![iOS13 tab 2](/images/iOS13 tab 2.png)</p>\n<p>![iOS13 tab 3](/images/iOS13 tab 3.png)</p>\n<h2 id=\"关于-iPad-的未来\"><a href=\"#关于-iPad-的未来\" class=\"headerlink\" title=\"关于 iPad 的未来\"></a>关于 iPad 的未来</h2><ol>\n<li>Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。</li>\n<li>会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。</li>\n<li>内存会更多，将来可以后台多任务运行的数量会增多。</li>\n</ol>\n<p>最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。</p>"},{"title":"「User Authentication with Passport and Koa 」Summary","date":"2019-02-02T14:15:36.000Z","catogries":"Coding","_content":"\n\n\n上周在阅读 *Express.js Blueprints* 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 [User Authentication with Passport and Koa](https://mherman.org/blog/user-authentication-with-passport-and-koa/) 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。\n\n需要通过 brew 安装：\n\n- postgresql\n- redis\n\n使用 npm 全局安装：\n\n- knex\n\n<!--more-->\n\n## 文件结构，逻辑\n\n文件最后的结构：\n\n```shell\n.\n├── LICENSE\n├── README.md\n├── knexfile.js\n├── package-lock.json\n├── package.json\n├── src\n│   └── server\n│       ├── auth.js\n│       ├── db\n│       │   ├── connection.js\n│       │   ├── migrations\n│       │   │   ├── 20170817152841_movies.js\n│       │   │   └── 20190127152820_users.js\n│       │   ├── queries\n│       │   │   ├── movies.js\n│       │   │   └── users.js\n│       │   └── seeds\n│       │       ├── movies_seed.js\n│       │       └── users.js\n│       ├── index.js\n│       ├── routes\n│       │   ├── auth.js\n│       │   ├── index.js\n│       │   └── movies.js\n│       └── views\n│           ├── login.html\n│           ├── register.html\n│           └── status.html\n└── test\n    ├── routes.auth.test.js\n    ├── routes.index.test.js\n    ├── routes.movies.test.js\n    └── sample.test.js\n```\n\n有一些文件夹，文件属于自动生成的 boilerplate，比如 `package.json`，`knexfile.js`，`db` 文件夹里的一些内容。项目的结构清晰明朗。`test` 为测试文件夹。测试文件的标题统一加上 `test` 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 `server` 文件夹下，`db` 几乎都是数据库，knex 相关的。另外有路由 `routes` 文件夹和 `views` 视图文件夹。\n\n## Postgresql\n\n在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 `service start` 的命令。这里是手动开启的办法：\n\n```shell\n$ pg_ctl -D /usr/local/var/postgres start  \n```\n\n和 Mysql 一样，把 `start` 可以换成 `stop`，`restart`。\n\n数据库初始化：\n\n```shell\n$ initdb /usr/local/var/postgres  \n```\n\n在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：\n\n```shell\n$ createdb koa_api    \n$ createdb koa_api_test\n```\n\n`psql` + Database，进入 database 的命令行。\n\n`\\dt` 显示所有 tables\n\n> Please note the following commands:\n>\n> - `\\list` or `\\l`: list all databases\n> - `\\dt`: list all tables in the current database\n>\n> You will never see tables in other databases, these tables aren't visible. You have to connect to the correct database to see its tables (and other objects).\n>\n> To switch databases:\n>\n> ```\n> \\connect database_name` or `\\c database_name\n> ```\n>\n> See the manual about [psql](http://www.postgresql.org/docs/current/interactive/app-psql.html).\n>\n> -- [How do I list all databases and tables using psql?](https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql)\n\n除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。\n\n## knex\n\n> **Knex.js** is a \"batteries included\" SQL query builder for **Postgres**, **MSSQL**, **MySQL**, **MariaDB**, **SQLite3**, **Oracle**, and **Amazon Redshift** designed to be flexible, portable, and fun to use. \n>\n> -- [Knex.js](https://knexjs.org)\n\nKnex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。\n\n![knex](/images/knex.png)\n\n因为要频繁在 Terminal 里用到 `knex` 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：\n\n```shell\n$ knex migrate:latest --env development\n$ knex seed:run --env development\n```\n\n\n\n---\n\n*Tips：*\n\n*如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 `node_modules` 文件夹下会有个隐藏文件夹 `.bin`，里面包含了全部我们可以直接运行的 package。所以直接：*\n\n```shell\n$ node_modules/.bin/knex init\n```\n\n---\n\n\n\n`init` 之后，本地会自动生成一个 `knexfile.js` 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，\t`knexfile.js` 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。\n\n> Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using `knex`command line tool.\n\n例如，通过 knex 创建 table：\n\n```shell\n$ knex migrate:make users\n```\n\n这里会自动生成一个 `users.js` 文件，文件名前面还会有 time stamp。存储路径在 `./server/db/migration/`。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：\n\n```javascript\nexports.up = (knex, Promise) => {\n  return knex.schema.createTable('users', (table) => {\n    table.increments();\n    table.string('username').unique().notNullable();\n    table.string('password').notNullable();\n  });\n};\n\nexports.down = (knex, Promise) => {\n  return knex.schema.dropTable('users');\n};\n```\n\n通过下面这条命令来应用我们定义的属性：\n\n```shell\nknex migrate:latest --env development\n```\n\n>To run the migration, use the command:\n>\n>```\n>knex migrate:latest\n>```\n>\n> The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the *env* flag in the migration command like:\n>\n>```\n>knex migrate:latest --env test\n>```\n\n`development` 是我们事先在 `knexfile.js` 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 `username` 和 `password`。以及每个 field 的属性都通过 chain function 的形式来表达。\n\n> Similar to migrations, the `knex` module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding **must be in a specific order** to so that we can rely on data that might already be in the database. \n\nseed 是用来初始化数据的。同 migrate 一样：\n\n```shell\n$ knex seed:make users\n$ knex seed:run --env development\n```\n\nline 1 会自动创建一个 `user.js` 在路径 `./server/db/seeds/` 里。line 2 运行这个 seeds，对 table 里数据进行初始化。\n\n## Mocha.js ,  Chai.js\n\n一个测试 module 被称为 specification，简称 spec，结构如下图所示：\n\n![Mocha_test](/images/Mocha_test.png)\n\n在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。\n\n>- [Mocha](http://mochajs.org/) – the core framework: it provides common testing functions including `describe` and `it` and the main function that runs tests.\n>- [Chai](http://chaijs.com/) – the library with many assertions. It allows to use a lot of different assertions, for now we need only `assert.equal`.\n\n使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。\n\n> Mocha automatically looks for tests inside the `**test**` directory of your project. Hence, you should go ahead and create this directory in your project root.\n\n以下是写的一个很简单的小例子：\n\n```javascript\nconst assert = require('assert');\n\ndescribe(\"sample\", ()=>{\n    it(\"it's just a test\", ()=>{\n        let x = 5;\n        let result = x;\n        assert.equal(Math.pow(x, 1), result);\n    });\n});\n```\n\n在 Terminal 里运行：\n\n```shell\n$ node_modules/.bin/_mocha\n\n  sample\n    ✓ it's just a test\n\n\n  1 passing (6ms)\n```\n\nChai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：\n\n```javascript\ndescribe('GET /auth/register', () => {\n  it('should render the register view', (done) => {\n    chai.request(server)\n    .get('/auth/register')\n    .end((err, res) => {\n      should.not.exist(err);\n      res.redirects.length.should.eql(0);\n      res.status.should.eql(200);\n      res.type.should.eql('text/html');\n      res.text.should.contain('<h1>Register</h1>');\n      res.text.should.contain(\n        '<p><button type=\"submit\">Register</button></p>');\n      done();\n    });\n  });\n});\n```\n\n其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。\n\n## Redis, Session\n\n这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。\n\n> It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.\n\nRedis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。\n\n关于 session 和 cookie 的区别。\n\ncookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。\n\n>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)\n>\n>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may \"steal\" another uses's session)\n\n这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。\n\n把 session 存储在 redis 的优势：\n\n>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. \n>\n>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <http://redis.io/topics/persistence> to learn more, but at a high level, here are your options ...\n\n依旧是通过 brew 安装 redis。\n\nredis 启动：\n\n```shell\n$ redis-server /usr/local/etc/redis.conf\n```\n\nredis 关闭，直接 `ctrl` + `C` 或是：\n\n```shell\n$ redis-cli shutdown\n```\n\n\n\n参考：\n\n- [Knex.js](https://knexjs.org)\n- [Seed Knex PostgreSQL Database with JSON Data](https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc)\n- [l4nk332/stuff - Github](https://github.com/l4nk332/stuff/tree/master/node/Knex)\n- [「batteries-included」该怎么翻译比较好？ - 知乎](https://www.zhihu.com/question/24710451)\n- [Migrations & Seeding](https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261)\n- [Automated testing with mocha](https://javascript.info/testing-mocha)\n- [Run mocha tests in test environment? - StackOverflow](https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment)\n- [A quick and complete guide to Mocha testing](https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d)\n- [What is the difference between a Session and a Cookie? - StackOverflow](https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie)\n- [How safe is it to store sessions with Redis?](https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis)\n- [Install and config Redis on Mac OS X via Homebrew](https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298)\n\n","source":"_posts/「User Authentication with Passport and Koa 」Summary.md","raw":"---\ntitle: '「User Authentication with Passport and Koa 」Summary'\ndate:\ntags:\n- JavaScript\n- Node.js\n- Front-end\ncatogries: 'Coding'\n---\n\n\n\n上周在阅读 *Express.js Blueprints* 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 [User Authentication with Passport and Koa](https://mherman.org/blog/user-authentication-with-passport-and-koa/) 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。\n\n需要通过 brew 安装：\n\n- postgresql\n- redis\n\n使用 npm 全局安装：\n\n- knex\n\n<!--more-->\n\n## 文件结构，逻辑\n\n文件最后的结构：\n\n```shell\n.\n├── LICENSE\n├── README.md\n├── knexfile.js\n├── package-lock.json\n├── package.json\n├── src\n│   └── server\n│       ├── auth.js\n│       ├── db\n│       │   ├── connection.js\n│       │   ├── migrations\n│       │   │   ├── 20170817152841_movies.js\n│       │   │   └── 20190127152820_users.js\n│       │   ├── queries\n│       │   │   ├── movies.js\n│       │   │   └── users.js\n│       │   └── seeds\n│       │       ├── movies_seed.js\n│       │       └── users.js\n│       ├── index.js\n│       ├── routes\n│       │   ├── auth.js\n│       │   ├── index.js\n│       │   └── movies.js\n│       └── views\n│           ├── login.html\n│           ├── register.html\n│           └── status.html\n└── test\n    ├── routes.auth.test.js\n    ├── routes.index.test.js\n    ├── routes.movies.test.js\n    └── sample.test.js\n```\n\n有一些文件夹，文件属于自动生成的 boilerplate，比如 `package.json`，`knexfile.js`，`db` 文件夹里的一些内容。项目的结构清晰明朗。`test` 为测试文件夹。测试文件的标题统一加上 `test` 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 `server` 文件夹下，`db` 几乎都是数据库，knex 相关的。另外有路由 `routes` 文件夹和 `views` 视图文件夹。\n\n## Postgresql\n\n在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 `service start` 的命令。这里是手动开启的办法：\n\n```shell\n$ pg_ctl -D /usr/local/var/postgres start  \n```\n\n和 Mysql 一样，把 `start` 可以换成 `stop`，`restart`。\n\n数据库初始化：\n\n```shell\n$ initdb /usr/local/var/postgres  \n```\n\n在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：\n\n```shell\n$ createdb koa_api    \n$ createdb koa_api_test\n```\n\n`psql` + Database，进入 database 的命令行。\n\n`\\dt` 显示所有 tables\n\n> Please note the following commands:\n>\n> - `\\list` or `\\l`: list all databases\n> - `\\dt`: list all tables in the current database\n>\n> You will never see tables in other databases, these tables aren't visible. You have to connect to the correct database to see its tables (and other objects).\n>\n> To switch databases:\n>\n> ```\n> \\connect database_name` or `\\c database_name\n> ```\n>\n> See the manual about [psql](http://www.postgresql.org/docs/current/interactive/app-psql.html).\n>\n> -- [How do I list all databases and tables using psql?](https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql)\n\n除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。\n\n## knex\n\n> **Knex.js** is a \"batteries included\" SQL query builder for **Postgres**, **MSSQL**, **MySQL**, **MariaDB**, **SQLite3**, **Oracle**, and **Amazon Redshift** designed to be flexible, portable, and fun to use. \n>\n> -- [Knex.js](https://knexjs.org)\n\nKnex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。\n\n![knex](/images/knex.png)\n\n因为要频繁在 Terminal 里用到 `knex` 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：\n\n```shell\n$ knex migrate:latest --env development\n$ knex seed:run --env development\n```\n\n\n\n---\n\n*Tips：*\n\n*如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 `node_modules` 文件夹下会有个隐藏文件夹 `.bin`，里面包含了全部我们可以直接运行的 package。所以直接：*\n\n```shell\n$ node_modules/.bin/knex init\n```\n\n---\n\n\n\n`init` 之后，本地会自动生成一个 `knexfile.js` 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，\t`knexfile.js` 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。\n\n> Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using `knex`command line tool.\n\n例如，通过 knex 创建 table：\n\n```shell\n$ knex migrate:make users\n```\n\n这里会自动生成一个 `users.js` 文件，文件名前面还会有 time stamp。存储路径在 `./server/db/migration/`。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：\n\n```javascript\nexports.up = (knex, Promise) => {\n  return knex.schema.createTable('users', (table) => {\n    table.increments();\n    table.string('username').unique().notNullable();\n    table.string('password').notNullable();\n  });\n};\n\nexports.down = (knex, Promise) => {\n  return knex.schema.dropTable('users');\n};\n```\n\n通过下面这条命令来应用我们定义的属性：\n\n```shell\nknex migrate:latest --env development\n```\n\n>To run the migration, use the command:\n>\n>```\n>knex migrate:latest\n>```\n>\n> The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the *env* flag in the migration command like:\n>\n>```\n>knex migrate:latest --env test\n>```\n\n`development` 是我们事先在 `knexfile.js` 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 `username` 和 `password`。以及每个 field 的属性都通过 chain function 的形式来表达。\n\n> Similar to migrations, the `knex` module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding **must be in a specific order** to so that we can rely on data that might already be in the database. \n\nseed 是用来初始化数据的。同 migrate 一样：\n\n```shell\n$ knex seed:make users\n$ knex seed:run --env development\n```\n\nline 1 会自动创建一个 `user.js` 在路径 `./server/db/seeds/` 里。line 2 运行这个 seeds，对 table 里数据进行初始化。\n\n## Mocha.js ,  Chai.js\n\n一个测试 module 被称为 specification，简称 spec，结构如下图所示：\n\n![Mocha_test](/images/Mocha_test.png)\n\n在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。\n\n>- [Mocha](http://mochajs.org/) – the core framework: it provides common testing functions including `describe` and `it` and the main function that runs tests.\n>- [Chai](http://chaijs.com/) – the library with many assertions. It allows to use a lot of different assertions, for now we need only `assert.equal`.\n\n使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。\n\n> Mocha automatically looks for tests inside the `**test**` directory of your project. Hence, you should go ahead and create this directory in your project root.\n\n以下是写的一个很简单的小例子：\n\n```javascript\nconst assert = require('assert');\n\ndescribe(\"sample\", ()=>{\n    it(\"it's just a test\", ()=>{\n        let x = 5;\n        let result = x;\n        assert.equal(Math.pow(x, 1), result);\n    });\n});\n```\n\n在 Terminal 里运行：\n\n```shell\n$ node_modules/.bin/_mocha\n\n  sample\n    ✓ it's just a test\n\n\n  1 passing (6ms)\n```\n\nChai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：\n\n```javascript\ndescribe('GET /auth/register', () => {\n  it('should render the register view', (done) => {\n    chai.request(server)\n    .get('/auth/register')\n    .end((err, res) => {\n      should.not.exist(err);\n      res.redirects.length.should.eql(0);\n      res.status.should.eql(200);\n      res.type.should.eql('text/html');\n      res.text.should.contain('<h1>Register</h1>');\n      res.text.should.contain(\n        '<p><button type=\"submit\">Register</button></p>');\n      done();\n    });\n  });\n});\n```\n\n其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。\n\n## Redis, Session\n\n这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。\n\n> It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.\n\nRedis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。\n\n关于 session 和 cookie 的区别。\n\ncookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。\n\n>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)\n>\n>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may \"steal\" another uses's session)\n\n这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。\n\n把 session 存储在 redis 的优势：\n\n>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. \n>\n>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <http://redis.io/topics/persistence> to learn more, but at a high level, here are your options ...\n\n依旧是通过 brew 安装 redis。\n\nredis 启动：\n\n```shell\n$ redis-server /usr/local/etc/redis.conf\n```\n\nredis 关闭，直接 `ctrl` + `C` 或是：\n\n```shell\n$ redis-cli shutdown\n```\n\n\n\n参考：\n\n- [Knex.js](https://knexjs.org)\n- [Seed Knex PostgreSQL Database with JSON Data](https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc)\n- [l4nk332/stuff - Github](https://github.com/l4nk332/stuff/tree/master/node/Knex)\n- [「batteries-included」该怎么翻译比较好？ - 知乎](https://www.zhihu.com/question/24710451)\n- [Migrations & Seeding](https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261)\n- [Automated testing with mocha](https://javascript.info/testing-mocha)\n- [Run mocha tests in test environment? - StackOverflow](https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment)\n- [A quick and complete guide to Mocha testing](https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d)\n- [What is the difference between a Session and a Cookie? - StackOverflow](https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie)\n- [How safe is it to store sessions with Redis?](https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis)\n- [Install and config Redis on Mac OS X via Homebrew](https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298)\n\n","slug":"「User Authentication with Passport and Koa 」Summary","published":1,"updated":"2019-02-02T14:15:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx28001xrg1v53kzb6gp","content":"<p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href=\"https://mherman.org/blog/user-authentication-with-passport-and-koa/\">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p>\n<p>需要通过 brew 安装：</p>\n<ul>\n<li>postgresql</li>\n<li>redis</li>\n</ul>\n<p>使用 npm 全局安装：</p>\n<ul>\n<li>knex</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"文件结构，逻辑\"><a href=\"#文件结构，逻辑\" class=\"headerlink\" title=\"文件结构，逻辑\"></a>文件结构，逻辑</h2><p>文件最后的结构：</p>\n<pre><code class=\"shell\">.\n├── LICENSE\n├── README.md\n├── knexfile.js\n├── package-lock.json\n├── package.json\n├── src\n│   └── server\n│       ├── auth.js\n│       ├── db\n│       │   ├── connection.js\n│       │   ├── migrations\n│       │   │   ├── 20170817152841_movies.js\n│       │   │   └── 20190127152820_users.js\n│       │   ├── queries\n│       │   │   ├── movies.js\n│       │   │   └── users.js\n│       │   └── seeds\n│       │       ├── movies_seed.js\n│       │       └── users.js\n│       ├── index.js\n│       ├── routes\n│       │   ├── auth.js\n│       │   ├── index.js\n│       │   └── movies.js\n│       └── views\n│           ├── login.html\n│           ├── register.html\n│           └── status.html\n└── test\n    ├── routes.auth.test.js\n    ├── routes.index.test.js\n    ├── routes.movies.test.js\n    └── sample.test.js\n</code></pre>\n<p>有一些文件夹，文件属于自动生成的 boilerplate，比如 <code>package.json</code>，<code>knexfile.js</code>，<code>db</code> 文件夹里的一些内容。项目的结构清晰明朗。<code>test</code> 为测试文件夹。测试文件的标题统一加上 <code>test</code> 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 <code>server</code> 文件夹下，<code>db</code> 几乎都是数据库，knex 相关的。另外有路由 <code>routes</code> 文件夹和 <code>views</code> 视图文件夹。</p>\n<h2 id=\"Postgresql\"><a href=\"#Postgresql\" class=\"headerlink\" title=\"Postgresql\"></a>Postgresql</h2><p>在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 <code>service start</code> 的命令。这里是手动开启的办法：</p>\n<pre><code class=\"shell\">$ pg_ctl -D /usr/local/var/postgres start  \n</code></pre>\n<p>和 Mysql 一样，把 <code>start</code> 可以换成 <code>stop</code>，<code>restart</code>。</p>\n<p>数据库初始化：</p>\n<pre><code class=\"shell\">$ initdb /usr/local/var/postgres  \n</code></pre>\n<p>在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：</p>\n<pre><code class=\"shell\">$ createdb koa_api    \n$ createdb koa_api_test\n</code></pre>\n<p><code>psql</code> + Database，进入 database 的命令行。</p>\n<p><code>\\dt</code> 显示所有 tables</p>\n<blockquote>\n<p>Please note the following commands:</p>\n<ul>\n<li><code>\\list</code> or <code>\\l</code>: list all databases</li>\n<li><code>\\dt</code>: list all tables in the current database</li>\n</ul>\n<p>You will never see tables in other databases, these tables aren’t visible. You have to connect to the correct database to see its tables (and other objects).</p>\n<p>To switch databases:</p>\n<pre><code>\\connect database_name` or `\\c database_name\n</code></pre>\n<p>See the manual about <a href=\"http://www.postgresql.org/docs/current/interactive/app-psql.html\">psql</a>.</p>\n<p>– <a href=\"https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql\">How do I list all databases and tables using psql?</a></p>\n</blockquote>\n<p>除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。</p>\n<h2 id=\"knex\"><a href=\"#knex\" class=\"headerlink\" title=\"knex\"></a>knex</h2><blockquote>\n<p><strong>Knex.js</strong> is a “batteries included” SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. </p>\n<p>– <a href=\"https://knexjs.org/\">Knex.js</a></p>\n</blockquote>\n<p>Knex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。</p>\n<p><img src=\"/images/knex.png\" alt=\"knex\"></p>\n<p>因为要频繁在 Terminal 里用到 <code>knex</code> 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：</p>\n<pre><code class=\"shell\">$ knex migrate:latest --env development\n$ knex seed:run --env development\n</code></pre>\n<hr>\n<p><em>Tips：</em></p>\n<p><em>如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 <code>node_modules</code> 文件夹下会有个隐藏文件夹 <code>.bin</code>，里面包含了全部我们可以直接运行的 package。所以直接：</em></p>\n<pre><code class=\"shell\">$ node_modules/.bin/knex init\n</code></pre>\n<hr>\n<p><code>init</code> 之后，本地会自动生成一个 <code>knexfile.js</code> 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，    <code>knexfile.js</code> 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。</p>\n<blockquote>\n<p>Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using <code>knex</code>command line tool.</p>\n</blockquote>\n<p>例如，通过 knex 创建 table：</p>\n<pre><code class=\"shell\">$ knex migrate:make users\n</code></pre>\n<p>这里会自动生成一个 <code>users.js</code> 文件，文件名前面还会有 time stamp。存储路径在 <code>./server/db/migration/</code>。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：</p>\n<pre><code class=\"javascript\">exports.up = (knex, Promise) =&gt; &#123;\n  return knex.schema.createTable(&#39;users&#39;, (table) =&gt; &#123;\n    table.increments();\n    table.string(&#39;username&#39;).unique().notNullable();\n    table.string(&#39;password&#39;).notNullable();\n  &#125;);\n&#125;;\n\nexports.down = (knex, Promise) =&gt; &#123;\n  return knex.schema.dropTable(&#39;users&#39;);\n&#125;;\n</code></pre>\n<p>通过下面这条命令来应用我们定义的属性：</p>\n<pre><code class=\"shell\">knex migrate:latest --env development\n</code></pre>\n<blockquote>\n<p>To run the migration, use the command:</p>\n<pre><code>knex migrate:latest\n</code></pre>\n<p>The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the <em>env</em> flag in the migration command like:</p>\n<pre><code>knex migrate:latest --env test\n</code></pre>\n</blockquote>\n<p><code>development</code> 是我们事先在 <code>knexfile.js</code> 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 <code>username</code> 和 <code>password</code>。以及每个 field 的属性都通过 chain function 的形式来表达。</p>\n<blockquote>\n<p>Similar to migrations, the <code>knex</code> module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding <strong>must be in a specific order</strong> to so that we can rely on data that might already be in the database. </p>\n</blockquote>\n<p>seed 是用来初始化数据的。同 migrate 一样：</p>\n<pre><code class=\"shell\">$ knex seed:make users\n$ knex seed:run --env development\n</code></pre>\n<p>line 1 会自动创建一个 <code>user.js</code> 在路径 <code>./server/db/seeds/</code> 里。line 2 运行这个 seeds，对 table 里数据进行初始化。</p>\n<h2 id=\"Mocha-js-Chai-js\"><a href=\"#Mocha-js-Chai-js\" class=\"headerlink\" title=\"Mocha.js ,  Chai.js\"></a>Mocha.js ,  Chai.js</h2><p>一个测试 module 被称为 specification，简称 spec，结构如下图所示：</p>\n<p><img src=\"/images/Mocha_test.png\" alt=\"Mocha_test\"></p>\n<p>在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。</p>\n<blockquote>\n<ul>\n<li><a href=\"http://mochajs.org/\">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li>\n<li><a href=\"http://chaijs.com/\">Chai</a> – the library with many assertions. It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li>\n</ul>\n</blockquote>\n<p>使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。</p>\n<blockquote>\n<p>Mocha automatically looks for tests inside the <code>**test**</code> directory of your project. Hence, you should go ahead and create this directory in your project root.</p>\n</blockquote>\n<p>以下是写的一个很简单的小例子：</p>\n<pre><code class=\"javascript\">const assert = require(&#39;assert&#39;);\n\ndescribe(&quot;sample&quot;, ()=&gt;&#123;\n    it(&quot;it&#39;s just a test&quot;, ()=&gt;&#123;\n        let x = 5;\n        let result = x;\n        assert.equal(Math.pow(x, 1), result);\n    &#125;);\n&#125;);\n</code></pre>\n<p>在 Terminal 里运行：</p>\n<pre><code class=\"shell\">$ node_modules/.bin/_mocha\n\n  sample\n    ✓ it&#39;s just a test\n\n\n  1 passing (6ms)\n</code></pre>\n<p>Chai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：</p>\n<pre><code class=\"javascript\">describe(&#39;GET /auth/register&#39;, () =&gt; &#123;\n  it(&#39;should render the register view&#39;, (done) =&gt; &#123;\n    chai.request(server)\n    .get(&#39;/auth/register&#39;)\n    .end((err, res) =&gt; &#123;\n      should.not.exist(err);\n      res.redirects.length.should.eql(0);\n      res.status.should.eql(200);\n      res.type.should.eql(&#39;text/html&#39;);\n      res.text.should.contain(&#39;&lt;h1&gt;Register&lt;/h1&gt;&#39;);\n      res.text.should.contain(\n        &#39;&lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;&lt;/p&gt;&#39;);\n      done();\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p>其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。</p>\n<h2 id=\"Redis-Session\"><a href=\"#Redis-Session\" class=\"headerlink\" title=\"Redis, Session\"></a>Redis, Session</h2><p>这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。</p>\n<blockquote>\n<p>It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.</p>\n</blockquote>\n<p>Redis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。</p>\n<p>关于 session 和 cookie 的区别。</p>\n<p>cookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。</p>\n<blockquote>\n<p>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)</p>\n<p>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may “steal” another uses’s session)</p>\n</blockquote>\n<p>这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。</p>\n<p>把 session 存储在 redis 的优势：</p>\n<blockquote>\n<p>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. </p>\n<p>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <a href=\"http://redis.io/topics/persistence\">http://redis.io/topics/persistence</a> to learn more, but at a high level, here are your options …</p>\n</blockquote>\n<p>依旧是通过 brew 安装 redis。</p>\n<p>redis 启动：</p>\n<pre><code class=\"shell\">$ redis-server /usr/local/etc/redis.conf\n</code></pre>\n<p>redis 关闭，直接 <code>ctrl</code> + <code>C</code> 或是：</p>\n<pre><code class=\"shell\">$ redis-cli shutdown\n</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://knexjs.org/\">Knex.js</a></li>\n<li><a href=\"https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc\">Seed Knex PostgreSQL Database with JSON Data</a></li>\n<li><a href=\"https://github.com/l4nk332/stuff/tree/master/node/Knex\">l4nk332/stuff - Github</a></li>\n<li><a href=\"https://www.zhihu.com/question/24710451\">「batteries-included」该怎么翻译比较好？ - 知乎</a></li>\n<li><a href=\"https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261\">Migrations &amp; Seeding</a></li>\n<li><a href=\"https://javascript.info/testing-mocha\">Automated testing with mocha</a></li>\n<li><a href=\"https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment\">Run mocha tests in test environment? - StackOverflow</a></li>\n<li><a href=\"https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d\">A quick and complete guide to Mocha testing</a></li>\n<li><a href=\"https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie\">What is the difference between a Session and a Cookie? - StackOverflow</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis\">How safe is it to store sessions with Redis?</a></li>\n<li><a href=\"https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298\">Install and config Redis on Mac OS X via Homebrew</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href=\"https://mherman.org/blog/user-authentication-with-passport-and-koa/\">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p>\n<p>需要通过 brew 安装：</p>\n<ul>\n<li>postgresql</li>\n<li>redis</li>\n</ul>\n<p>使用 npm 全局安装：</p>\n<ul>\n<li>knex</li>\n</ul>","more":"<h2 id=\"文件结构，逻辑\"><a href=\"#文件结构，逻辑\" class=\"headerlink\" title=\"文件结构，逻辑\"></a>文件结构，逻辑</h2><p>文件最后的结构：</p>\n<pre><code class=\"shell\">.\n├── LICENSE\n├── README.md\n├── knexfile.js\n├── package-lock.json\n├── package.json\n├── src\n│   └── server\n│       ├── auth.js\n│       ├── db\n│       │   ├── connection.js\n│       │   ├── migrations\n│       │   │   ├── 20170817152841_movies.js\n│       │   │   └── 20190127152820_users.js\n│       │   ├── queries\n│       │   │   ├── movies.js\n│       │   │   └── users.js\n│       │   └── seeds\n│       │       ├── movies_seed.js\n│       │       └── users.js\n│       ├── index.js\n│       ├── routes\n│       │   ├── auth.js\n│       │   ├── index.js\n│       │   └── movies.js\n│       └── views\n│           ├── login.html\n│           ├── register.html\n│           └── status.html\n└── test\n    ├── routes.auth.test.js\n    ├── routes.index.test.js\n    ├── routes.movies.test.js\n    └── sample.test.js\n</code></pre>\n<p>有一些文件夹，文件属于自动生成的 boilerplate，比如 <code>package.json</code>，<code>knexfile.js</code>，<code>db</code> 文件夹里的一些内容。项目的结构清晰明朗。<code>test</code> 为测试文件夹。测试文件的标题统一加上 <code>test</code> 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 <code>server</code> 文件夹下，<code>db</code> 几乎都是数据库，knex 相关的。另外有路由 <code>routes</code> 文件夹和 <code>views</code> 视图文件夹。</p>\n<h2 id=\"Postgresql\"><a href=\"#Postgresql\" class=\"headerlink\" title=\"Postgresql\"></a>Postgresql</h2><p>在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 <code>service start</code> 的命令。这里是手动开启的办法：</p>\n<pre><code class=\"shell\">$ pg_ctl -D /usr/local/var/postgres start  \n</code></pre>\n<p>和 Mysql 一样，把 <code>start</code> 可以换成 <code>stop</code>，<code>restart</code>。</p>\n<p>数据库初始化：</p>\n<pre><code class=\"shell\">$ initdb /usr/local/var/postgres  \n</code></pre>\n<p>在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：</p>\n<pre><code class=\"shell\">$ createdb koa_api    \n$ createdb koa_api_test\n</code></pre>\n<p><code>psql</code> + Database，进入 database 的命令行。</p>\n<p><code>\\dt</code> 显示所有 tables</p>\n<blockquote>\n<p>Please note the following commands:</p>\n<ul>\n<li><code>\\list</code> or <code>\\l</code>: list all databases</li>\n<li><code>\\dt</code>: list all tables in the current database</li>\n</ul>\n<p>You will never see tables in other databases, these tables aren’t visible. You have to connect to the correct database to see its tables (and other objects).</p>\n<p>To switch databases:</p>\n<pre><code>\\connect database_name` or `\\c database_name\n</code></pre>\n<p>See the manual about <a href=\"http://www.postgresql.org/docs/current/interactive/app-psql.html\">psql</a>.</p>\n<p>– <a href=\"https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql\">How do I list all databases and tables using psql?</a></p>\n</blockquote>\n<p>除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。</p>\n<h2 id=\"knex\"><a href=\"#knex\" class=\"headerlink\" title=\"knex\"></a>knex</h2><blockquote>\n<p><strong>Knex.js</strong> is a “batteries included” SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. </p>\n<p>– <a href=\"https://knexjs.org/\">Knex.js</a></p>\n</blockquote>\n<p>Knex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。</p>\n<p><img src=\"/images/knex.png\" alt=\"knex\"></p>\n<p>因为要频繁在 Terminal 里用到 <code>knex</code> 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：</p>\n<pre><code class=\"shell\">$ knex migrate:latest --env development\n$ knex seed:run --env development\n</code></pre>\n<hr>\n<p><em>Tips：</em></p>\n<p><em>如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 <code>node_modules</code> 文件夹下会有个隐藏文件夹 <code>.bin</code>，里面包含了全部我们可以直接运行的 package。所以直接：</em></p>\n<pre><code class=\"shell\">$ node_modules/.bin/knex init\n</code></pre>\n<hr>\n<p><code>init</code> 之后，本地会自动生成一个 <code>knexfile.js</code> 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，    <code>knexfile.js</code> 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。</p>\n<blockquote>\n<p>Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using <code>knex</code>command line tool.</p>\n</blockquote>\n<p>例如，通过 knex 创建 table：</p>\n<pre><code class=\"shell\">$ knex migrate:make users\n</code></pre>\n<p>这里会自动生成一个 <code>users.js</code> 文件，文件名前面还会有 time stamp。存储路径在 <code>./server/db/migration/</code>。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：</p>\n<pre><code class=\"javascript\">exports.up = (knex, Promise) =&gt; &#123;\n  return knex.schema.createTable(&#39;users&#39;, (table) =&gt; &#123;\n    table.increments();\n    table.string(&#39;username&#39;).unique().notNullable();\n    table.string(&#39;password&#39;).notNullable();\n  &#125;);\n&#125;;\n\nexports.down = (knex, Promise) =&gt; &#123;\n  return knex.schema.dropTable(&#39;users&#39;);\n&#125;;\n</code></pre>\n<p>通过下面这条命令来应用我们定义的属性：</p>\n<pre><code class=\"shell\">knex migrate:latest --env development\n</code></pre>\n<blockquote>\n<p>To run the migration, use the command:</p>\n<pre><code>knex migrate:latest\n</code></pre>\n<p>The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the <em>env</em> flag in the migration command like:</p>\n<pre><code>knex migrate:latest --env test\n</code></pre>\n</blockquote>\n<p><code>development</code> 是我们事先在 <code>knexfile.js</code> 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 <code>username</code> 和 <code>password</code>。以及每个 field 的属性都通过 chain function 的形式来表达。</p>\n<blockquote>\n<p>Similar to migrations, the <code>knex</code> module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding <strong>must be in a specific order</strong> to so that we can rely on data that might already be in the database. </p>\n</blockquote>\n<p>seed 是用来初始化数据的。同 migrate 一样：</p>\n<pre><code class=\"shell\">$ knex seed:make users\n$ knex seed:run --env development\n</code></pre>\n<p>line 1 会自动创建一个 <code>user.js</code> 在路径 <code>./server/db/seeds/</code> 里。line 2 运行这个 seeds，对 table 里数据进行初始化。</p>\n<h2 id=\"Mocha-js-Chai-js\"><a href=\"#Mocha-js-Chai-js\" class=\"headerlink\" title=\"Mocha.js ,  Chai.js\"></a>Mocha.js ,  Chai.js</h2><p>一个测试 module 被称为 specification，简称 spec，结构如下图所示：</p>\n<p><img src=\"/images/Mocha_test.png\" alt=\"Mocha_test\"></p>\n<p>在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。</p>\n<blockquote>\n<ul>\n<li><a href=\"http://mochajs.org/\">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li>\n<li><a href=\"http://chaijs.com/\">Chai</a> – the library with many assertions. It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li>\n</ul>\n</blockquote>\n<p>使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。</p>\n<blockquote>\n<p>Mocha automatically looks for tests inside the <code>**test**</code> directory of your project. Hence, you should go ahead and create this directory in your project root.</p>\n</blockquote>\n<p>以下是写的一个很简单的小例子：</p>\n<pre><code class=\"javascript\">const assert = require(&#39;assert&#39;);\n\ndescribe(&quot;sample&quot;, ()=&gt;&#123;\n    it(&quot;it&#39;s just a test&quot;, ()=&gt;&#123;\n        let x = 5;\n        let result = x;\n        assert.equal(Math.pow(x, 1), result);\n    &#125;);\n&#125;);\n</code></pre>\n<p>在 Terminal 里运行：</p>\n<pre><code class=\"shell\">$ node_modules/.bin/_mocha\n\n  sample\n    ✓ it&#39;s just a test\n\n\n  1 passing (6ms)\n</code></pre>\n<p>Chai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：</p>\n<pre><code class=\"javascript\">describe(&#39;GET /auth/register&#39;, () =&gt; &#123;\n  it(&#39;should render the register view&#39;, (done) =&gt; &#123;\n    chai.request(server)\n    .get(&#39;/auth/register&#39;)\n    .end((err, res) =&gt; &#123;\n      should.not.exist(err);\n      res.redirects.length.should.eql(0);\n      res.status.should.eql(200);\n      res.type.should.eql(&#39;text/html&#39;);\n      res.text.should.contain(&#39;&lt;h1&gt;Register&lt;/h1&gt;&#39;);\n      res.text.should.contain(\n        &#39;&lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;&lt;/p&gt;&#39;);\n      done();\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p>其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。</p>\n<h2 id=\"Redis-Session\"><a href=\"#Redis-Session\" class=\"headerlink\" title=\"Redis, Session\"></a>Redis, Session</h2><p>这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。</p>\n<blockquote>\n<p>It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.</p>\n</blockquote>\n<p>Redis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。</p>\n<p>关于 session 和 cookie 的区别。</p>\n<p>cookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。</p>\n<blockquote>\n<p>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)</p>\n<p>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may “steal” another uses’s session)</p>\n</blockquote>\n<p>这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。</p>\n<p>把 session 存储在 redis 的优势：</p>\n<blockquote>\n<p>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. </p>\n<p>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <a href=\"http://redis.io/topics/persistence\">http://redis.io/topics/persistence</a> to learn more, but at a high level, here are your options …</p>\n</blockquote>\n<p>依旧是通过 brew 安装 redis。</p>\n<p>redis 启动：</p>\n<pre><code class=\"shell\">$ redis-server /usr/local/etc/redis.conf\n</code></pre>\n<p>redis 关闭，直接 <code>ctrl</code> + <code>C</code> 或是：</p>\n<pre><code class=\"shell\">$ redis-cli shutdown\n</code></pre>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://knexjs.org/\">Knex.js</a></li>\n<li><a href=\"https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc\">Seed Knex PostgreSQL Database with JSON Data</a></li>\n<li><a href=\"https://github.com/l4nk332/stuff/tree/master/node/Knex\">l4nk332/stuff - Github</a></li>\n<li><a href=\"https://www.zhihu.com/question/24710451\">「batteries-included」该怎么翻译比较好？ - 知乎</a></li>\n<li><a href=\"https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261\">Migrations &amp; Seeding</a></li>\n<li><a href=\"https://javascript.info/testing-mocha\">Automated testing with mocha</a></li>\n<li><a href=\"https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment\">Run mocha tests in test environment? - StackOverflow</a></li>\n<li><a href=\"https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d\">A quick and complete guide to Mocha testing</a></li>\n<li><a href=\"https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie\">What is the difference between a Session and a Cookie? - StackOverflow</a></li>\n<li><a href=\"https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis\">How safe is it to store sessions with Redis?</a></li>\n<li><a href=\"https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298\">Install and config Redis on Mac OS X via Homebrew</a></li>\n</ul>"},{"title":"Lowest base system | 4kyu","date":"2019-01-22T15:16:13.000Z","_content":"\n## 要点\n\n- 除法，求余，因子\n- `Number.MAX_SAFE_INTEGER`\n- 二分法求方程根\n\n## Details\n\nYour task is determine lowest number base system in which the input `n` (base 10), expressed in this number base system, is all `1` in its digit. See an example:\n\n'7' in base 2 is '111' - fits! answer is 2\n\n'21' in base 2 is '10101' - contains '0' does not fit '21' in base 3 is '210' - contains '0' and '2' does not fit '21' in base 4 is '111' - contains only '1' it fits! answer is 4\n\n`n` is always less than `Number.MAX_SAFE_INTEGER`.\n\n这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction getMinBase (number) {\n    if (number == 3) return 2;\n    var divisor = number -1\n    for (let i = 2; i != divisor; i++) {\n        var k = number - 1;\n        if (i > 5999) break;\n        while (!(k % i)) {\n            divisor = k / i\n            k = divisor - 1;\n            if (k == 0) return i;\n        }\n    }\n    var _root = [2,3,4,5]\n    var k = 11\n    for (let i=0; i<_root.length; i++){\n        var possible = parseInt(Math.pow(number, 1/_root[i]))\n        var k = 10 * k + 1\n        if (toTenBase(k,possible) == number) return possible\n    }\n\n    return number -1;\n}\n\n\nfunction toTenBase (number, base) {\n    n = number + '';\n    n = n.split('').map(a => parseInt(a));\n    res = 0\n    for (var i = n.length -1; i > -1; i--) {\n        res += Math.pow(base,i) * n[i]\n    }\n\n    return res;\n}\n```\n\n我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，`i` 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 `i` 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 `number - 1` 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。\n\n所以我在代码的第一部分加入了变量 `divisor`，并把它加入了跳出循环的条件。因为一旦 `i` 超过了 `number - 1`  的一半，那么就不可能存在除了 `number -1` 之外的数，使得以之为 base 能得到 `111...`。\n\n但因为每次 `i` 都是类加 1，经过多次反复实验，`i` 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 `toTenBase()` ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 `number - 1`，然而在特殊测试部分，类似这样的 `Test.assertEquals(getMinBase(2500050001), 50000);` 数就很难办。\n\n后来也是借助函数 `toTenBase()` 才发现，特殊测试中的数字，化成 `111…` 形式的话，大多都是 `111`，`1111` 和 `11111`，再大的话就没有了。如果我们设 `getMinBase()` 函数所得值为 $x$，而对应 number 为 $n$，对于 `111` 的类型，则变成一个二次方程求解：\n\n$$x^2 +x+1=n$$\n\n相应的 `1111` 类型，则是三次方程求解：\n\n$$x^3+x^2 +x+1=n$$\n\n对于 `11111` ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：\n\n$\\lim\\limits_{x \\to \\infty }x^3+x^2 +x+1=\\lim\\limits_{n \\to \\infty }n$\n$\\lim\\limits_{x \\to \\infty }x^3=\\lim\\limits_{n \\to \\infty }n$\n\n因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。\n\n## Other Solutions\n\n [Voile](https://www.codewars.com/users/Voile)\n\n```javascript\nfunction getMinBase(n) {\n  for(let i=Math.ceil(Math.log2(n)); i>1; i--) {\n    let root=Math.round(findRoot(n,i));\n    if([...'1'.repeat(i)].reduce((s,_)=>s*root+1,0)===n) return root;\n  }\n}\n\nfunction findRoot(n,i) {\n  var l=1, r=Number.MAX_SAFE_INTEGER;\n  while((r-l)/l>1e-12) {\n    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);\n    g<n?l=m:r=m;\n  }\n  return (r+l)/2;\n}\n```\n\n`Number.MAX_SAFE_INTEGER` 是我们可以在 JavaScript 中进行 **准确计算**的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。\n\n> The **Number.MAX_SAFE_INTEGER** constant represents the maximum safe integer in JavaScript (`253 - 1`).\n>\n> The reasoning behind that number is that JavaScript uses [double-precision floating-point format numbers](http://www.wikiwand.com/en/Double_precision_floating-point_format) as specified in [IEEE 754](http://www.wikiwand.com/en/IEEE_floating_point) and can only safely represent numbers between `-(253 - 1)` and `253 - 1`.\n\n `findRoot(n,i)` 正是求我上面所说 $i-1$ 阶的一元方程。\n\n```javascript\n>x = findRoot(1000,4)\n9.641969245752986\n>Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1\n999.9999999995179\n```\n\n关键一步：`g=(Math.pow(m,i)-1)/(m-1)`，写成数学式是：\n\n$g = \\dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + ... + m + 1$\n\n求解的方程是：\n\n$f(x) = x^{i-1}+x^{i-2} + ... + x + 1 = n$\n\n注意到 `r` 和 `l`，分别为计算的上界和下届。求  `r` 和 `l` 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 `r` 和 `l`  中。标准的二分法求根的迭代过程，bisection method。\n\n下面看一下函数的主体部分。主要是 for 循环中 `i` 的初始值：`i=Math.ceil(Math.log2(n))`。`i` 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。\n\n\n\n[spiderPan](https://www.codewars.com/users/spiderPan)\n\n```javascript\nfunction getMinBase(number) {\n  for (var b =2; b<= Math.floor(Math.sqrt(number)); b++) {\n    var num = number;\n    while (num % b == 1) {\n      num = Math.floor(num / b);\n      if (num == 1) {\n        return b;\n      }\n    }\n\n  }\n\n  return number - 1;\n}\n```\n\n\n\n [LesRamer](https://www.codewars.com/users/LesRamer), [yurak](https://www.codewars.com/users/yurak)\n\n```javascript\nfunction getMinBase(x) {\n  function test(b) {\n    var z = x;\n    while(z % b == 1)\n      z = (z - 1) / b;\n    return z == 0;\n  }\n  for(var n = Math.ceil(Math.log2(x)); n >= 1; --n) {\n    var b = Math.floor(Math.pow(x,1/n));\n    if (test(b)) return b;\n    if (test(b-1)) return b-1;\n  }\n  return -1;\n}\n```\n\n\n\n\n\n参考文章：\n\n- [Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$](https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1)\n- [二分法 (數學)](http://www.wikiwand.com/zh/二分法_(數學))","source":"_posts/Lowest base system | 4kyu.md","raw":"---\ntitle: 'Lowest base system | 4kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## 要点\n\n- 除法，求余，因子\n- `Number.MAX_SAFE_INTEGER`\n- 二分法求方程根\n\n## Details\n\nYour task is determine lowest number base system in which the input `n` (base 10), expressed in this number base system, is all `1` in its digit. See an example:\n\n'7' in base 2 is '111' - fits! answer is 2\n\n'21' in base 2 is '10101' - contains '0' does not fit '21' in base 3 is '210' - contains '0' and '2' does not fit '21' in base 4 is '111' - contains only '1' it fits! answer is 4\n\n`n` is always less than `Number.MAX_SAFE_INTEGER`.\n\n这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。\n\n<!--more-->\n\n## My Solution\n\n```javascript\nfunction getMinBase (number) {\n    if (number == 3) return 2;\n    var divisor = number -1\n    for (let i = 2; i != divisor; i++) {\n        var k = number - 1;\n        if (i > 5999) break;\n        while (!(k % i)) {\n            divisor = k / i\n            k = divisor - 1;\n            if (k == 0) return i;\n        }\n    }\n    var _root = [2,3,4,5]\n    var k = 11\n    for (let i=0; i<_root.length; i++){\n        var possible = parseInt(Math.pow(number, 1/_root[i]))\n        var k = 10 * k + 1\n        if (toTenBase(k,possible) == number) return possible\n    }\n\n    return number -1;\n}\n\n\nfunction toTenBase (number, base) {\n    n = number + '';\n    n = n.split('').map(a => parseInt(a));\n    res = 0\n    for (var i = n.length -1; i > -1; i--) {\n        res += Math.pow(base,i) * n[i]\n    }\n\n    return res;\n}\n```\n\n我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，`i` 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 `i` 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 `number - 1` 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。\n\n所以我在代码的第一部分加入了变量 `divisor`，并把它加入了跳出循环的条件。因为一旦 `i` 超过了 `number - 1`  的一半，那么就不可能存在除了 `number -1` 之外的数，使得以之为 base 能得到 `111...`。\n\n但因为每次 `i` 都是类加 1，经过多次反复实验，`i` 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 `toTenBase()` ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 `number - 1`，然而在特殊测试部分，类似这样的 `Test.assertEquals(getMinBase(2500050001), 50000);` 数就很难办。\n\n后来也是借助函数 `toTenBase()` 才发现，特殊测试中的数字，化成 `111…` 形式的话，大多都是 `111`，`1111` 和 `11111`，再大的话就没有了。如果我们设 `getMinBase()` 函数所得值为 $x$，而对应 number 为 $n$，对于 `111` 的类型，则变成一个二次方程求解：\n\n$$x^2 +x+1=n$$\n\n相应的 `1111` 类型，则是三次方程求解：\n\n$$x^3+x^2 +x+1=n$$\n\n对于 `11111` ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：\n\n$\\lim\\limits_{x \\to \\infty }x^3+x^2 +x+1=\\lim\\limits_{n \\to \\infty }n$\n$\\lim\\limits_{x \\to \\infty }x^3=\\lim\\limits_{n \\to \\infty }n$\n\n因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。\n\n## Other Solutions\n\n [Voile](https://www.codewars.com/users/Voile)\n\n```javascript\nfunction getMinBase(n) {\n  for(let i=Math.ceil(Math.log2(n)); i>1; i--) {\n    let root=Math.round(findRoot(n,i));\n    if([...'1'.repeat(i)].reduce((s,_)=>s*root+1,0)===n) return root;\n  }\n}\n\nfunction findRoot(n,i) {\n  var l=1, r=Number.MAX_SAFE_INTEGER;\n  while((r-l)/l>1e-12) {\n    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);\n    g<n?l=m:r=m;\n  }\n  return (r+l)/2;\n}\n```\n\n`Number.MAX_SAFE_INTEGER` 是我们可以在 JavaScript 中进行 **准确计算**的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。\n\n> The **Number.MAX_SAFE_INTEGER** constant represents the maximum safe integer in JavaScript (`253 - 1`).\n>\n> The reasoning behind that number is that JavaScript uses [double-precision floating-point format numbers](http://www.wikiwand.com/en/Double_precision_floating-point_format) as specified in [IEEE 754](http://www.wikiwand.com/en/IEEE_floating_point) and can only safely represent numbers between `-(253 - 1)` and `253 - 1`.\n\n `findRoot(n,i)` 正是求我上面所说 $i-1$ 阶的一元方程。\n\n```javascript\n>x = findRoot(1000,4)\n9.641969245752986\n>Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1\n999.9999999995179\n```\n\n关键一步：`g=(Math.pow(m,i)-1)/(m-1)`，写成数学式是：\n\n$g = \\dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + ... + m + 1$\n\n求解的方程是：\n\n$f(x) = x^{i-1}+x^{i-2} + ... + x + 1 = n$\n\n注意到 `r` 和 `l`，分别为计算的上界和下届。求  `r` 和 `l` 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 `r` 和 `l`  中。标准的二分法求根的迭代过程，bisection method。\n\n下面看一下函数的主体部分。主要是 for 循环中 `i` 的初始值：`i=Math.ceil(Math.log2(n))`。`i` 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。\n\n\n\n[spiderPan](https://www.codewars.com/users/spiderPan)\n\n```javascript\nfunction getMinBase(number) {\n  for (var b =2; b<= Math.floor(Math.sqrt(number)); b++) {\n    var num = number;\n    while (num % b == 1) {\n      num = Math.floor(num / b);\n      if (num == 1) {\n        return b;\n      }\n    }\n\n  }\n\n  return number - 1;\n}\n```\n\n\n\n [LesRamer](https://www.codewars.com/users/LesRamer), [yurak](https://www.codewars.com/users/yurak)\n\n```javascript\nfunction getMinBase(x) {\n  function test(b) {\n    var z = x;\n    while(z % b == 1)\n      z = (z - 1) / b;\n    return z == 0;\n  }\n  for(var n = Math.ceil(Math.log2(x)); n >= 1; --n) {\n    var b = Math.floor(Math.pow(x,1/n));\n    if (test(b)) return b;\n    if (test(b-1)) return b-1;\n  }\n  return -1;\n}\n```\n\n\n\n\n\n参考文章：\n\n- [Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$](https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1)\n- [二分法 (數學)](http://www.wikiwand.com/zh/二分法_(數學))","slug":"Lowest base system | 4kyu","published":1,"updated":"2019-01-22T15:16:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx28001zrg1v66igb3nn","content":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li>除法，求余，因子</li>\n<li><code>Number.MAX_SAFE_INTEGER</code></li>\n<li>二分法求方程根</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Your task is determine lowest number base system in which the input <code>n</code> (base 10), expressed in this number base system, is all <code>1</code> in its digit. See an example:</p>\n<p>‘7’ in base 2 is ‘111’ - fits! answer is 2</p>\n<p>‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4</p>\n<p><code>n</code> is always less than <code>Number.MAX_SAFE_INTEGER</code>.</p>\n<p>这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function getMinBase (number) &#123;\n    if (number == 3) return 2;\n    var divisor = number -1\n    for (let i = 2; i != divisor; i++) &#123;\n        var k = number - 1;\n        if (i &gt; 5999) break;\n        while (!(k % i)) &#123;\n            divisor = k / i\n            k = divisor - 1;\n            if (k == 0) return i;\n        &#125;\n    &#125;\n    var _root = [2,3,4,5]\n    var k = 11\n    for (let i=0; i&lt;_root.length; i++)&#123;\n        var possible = parseInt(Math.pow(number, 1/_root[i]))\n        var k = 10 * k + 1\n        if (toTenBase(k,possible) == number) return possible\n    &#125;\n\n    return number -1;\n&#125;\n\n\nfunction toTenBase (number, base) &#123;\n    n = number + &#39;&#39;;\n    n = n.split(&#39;&#39;).map(a =&gt; parseInt(a));\n    res = 0\n    for (var i = n.length -1; i &gt; -1; i--) &#123;\n        res += Math.pow(base,i) * n[i]\n    &#125;\n\n    return res;\n&#125;\n</code></pre>\n<p>我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，<code>i</code> 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 <code>i</code> 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 <code>number - 1</code> 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。</p>\n<p>所以我在代码的第一部分加入了变量 <code>divisor</code>，并把它加入了跳出循环的条件。因为一旦 <code>i</code> 超过了 <code>number - 1</code>  的一半，那么就不可能存在除了 <code>number -1</code> 之外的数，使得以之为 base 能得到 <code>111...</code>。</p>\n<p>但因为每次 <code>i</code> 都是类加 1，经过多次反复实验，<code>i</code> 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 <code>toTenBase()</code> ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 <code>number - 1</code>，然而在特殊测试部分，类似这样的 <code>Test.assertEquals(getMinBase(2500050001), 50000);</code> 数就很难办。</p>\n<p>后来也是借助函数 <code>toTenBase()</code> 才发现，特殊测试中的数字，化成 <code>111…</code> 形式的话，大多都是 <code>111</code>，<code>1111</code> 和 <code>11111</code>，再大的话就没有了。如果我们设 <code>getMinBase()</code> 函数所得值为 $x$，而对应 number 为 $n$，对于 <code>111</code> 的类型，则变成一个二次方程求解：</p>\n<p>$$x^2 +x+1=n$$</p>\n<p>相应的 <code>1111</code> 类型，则是三次方程求解：</p>\n<p>$$x^3+x^2 +x+1=n$$</p>\n<p>对于 <code>11111</code> ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：</p>\n<p>$\\lim\\limits_{x \\to \\infty }x^3+x^2 +x+1=\\lim\\limits_{n \\to \\infty }n$<br>$\\lim\\limits_{x \\to \\infty }x^3=\\lim\\limits_{n \\to \\infty }n$</p>\n<p>因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"javascript\">function getMinBase(n) &#123;\n  for(let i=Math.ceil(Math.log2(n)); i&gt;1; i--) &#123;\n    let root=Math.round(findRoot(n,i));\n    if([...&#39;1&#39;.repeat(i)].reduce((s,_)=&gt;s*root+1,0)===n) return root;\n  &#125;\n&#125;\n\nfunction findRoot(n,i) &#123;\n  var l=1, r=Number.MAX_SAFE_INTEGER;\n  while((r-l)/l&gt;1e-12) &#123;\n    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);\n    g&lt;n?l=m:r=m;\n  &#125;\n  return (r+l)/2;\n&#125;\n</code></pre>\n<p><code>Number.MAX_SAFE_INTEGER</code> 是我们可以在 JavaScript 中进行 <strong>准确计算</strong>的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。</p>\n<blockquote>\n<p>The <strong>Number.MAX_SAFE_INTEGER</strong> constant represents the maximum safe integer in JavaScript (<code>253 - 1</code>).</p>\n<p>The reasoning behind that number is that JavaScript uses <a href=\"http://www.wikiwand.com/en/Double_precision_floating-point_format\">double-precision floating-point format numbers</a> as specified in <a href=\"http://www.wikiwand.com/en/IEEE_floating_point\">IEEE 754</a> and can only safely represent numbers between <code>-(253 - 1)</code> and <code>253 - 1</code>.</p>\n</blockquote>\n<p> <code>findRoot(n,i)</code> 正是求我上面所说 $i-1$ 阶的一元方程。</p>\n<pre><code class=\"javascript\">&gt;x = findRoot(1000,4)\n9.641969245752986\n&gt;Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1\n999.9999999995179\n</code></pre>\n<p>关键一步：<code>g=(Math.pow(m,i)-1)/(m-1)</code>，写成数学式是：</p>\n<p>$g = \\dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + … + m + 1$</p>\n<p>求解的方程是：</p>\n<p>$f(x) = x^{i-1}+x^{i-2} + … + x + 1 = n$</p>\n<p>注意到 <code>r</code> 和 <code>l</code>，分别为计算的上界和下届。求  <code>r</code> 和 <code>l</code> 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 <code>r</code> 和 <code>l</code>  中。标准的二分法求根的迭代过程，bisection method。</p>\n<p>下面看一下函数的主体部分。主要是 for 循环中 <code>i</code> 的初始值：<code>i=Math.ceil(Math.log2(n))</code>。<code>i</code> 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。</p>\n<p><a href=\"https://www.codewars.com/users/spiderPan\">spiderPan</a></p>\n<pre><code class=\"javascript\">function getMinBase(number) &#123;\n  for (var b =2; b&lt;= Math.floor(Math.sqrt(number)); b++) &#123;\n    var num = number;\n    while (num % b == 1) &#123;\n      num = Math.floor(num / b);\n      if (num == 1) &#123;\n        return b;\n      &#125;\n    &#125;\n\n  &#125;\n\n  return number - 1;\n&#125;\n</code></pre>\n<p> <a href=\"https://www.codewars.com/users/LesRamer\">LesRamer</a>, <a href=\"https://www.codewars.com/users/yurak\">yurak</a></p>\n<pre><code class=\"javascript\">function getMinBase(x) &#123;\n  function test(b) &#123;\n    var z = x;\n    while(z % b == 1)\n      z = (z - 1) / b;\n    return z == 0;\n  &#125;\n  for(var n = Math.ceil(Math.log2(x)); n &gt;= 1; --n) &#123;\n    var b = Math.floor(Math.pow(x,1/n));\n    if (test(b)) return b;\n    if (test(b-1)) return b-1;\n  &#125;\n  return -1;\n&#125;\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1\">Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$</a></li>\n<li><a href=\"http://www.wikiwand.com/zh/%E4%BA%8C%E5%88%86%E6%B3%95_(%E6%95%B8%E5%AD%B8)\">二分法 (數學)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ul>\n<li>除法，求余，因子</li>\n<li><code>Number.MAX_SAFE_INTEGER</code></li>\n<li>二分法求方程根</li>\n</ul>\n<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Your task is determine lowest number base system in which the input <code>n</code> (base 10), expressed in this number base system, is all <code>1</code> in its digit. See an example:</p>\n<p>‘7’ in base 2 is ‘111’ - fits! answer is 2</p>\n<p>‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4</p>\n<p><code>n</code> is always less than <code>Number.MAX_SAFE_INTEGER</code>.</p>\n<p>这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。</p>","more":"<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function getMinBase (number) &#123;\n    if (number == 3) return 2;\n    var divisor = number -1\n    for (let i = 2; i != divisor; i++) &#123;\n        var k = number - 1;\n        if (i &gt; 5999) break;\n        while (!(k % i)) &#123;\n            divisor = k / i\n            k = divisor - 1;\n            if (k == 0) return i;\n        &#125;\n    &#125;\n    var _root = [2,3,4,5]\n    var k = 11\n    for (let i=0; i&lt;_root.length; i++)&#123;\n        var possible = parseInt(Math.pow(number, 1/_root[i]))\n        var k = 10 * k + 1\n        if (toTenBase(k,possible) == number) return possible\n    &#125;\n\n    return number -1;\n&#125;\n\n\nfunction toTenBase (number, base) &#123;\n    n = number + &#39;&#39;;\n    n = n.split(&#39;&#39;).map(a =&gt; parseInt(a));\n    res = 0\n    for (var i = n.length -1; i &gt; -1; i--) &#123;\n        res += Math.pow(base,i) * n[i]\n    &#125;\n\n    return res;\n&#125;\n</code></pre>\n<p>我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，<code>i</code> 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 <code>i</code> 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 <code>number - 1</code> 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。</p>\n<p>所以我在代码的第一部分加入了变量 <code>divisor</code>，并把它加入了跳出循环的条件。因为一旦 <code>i</code> 超过了 <code>number - 1</code>  的一半，那么就不可能存在除了 <code>number -1</code> 之外的数，使得以之为 base 能得到 <code>111...</code>。</p>\n<p>但因为每次 <code>i</code> 都是类加 1，经过多次反复实验，<code>i</code> 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 <code>toTenBase()</code> ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 <code>number - 1</code>，然而在特殊测试部分，类似这样的 <code>Test.assertEquals(getMinBase(2500050001), 50000);</code> 数就很难办。</p>\n<p>后来也是借助函数 <code>toTenBase()</code> 才发现，特殊测试中的数字，化成 <code>111…</code> 形式的话，大多都是 <code>111</code>，<code>1111</code> 和 <code>11111</code>，再大的话就没有了。如果我们设 <code>getMinBase()</code> 函数所得值为 $x$，而对应 number 为 $n$，对于 <code>111</code> 的类型，则变成一个二次方程求解：</p>\n<p>$$x^2 +x+1=n$$</p>\n<p>相应的 <code>1111</code> 类型，则是三次方程求解：</p>\n<p>$$x^3+x^2 +x+1=n$$</p>\n<p>对于 <code>11111</code> ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：</p>\n<p>$\\lim\\limits_{x \\to \\infty }x^3+x^2 +x+1=\\lim\\limits_{n \\to \\infty }n$<br>$\\lim\\limits_{x \\to \\infty }x^3=\\lim\\limits_{n \\to \\infty }n$</p>\n<p>因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。</p>\n<h2 id=\"Other-Solutions\"><a href=\"#Other-Solutions\" class=\"headerlink\" title=\"Other Solutions\"></a>Other Solutions</h2><p> <a href=\"https://www.codewars.com/users/Voile\">Voile</a></p>\n<pre><code class=\"javascript\">function getMinBase(n) &#123;\n  for(let i=Math.ceil(Math.log2(n)); i&gt;1; i--) &#123;\n    let root=Math.round(findRoot(n,i));\n    if([...&#39;1&#39;.repeat(i)].reduce((s,_)=&gt;s*root+1,0)===n) return root;\n  &#125;\n&#125;\n\nfunction findRoot(n,i) &#123;\n  var l=1, r=Number.MAX_SAFE_INTEGER;\n  while((r-l)/l&gt;1e-12) &#123;\n    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);\n    g&lt;n?l=m:r=m;\n  &#125;\n  return (r+l)/2;\n&#125;\n</code></pre>\n<p><code>Number.MAX_SAFE_INTEGER</code> 是我们可以在 JavaScript 中进行 <strong>准确计算</strong>的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。</p>\n<blockquote>\n<p>The <strong>Number.MAX_SAFE_INTEGER</strong> constant represents the maximum safe integer in JavaScript (<code>253 - 1</code>).</p>\n<p>The reasoning behind that number is that JavaScript uses <a href=\"http://www.wikiwand.com/en/Double_precision_floating-point_format\">double-precision floating-point format numbers</a> as specified in <a href=\"http://www.wikiwand.com/en/IEEE_floating_point\">IEEE 754</a> and can only safely represent numbers between <code>-(253 - 1)</code> and <code>253 - 1</code>.</p>\n</blockquote>\n<p> <code>findRoot(n,i)</code> 正是求我上面所说 $i-1$ 阶的一元方程。</p>\n<pre><code class=\"javascript\">&gt;x = findRoot(1000,4)\n9.641969245752986\n&gt;Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1\n999.9999999995179\n</code></pre>\n<p>关键一步：<code>g=(Math.pow(m,i)-1)/(m-1)</code>，写成数学式是：</p>\n<p>$g = \\dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + … + m + 1$</p>\n<p>求解的方程是：</p>\n<p>$f(x) = x^{i-1}+x^{i-2} + … + x + 1 = n$</p>\n<p>注意到 <code>r</code> 和 <code>l</code>，分别为计算的上界和下届。求  <code>r</code> 和 <code>l</code> 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 <code>r</code> 和 <code>l</code>  中。标准的二分法求根的迭代过程，bisection method。</p>\n<p>下面看一下函数的主体部分。主要是 for 循环中 <code>i</code> 的初始值：<code>i=Math.ceil(Math.log2(n))</code>。<code>i</code> 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。</p>\n<p><a href=\"https://www.codewars.com/users/spiderPan\">spiderPan</a></p>\n<pre><code class=\"javascript\">function getMinBase(number) &#123;\n  for (var b =2; b&lt;= Math.floor(Math.sqrt(number)); b++) &#123;\n    var num = number;\n    while (num % b == 1) &#123;\n      num = Math.floor(num / b);\n      if (num == 1) &#123;\n        return b;\n      &#125;\n    &#125;\n\n  &#125;\n\n  return number - 1;\n&#125;\n</code></pre>\n<p> <a href=\"https://www.codewars.com/users/LesRamer\">LesRamer</a>, <a href=\"https://www.codewars.com/users/yurak\">yurak</a></p>\n<pre><code class=\"javascript\">function getMinBase(x) &#123;\n  function test(b) &#123;\n    var z = x;\n    while(z % b == 1)\n      z = (z - 1) / b;\n    return z == 0;\n  &#125;\n  for(var n = Math.ceil(Math.log2(x)); n &gt;= 1; --n) &#123;\n    var b = Math.floor(Math.pow(x,1/n));\n    if (test(b)) return b;\n    if (test(b-1)) return b-1;\n  &#125;\n  return -1;\n&#125;\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li><a href=\"https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1\">Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$</a></li>\n<li><a href=\"http://www.wikiwand.com/zh/%E4%BA%8C%E5%88%86%E6%B3%95_(%E6%95%B8%E5%AD%B8)\">二分法 (數學)</a></li>\n</ul>"},{"title":"「可我会永远喜欢你的，这和时间没关系，我想」","date":"2020-12-31T02:15:28.000Z","_content":"\n每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。\n\n> “是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” \n>\n> “可我会永远喜欢你的，这和时间没有关系，我想。”\n>\n> -- 「舞！舞！舞！」\n\n<!--more-->\n\n### 游戏\n\n![switch 2020](/images/switch_2020.png)\n\n- The Legend of Zelda: Breath of the Wild\n- Hades\n- Animal Crossing: New Horizons\n- 火焰纹章：风花雪月\n- Ori and the Will of the Wisps\n\n在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。\n\n2021 年最期待塞尔达的续作。\n\n### 音乐\n\n- Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks\n- 「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ\n- Zelda & Chill by Mikel & GameChops\n- Zelda & Chill 2 by Mikel & GameChops\n- 如果你爱我 by Tanya Chua\n\n[Replay 2020 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW)\n\n(上面的链接，国内用户需要挂代理才可以打开。)\n\n### 书\n\n- 「舞！舞！舞！」\n\n非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。\n\n![舞！舞！舞！](/images/舞！舞！舞！.png)\n\n技术类书籍看了一些：\n\n- Combine Asynchronous Programming with Swift\n- Node.js Design Patterns\n- iOS Development with Swift\n- Programming iOS 13\n- Python Parallel Programming Cookbook\n\n闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。\n\n### 电影\n\n![movies 2020](/images/movies_2020.PNG)\n\n看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。\n\n### 时刻\n\n今年一些值得纪念的时刻：\n\n> *2020.06.23*\n>\n> 凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。\n\n背景音乐是 vox freak 版本的 *Ur So F**kInG cOoL*，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。\n\n> *2020.11.12*\n>\n> 今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.\n>\n> https://browser.geekbench.com/v5/cpu/4652635\n> https://browser.geekbench.com/v5/cpu/4648107\n\nM1 芯片的发布相当震撼。期待明年的 16寸 MBP。\n\n> *2020.11.19*\n>\n> 看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。\n\n这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。\n\n### 期待\n\n来讲一讲明年的期待吧：\n\n- 塞尔达续作\n- 搭载 Apple Silicon 芯片的 16 寸 MacBook Pro\n\n\n\n### 结语\n\n然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。\n\n","source":"_posts/「可我会永远喜欢你的，这和时间没关系，我想」.md","raw":"---\ntitle: 「可我会永远喜欢你的，这和时间没关系，我想」\ndate: 2020-12-31 10:15:28\ntags:\n- 电影\n- 游戏\n- 音乐\ncategories: 'I/O'\n---\n\n每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。\n\n> “是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” \n>\n> “可我会永远喜欢你的，这和时间没有关系，我想。”\n>\n> -- 「舞！舞！舞！」\n\n<!--more-->\n\n### 游戏\n\n![switch 2020](/images/switch_2020.png)\n\n- The Legend of Zelda: Breath of the Wild\n- Hades\n- Animal Crossing: New Horizons\n- 火焰纹章：风花雪月\n- Ori and the Will of the Wisps\n\n在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。\n\n2021 年最期待塞尔达的续作。\n\n### 音乐\n\n- Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks\n- 「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ\n- Zelda & Chill by Mikel & GameChops\n- Zelda & Chill 2 by Mikel & GameChops\n- 如果你爱我 by Tanya Chua\n\n[Replay 2020 - Apple Music for Reyshawn](https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW)\n\n(上面的链接，国内用户需要挂代理才可以打开。)\n\n### 书\n\n- 「舞！舞！舞！」\n\n非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。\n\n![舞！舞！舞！](/images/舞！舞！舞！.png)\n\n技术类书籍看了一些：\n\n- Combine Asynchronous Programming with Swift\n- Node.js Design Patterns\n- iOS Development with Swift\n- Programming iOS 13\n- Python Parallel Programming Cookbook\n\n闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。\n\n### 电影\n\n![movies 2020](/images/movies_2020.PNG)\n\n看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。\n\n### 时刻\n\n今年一些值得纪念的时刻：\n\n> *2020.06.23*\n>\n> 凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。\n\n背景音乐是 vox freak 版本的 *Ur So F**kInG cOoL*，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。\n\n> *2020.11.12*\n>\n> 今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.\n>\n> https://browser.geekbench.com/v5/cpu/4652635\n> https://browser.geekbench.com/v5/cpu/4648107\n\nM1 芯片的发布相当震撼。期待明年的 16寸 MBP。\n\n> *2020.11.19*\n>\n> 看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。\n\n这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。\n\n### 期待\n\n来讲一讲明年的期待吧：\n\n- 塞尔达续作\n- 搭载 Apple Silicon 芯片的 16 寸 MacBook Pro\n\n\n\n### 结语\n\n然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。\n\n","slug":"「可我会永远喜欢你的，这和时间没关系，我想」","published":1,"updated":"2020-12-31T04:20:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2b003srg1v5mhrat8e","content":"<p>每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。</p>\n<blockquote>\n<p>“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” </p>\n<p>“可我会永远喜欢你的，这和时间没有关系，我想。”</p>\n<p>– 「舞！舞！舞！」</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h3><p><img src=\"/images/switch_2020.png\" alt=\"switch 2020\"></p>\n<ul>\n<li>The Legend of Zelda: Breath of the Wild</li>\n<li>Hades</li>\n<li>Animal Crossing: New Horizons</li>\n<li>火焰纹章：风花雪月</li>\n<li>Ori and the Will of the Wisps</li>\n</ul>\n<p>在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。</p>\n<p>2021 年最期待塞尔达的续作。</p>\n<h3 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h3><ul>\n<li>Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks</li>\n<li>「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ</li>\n<li>Zelda &amp; Chill by Mikel &amp; GameChops</li>\n<li>Zelda &amp; Chill 2 by Mikel &amp; GameChops</li>\n<li>如果你爱我 by Tanya Chua</li>\n</ul>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW\">Replay 2020 - Apple Music for Reyshawn</a></p>\n<p>(上面的链接，国内用户需要挂代理才可以打开。)</p>\n<h3 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h3><ul>\n<li>「舞！舞！舞！」</li>\n</ul>\n<p>非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。</p>\n<p><img src=\"/images/%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81.png\" alt=\"舞！舞！舞！\"></p>\n<p>技术类书籍看了一些：</p>\n<ul>\n<li>Combine Asynchronous Programming with Swift</li>\n<li>Node.js Design Patterns</li>\n<li>iOS Development with Swift</li>\n<li>Programming iOS 13</li>\n<li>Python Parallel Programming Cookbook</li>\n</ul>\n<p>闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。</p>\n<h3 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h3><p><img src=\"/images/movies_2020.PNG\" alt=\"movies 2020\"></p>\n<p>看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。</p>\n<h3 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h3><p>今年一些值得纪念的时刻：</p>\n<blockquote>\n<p><em>2020.06.23</em></p>\n<p>凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。</p>\n</blockquote>\n<p>背景音乐是 vox freak 版本的 <em>Ur So F**kInG cOoL</em>，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。</p>\n<blockquote>\n<p><em>2020.11.12</em></p>\n<p>今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.</p>\n<p><a href=\"https://browser.geekbench.com/v5/cpu/4652635\">https://browser.geekbench.com/v5/cpu/4652635</a><br><a href=\"https://browser.geekbench.com/v5/cpu/4648107\">https://browser.geekbench.com/v5/cpu/4648107</a></p>\n</blockquote>\n<p>M1 芯片的发布相当震撼。期待明年的 16寸 MBP。</p>\n<blockquote>\n<p><em>2020.11.19</em></p>\n<p>看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。</p>\n</blockquote>\n<p>这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。</p>\n<h3 id=\"期待\"><a href=\"#期待\" class=\"headerlink\" title=\"期待\"></a>期待</h3><p>来讲一讲明年的期待吧：</p>\n<ul>\n<li>塞尔达续作</li>\n<li>搭载 Apple Silicon 芯片的 16 寸 MacBook Pro</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。</p>\n","site":{"data":{}},"excerpt":"<p>每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。</p>\n<blockquote>\n<p>“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” </p>\n<p>“可我会永远喜欢你的，这和时间没有关系，我想。”</p>\n<p>– 「舞！舞！舞！」</p>\n</blockquote>","more":"<h3 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h3><p><img src=\"/images/switch_2020.png\" alt=\"switch 2020\"></p>\n<ul>\n<li>The Legend of Zelda: Breath of the Wild</li>\n<li>Hades</li>\n<li>Animal Crossing: New Horizons</li>\n<li>火焰纹章：风花雪月</li>\n<li>Ori and the Will of the Wisps</li>\n</ul>\n<p>在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。</p>\n<p>2021 年最期待塞尔达的续作。</p>\n<h3 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h3><ul>\n<li>Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks</li>\n<li>「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ</li>\n<li>Zelda &amp; Chill by Mikel &amp; GameChops</li>\n<li>Zelda &amp; Chill 2 by Mikel &amp; GameChops</li>\n<li>如果你爱我 by Tanya Chua</li>\n</ul>\n<p><a href=\"https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW\">Replay 2020 - Apple Music for Reyshawn</a></p>\n<p>(上面的链接，国内用户需要挂代理才可以打开。)</p>\n<h3 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h3><ul>\n<li>「舞！舞！舞！」</li>\n</ul>\n<p>非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。</p>\n<p><img src=\"/images/%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81.png\" alt=\"舞！舞！舞！\"></p>\n<p>技术类书籍看了一些：</p>\n<ul>\n<li>Combine Asynchronous Programming with Swift</li>\n<li>Node.js Design Patterns</li>\n<li>iOS Development with Swift</li>\n<li>Programming iOS 13</li>\n<li>Python Parallel Programming Cookbook</li>\n</ul>\n<p>闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。</p>\n<h3 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h3><p><img src=\"/images/movies_2020.PNG\" alt=\"movies 2020\"></p>\n<p>看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。</p>\n<h3 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h3><p>今年一些值得纪念的时刻：</p>\n<blockquote>\n<p><em>2020.06.23</em></p>\n<p>凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。</p>\n</blockquote>\n<p>背景音乐是 vox freak 版本的 <em>Ur So F**kInG cOoL</em>，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。</p>\n<blockquote>\n<p><em>2020.11.12</em></p>\n<p>今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.</p>\n<p><a href=\"https://browser.geekbench.com/v5/cpu/4652635\">https://browser.geekbench.com/v5/cpu/4652635</a><br><a href=\"https://browser.geekbench.com/v5/cpu/4648107\">https://browser.geekbench.com/v5/cpu/4648107</a></p>\n</blockquote>\n<p>M1 芯片的发布相当震撼。期待明年的 16寸 MBP。</p>\n<blockquote>\n<p><em>2020.11.19</em></p>\n<p>看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。</p>\n</blockquote>\n<p>这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。</p>\n<h3 id=\"期待\"><a href=\"#期待\" class=\"headerlink\" title=\"期待\"></a>期待</h3><p>来讲一讲明年的期待吧：</p>\n<ul>\n<li>塞尔达续作</li>\n<li>搭载 Apple Silicon 芯片的 16 寸 MacBook Pro</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。</p>"},{"title":"初见 Koa.js","date":"2019-01-26T11:41:00.000Z","catogries":"Coding","_content":"\n去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：\n\n- Node.js 的异步特性及异步是如何实现的\n- 异步实现的几种方式，callback 到 Promise 到 async/await\n- 什么是 middleware？\n- ejs template engine\n\n通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。\n\n<!--more-->\n\n## Hello world\n\n`app.use()` 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 `app.use()` 来实现的。\n\n`ctx` 内封装了 request 和 response  object。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async function(ctx) {\n    ctx.body = \"hello world ssss\";\n})\n\napp.listen(3000, function() {\n    console.log('listen port: 3000...')\n})\n```\n\n## 渲染 ejs 模版\n\n这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。\n\n使用 npm 安装：\n\n```shell\n$ npm install koa-views --save\n$ npm install ejs --save\n```\n\nserver.js 内容是\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\nconst views = require('koa-views');\n\napp.use(views(__dirname + '/views', {\n    map: {\n        html: 'ejs'\n    }\n}));\n\napp.use(async function(ctx) {\n    await ctx.render('layout.ejs');\n})\n\napp.listen(3000, function() {\n    console.log('listen port: 3000...')\n})\n```\n\n`./views/layout.ejs` 内容是\n\n```html\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <h1>Hello Koa, This is from ejs</h1>\n</body>\n```\n\n上面这个例子是不包含传值的，当需要向 template 传递值时，通过 `ctx.state` 来设置，将上面 render 部分修改成：\n\n```javascript\napp.use(async function(ctx) {\n    ctx.state = {\n        title: 'This is title',\n        body: 'body bla bla'\n    };\n    await ctx.render('layout.ejs');\n})\n```\n\n或者写成 `render` 的参数，二者是等价的：\n\n```javascript\napp.use(async function(ctx) {\n    await ctx.render('layout.ejs', {\n        title: 'This is title',\n        body: 'body bla bla'\n    });\n})\n```\n\n此时 template 修改成：\n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <h1><%- title %></h1>\n    <p><%- body %></p>\n</body>\n```\n\n通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？\n\n这里直接在 ejs 里使用 `include` 进行引用。\n\nheader.ejs\n\n```html\n<header>\n    <p>This is a header</p>\n</header>\n```\n\nlayout.ejs\n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <%- include ./header %>\n    <h1><%- title %></h1>\n    <p><%- body %></p>\n</body>\n```\n\n## Router 路由功能\n\n对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。\n\n![koa_routing](/images/koa_routing.png)\n\n```shell\n$ npm install koa-router --save\n```\n\nserver.js 中修改为：\n\n```javascript\nconst Router = require('koa-router');\nconst router = new Router()\n\nrouter.get('/', async function(ctx) {\n    await ctx.render('layout.ejs', {\n        title: 'This is title',\n        body: 'body bla bla'\n    });\n})\n\napp.use(router.routes());\n```\n\n我们看到，各个页面的渲染完全由 router 进行了接管。\n\n上面是最简单的 \"Get\" 请求，下面是给出一个\"Post\" 请求的例子，来自 [koa2 进阶学习笔记](https://chenshenhai.github.io/koa2-note/note/request/post.html)，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 `koa-router` 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。\n\n```javascript\n// receive the posting data\nfunction parsePostData(ctx) {\n    return new Promise((resolve, reject) => {\n        try {\n            let postData = \"\";\n            ctx.req.addListener('data', (data) => {\n                postData += data;\n            });\n            ctx.req.addListener('end', () => {\n                let parseData = parseQueryStr(postData);\n                resolve(parseData);\n            });\n        } catch(err) {\n            reject(err);\n        }\n    })\n}\n\n// convert the posting data to Object\nfunction parseQueryStr(data) {\n    let queryData = {};\n    let queryStrList = data.split('&');\n    for (let queryStr of queryStrList) {\n        let itemList = queryStr.split('=');\n        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);\n    }\n\n    return queryData;\n}\n\napp.use(views(__dirname + '/views', {\n    map: {\n        html: 'ejs'\n    }\n}));\n\nrouter.get('/', async function(ctx) {\n    await ctx.render('layout.ejs', {\n        data: 'no data posted'\n    });\n})\n\nrouter.post('/', async function(ctx) {\n    let postData = await parsePostData(ctx);\n    await ctx.render('layout.ejs', {\n        data: JSON.stringify(postData)\n    })\n})\n\napp.use(router.routes());\n\n```\n\nlayout.ejs 添加一个可以提交的表格，注意表格的 `method` 是 `POST`，`action` 是根目录页面 `\"/\"`。 \n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <%- include ./header %>\n    <h1>koa2 request post demo</h1>\n      <form method=\"POST\" action=\"/\">\n            <p>userName</p>\n            <input name=\"userName\" /><br/>\n            <p>nickName</p>\n            <input name=\"nickName\" /><br/>\n            <p>email</p>\n            <input name=\"email\" /><br/>\n            <button type=\"submit\">submit</button>\n      </form>\n      <p><%- data %><p>\n</body>\n```\n\n","source":"_posts/初见 Koa.md","raw":"---\ntitle: '初见 Koa.js'\ndate: 2019-01-26 19:41:00\ntags:\n- JavaScript\n- Node.js\n- Front-end\ncatogries: 'Coding'\n---\n\n去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：\n\n- Node.js 的异步特性及异步是如何实现的\n- 异步实现的几种方式，callback 到 Promise 到 async/await\n- 什么是 middleware？\n- ejs template engine\n\n通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。\n\n<!--more-->\n\n## Hello world\n\n`app.use()` 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 `app.use()` 来实现的。\n\n`ctx` 内封装了 request 和 response  object。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async function(ctx) {\n    ctx.body = \"hello world ssss\";\n})\n\napp.listen(3000, function() {\n    console.log('listen port: 3000...')\n})\n```\n\n## 渲染 ejs 模版\n\n这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。\n\n使用 npm 安装：\n\n```shell\n$ npm install koa-views --save\n$ npm install ejs --save\n```\n\nserver.js 内容是\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\nconst views = require('koa-views');\n\napp.use(views(__dirname + '/views', {\n    map: {\n        html: 'ejs'\n    }\n}));\n\napp.use(async function(ctx) {\n    await ctx.render('layout.ejs');\n})\n\napp.listen(3000, function() {\n    console.log('listen port: 3000...')\n})\n```\n\n`./views/layout.ejs` 内容是\n\n```html\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <h1>Hello Koa, This is from ejs</h1>\n</body>\n```\n\n上面这个例子是不包含传值的，当需要向 template 传递值时，通过 `ctx.state` 来设置，将上面 render 部分修改成：\n\n```javascript\napp.use(async function(ctx) {\n    ctx.state = {\n        title: 'This is title',\n        body: 'body bla bla'\n    };\n    await ctx.render('layout.ejs');\n})\n```\n\n或者写成 `render` 的参数，二者是等价的：\n\n```javascript\napp.use(async function(ctx) {\n    await ctx.render('layout.ejs', {\n        title: 'This is title',\n        body: 'body bla bla'\n    });\n})\n```\n\n此时 template 修改成：\n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <h1><%- title %></h1>\n    <p><%- body %></p>\n</body>\n```\n\n通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？\n\n这里直接在 ejs 里使用 `include` 进行引用。\n\nheader.ejs\n\n```html\n<header>\n    <p>This is a header</p>\n</header>\n```\n\nlayout.ejs\n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <%- include ./header %>\n    <h1><%- title %></h1>\n    <p><%- body %></p>\n</body>\n```\n\n## Router 路由功能\n\n对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。\n\n![koa_routing](/images/koa_routing.png)\n\n```shell\n$ npm install koa-router --save\n```\n\nserver.js 中修改为：\n\n```javascript\nconst Router = require('koa-router');\nconst router = new Router()\n\nrouter.get('/', async function(ctx) {\n    await ctx.render('layout.ejs', {\n        title: 'This is title',\n        body: 'body bla bla'\n    });\n})\n\napp.use(router.routes());\n```\n\n我们看到，各个页面的渲染完全由 router 进行了接管。\n\n上面是最简单的 \"Get\" 请求，下面是给出一个\"Post\" 请求的例子，来自 [koa2 进阶学习笔记](https://chenshenhai.github.io/koa2-note/note/request/post.html)，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 `koa-router` 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。\n\n```javascript\n// receive the posting data\nfunction parsePostData(ctx) {\n    return new Promise((resolve, reject) => {\n        try {\n            let postData = \"\";\n            ctx.req.addListener('data', (data) => {\n                postData += data;\n            });\n            ctx.req.addListener('end', () => {\n                let parseData = parseQueryStr(postData);\n                resolve(parseData);\n            });\n        } catch(err) {\n            reject(err);\n        }\n    })\n}\n\n// convert the posting data to Object\nfunction parseQueryStr(data) {\n    let queryData = {};\n    let queryStrList = data.split('&');\n    for (let queryStr of queryStrList) {\n        let itemList = queryStr.split('=');\n        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);\n    }\n\n    return queryData;\n}\n\napp.use(views(__dirname + '/views', {\n    map: {\n        html: 'ejs'\n    }\n}));\n\nrouter.get('/', async function(ctx) {\n    await ctx.render('layout.ejs', {\n        data: 'no data posted'\n    });\n})\n\nrouter.post('/', async function(ctx) {\n    let postData = await parsePostData(ctx);\n    await ctx.render('layout.ejs', {\n        data: JSON.stringify(postData)\n    })\n})\n\napp.use(router.routes());\n\n```\n\nlayout.ejs 添加一个可以提交的表格，注意表格的 `method` 是 `POST`，`action` 是根目录页面 `\"/\"`。 \n\n```ejs\n<!DOCTYPE html>\n<head>\n\n</head>\n<body>\n    <%- include ./header %>\n    <h1>koa2 request post demo</h1>\n      <form method=\"POST\" action=\"/\">\n            <p>userName</p>\n            <input name=\"userName\" /><br/>\n            <p>nickName</p>\n            <input name=\"nickName\" /><br/>\n            <p>email</p>\n            <input name=\"email\" /><br/>\n            <button type=\"submit\">submit</button>\n      </form>\n      <p><%- data %><p>\n</body>\n```\n\n","slug":"初见 Koa","published":1,"updated":"2019-01-26T11:48:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2b003trg1v303agc47","content":"<p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p>\n<ul>\n<li>Node.js 的异步特性及异步是如何实现的</li>\n<li>异步实现的几种方式，callback 到 Promise 到 async/await</li>\n<li>什么是 middleware？</li>\n<li>ejs template engine</li>\n</ul>\n<p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h2><p><code>app.use()</code> 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 <code>app.use()</code> 来实现的。</p>\n<p><code>ctx</code> 内封装了 request 和 response  object。</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\napp.use(async function(ctx) &#123;\n    ctx.body = &quot;hello world ssss&quot;;\n&#125;)\n\napp.listen(3000, function() &#123;\n    console.log(&#39;listen port: 3000...&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"渲染-ejs-模版\"><a href=\"#渲染-ejs-模版\" class=\"headerlink\" title=\"渲染 ejs 模版\"></a>渲染 ejs 模版</h2><p>这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。</p>\n<p>使用 npm 安装：</p>\n<pre><code class=\"shell\">$ npm install koa-views --save\n$ npm install ejs --save\n</code></pre>\n<p>server.js 内容是</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nconst views = require(&#39;koa-views&#39;);\n\napp.use(views(__dirname + &#39;/views&#39;, &#123;\n    map: &#123;\n        html: &#39;ejs&#39;\n    &#125;\n&#125;));\n\napp.use(async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;);\n&#125;)\n\napp.listen(3000, function() &#123;\n    console.log(&#39;listen port: 3000...&#39;)\n&#125;)\n</code></pre>\n<p><code>./views/layout.ejs</code> 内容是</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello Koa, This is from ejs&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre>\n<p>上面这个例子是不包含传值的，当需要向 template 传递值时，通过 <code>ctx.state</code> 来设置，将上面 render 部分修改成：</p>\n<pre><code class=\"javascript\">app.use(async function(ctx) &#123;\n    ctx.state = &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;;\n    await ctx.render(&#39;layout.ejs&#39;);\n&#125;)\n</code></pre>\n<p>或者写成 <code>render</code> 的参数，二者是等价的：</p>\n<pre><code class=\"javascript\">app.use(async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;);\n&#125;)\n</code></pre>\n<p>此时 template 修改成：</p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;\n    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;\n&lt;/body&gt;\n</code></pre>\n<p>通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？</p>\n<p>这里直接在 ejs 里使用 <code>include</code> 进行引用。</p>\n<p>header.ejs</p>\n<pre><code class=\"html\">&lt;header&gt;\n    &lt;p&gt;This is a header&lt;/p&gt;\n&lt;/header&gt;\n</code></pre>\n<p>layout.ejs</p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- include ./header %&gt;\n    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;\n    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"Router-路由功能\"><a href=\"#Router-路由功能\" class=\"headerlink\" title=\"Router 路由功能\"></a>Router 路由功能</h2><p>对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。</p>\n<p><img src=\"/images/koa_routing.png\" alt=\"koa_routing\"></p>\n<pre><code class=\"shell\">$ npm install koa-router --save\n</code></pre>\n<p>server.js 中修改为：</p>\n<pre><code class=\"javascript\">const Router = require(&#39;koa-router&#39;);\nconst router = new Router()\n\nrouter.get(&#39;/&#39;, async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;);\n&#125;)\n\napp.use(router.routes());\n</code></pre>\n<p>我们看到，各个页面的渲染完全由 router 进行了接管。</p>\n<p>上面是最简单的 “Get” 请求，下面是给出一个”Post” 请求的例子，来自 <a href=\"https://chenshenhai.github.io/koa2-note/note/request/post.html\">koa2 进阶学习笔记</a>，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 <code>koa-router</code> 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。</p>\n<pre><code class=\"javascript\">// receive the posting data\nfunction parsePostData(ctx) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        try &#123;\n            let postData = &quot;&quot;;\n            ctx.req.addListener(&#39;data&#39;, (data) =&gt; &#123;\n                postData += data;\n            &#125;);\n            ctx.req.addListener(&#39;end&#39;, () =&gt; &#123;\n                let parseData = parseQueryStr(postData);\n                resolve(parseData);\n            &#125;);\n        &#125; catch(err) &#123;\n            reject(err);\n        &#125;\n    &#125;)\n&#125;\n\n// convert the posting data to Object\nfunction parseQueryStr(data) &#123;\n    let queryData = &#123;&#125;;\n    let queryStrList = data.split(&#39;&amp;&#39;);\n    for (let queryStr of queryStrList) &#123;\n        let itemList = queryStr.split(&#39;=&#39;);\n        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);\n    &#125;\n\n    return queryData;\n&#125;\n\napp.use(views(__dirname + &#39;/views&#39;, &#123;\n    map: &#123;\n        html: &#39;ejs&#39;\n    &#125;\n&#125;));\n\nrouter.get(&#39;/&#39;, async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        data: &#39;no data posted&#39;\n    &#125;);\n&#125;)\n\nrouter.post(&#39;/&#39;, async function(ctx) &#123;\n    let postData = await parsePostData(ctx);\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        data: JSON.stringify(postData)\n    &#125;)\n&#125;)\n\napp.use(router.routes());\n</code></pre>\n<p>layout.ejs 添加一个可以提交的表格，注意表格的 <code>method</code> 是 <code>POST</code>，<code>action</code> 是根目录页面 <code>&quot;/&quot;</code>。 </p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- include ./header %&gt;\n    &lt;h1&gt;koa2 request post demo&lt;/h1&gt;\n      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;\n            &lt;p&gt;userName&lt;/p&gt;\n            &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;\n            &lt;p&gt;nickName&lt;/p&gt;\n            &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;\n            &lt;p&gt;email&lt;/p&gt;\n            &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;\n            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;\n      &lt;/form&gt;\n      &lt;p&gt;&lt;%- data %&gt;&lt;p&gt;\n&lt;/body&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p>\n<ul>\n<li>Node.js 的异步特性及异步是如何实现的</li>\n<li>异步实现的几种方式，callback 到 Promise 到 async/await</li>\n<li>什么是 middleware？</li>\n<li>ejs template engine</li>\n</ul>\n<p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p>","more":"<h2 id=\"Hello-world\"><a href=\"#Hello-world\" class=\"headerlink\" title=\"Hello world\"></a>Hello world</h2><p><code>app.use()</code> 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 <code>app.use()</code> 来实现的。</p>\n<p><code>ctx</code> 内封装了 request 和 response  object。</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\napp.use(async function(ctx) &#123;\n    ctx.body = &quot;hello world ssss&quot;;\n&#125;)\n\napp.listen(3000, function() &#123;\n    console.log(&#39;listen port: 3000...&#39;)\n&#125;)\n</code></pre>\n<h2 id=\"渲染-ejs-模版\"><a href=\"#渲染-ejs-模版\" class=\"headerlink\" title=\"渲染 ejs 模版\"></a>渲染 ejs 模版</h2><p>这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。</p>\n<p>使用 npm 安装：</p>\n<pre><code class=\"shell\">$ npm install koa-views --save\n$ npm install ejs --save\n</code></pre>\n<p>server.js 内容是</p>\n<pre><code class=\"javascript\">const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nconst views = require(&#39;koa-views&#39;);\n\napp.use(views(__dirname + &#39;/views&#39;, &#123;\n    map: &#123;\n        html: &#39;ejs&#39;\n    &#125;\n&#125;));\n\napp.use(async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;);\n&#125;)\n\napp.listen(3000, function() &#123;\n    console.log(&#39;listen port: 3000...&#39;)\n&#125;)\n</code></pre>\n<p><code>./views/layout.ejs</code> 内容是</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Hello Koa, This is from ejs&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre>\n<p>上面这个例子是不包含传值的，当需要向 template 传递值时，通过 <code>ctx.state</code> 来设置，将上面 render 部分修改成：</p>\n<pre><code class=\"javascript\">app.use(async function(ctx) &#123;\n    ctx.state = &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;;\n    await ctx.render(&#39;layout.ejs&#39;);\n&#125;)\n</code></pre>\n<p>或者写成 <code>render</code> 的参数，二者是等价的：</p>\n<pre><code class=\"javascript\">app.use(async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;);\n&#125;)\n</code></pre>\n<p>此时 template 修改成：</p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;\n    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;\n&lt;/body&gt;\n</code></pre>\n<p>通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？</p>\n<p>这里直接在 ejs 里使用 <code>include</code> 进行引用。</p>\n<p>header.ejs</p>\n<pre><code class=\"html\">&lt;header&gt;\n    &lt;p&gt;This is a header&lt;/p&gt;\n&lt;/header&gt;\n</code></pre>\n<p>layout.ejs</p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- include ./header %&gt;\n    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;\n    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;\n&lt;/body&gt;\n</code></pre>\n<h2 id=\"Router-路由功能\"><a href=\"#Router-路由功能\" class=\"headerlink\" title=\"Router 路由功能\"></a>Router 路由功能</h2><p>对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。</p>\n<p><img src=\"/images/koa_routing.png\" alt=\"koa_routing\"></p>\n<pre><code class=\"shell\">$ npm install koa-router --save\n</code></pre>\n<p>server.js 中修改为：</p>\n<pre><code class=\"javascript\">const Router = require(&#39;koa-router&#39;);\nconst router = new Router()\n\nrouter.get(&#39;/&#39;, async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        title: &#39;This is title&#39;,\n        body: &#39;body bla bla&#39;\n    &#125;);\n&#125;)\n\napp.use(router.routes());\n</code></pre>\n<p>我们看到，各个页面的渲染完全由 router 进行了接管。</p>\n<p>上面是最简单的 “Get” 请求，下面是给出一个”Post” 请求的例子，来自 <a href=\"https://chenshenhai.github.io/koa2-note/note/request/post.html\">koa2 进阶学习笔记</a>，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 <code>koa-router</code> 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。</p>\n<pre><code class=\"javascript\">// receive the posting data\nfunction parsePostData(ctx) &#123;\n    return new Promise((resolve, reject) =&gt; &#123;\n        try &#123;\n            let postData = &quot;&quot;;\n            ctx.req.addListener(&#39;data&#39;, (data) =&gt; &#123;\n                postData += data;\n            &#125;);\n            ctx.req.addListener(&#39;end&#39;, () =&gt; &#123;\n                let parseData = parseQueryStr(postData);\n                resolve(parseData);\n            &#125;);\n        &#125; catch(err) &#123;\n            reject(err);\n        &#125;\n    &#125;)\n&#125;\n\n// convert the posting data to Object\nfunction parseQueryStr(data) &#123;\n    let queryData = &#123;&#125;;\n    let queryStrList = data.split(&#39;&amp;&#39;);\n    for (let queryStr of queryStrList) &#123;\n        let itemList = queryStr.split(&#39;=&#39;);\n        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);\n    &#125;\n\n    return queryData;\n&#125;\n\napp.use(views(__dirname + &#39;/views&#39;, &#123;\n    map: &#123;\n        html: &#39;ejs&#39;\n    &#125;\n&#125;));\n\nrouter.get(&#39;/&#39;, async function(ctx) &#123;\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        data: &#39;no data posted&#39;\n    &#125;);\n&#125;)\n\nrouter.post(&#39;/&#39;, async function(ctx) &#123;\n    let postData = await parsePostData(ctx);\n    await ctx.render(&#39;layout.ejs&#39;, &#123;\n        data: JSON.stringify(postData)\n    &#125;)\n&#125;)\n\napp.use(router.routes());\n</code></pre>\n<p>layout.ejs 添加一个可以提交的表格，注意表格的 <code>method</code> 是 <code>POST</code>，<code>action</code> 是根目录页面 <code>&quot;/&quot;</code>。 </p>\n<pre><code class=\"ejs\">&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- include ./header %&gt;\n    &lt;h1&gt;koa2 request post demo&lt;/h1&gt;\n      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;\n            &lt;p&gt;userName&lt;/p&gt;\n            &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;\n            &lt;p&gt;nickName&lt;/p&gt;\n            &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;\n            &lt;p&gt;email&lt;/p&gt;\n            &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;\n            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;\n      &lt;/form&gt;\n      &lt;p&gt;&lt;%- data %&gt;&lt;p&gt;\n&lt;/body&gt;\n</code></pre>"},{"title":"十年回顾","date":"2020-01-01T05:50:15.000Z","_content":"\n我在两个月前的某[测评网站](https://www.apesk.com/mbti/)上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是[「蝙蝠侠：黑暗骑士」](https://movie.douban.com/subject/1851857/)，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。\n\n从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。\n\n<!--more-->\n\n### 「骑着白马入地狱，叼着纸烟进天堂」\n\n**2017 - 2019**\n\n这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。\n\n2017.9.10，自己的文章标题[「骑着白马入地狱，叼着纸烟进天堂」]([https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/](https://reyshawn.com/2017/09/10/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」/))，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。\n\n到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。\n\n在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：\n\n>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。\n\n处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：\n\n- Movies 🎬\n- Coding 💻\n- Basketball 🏀\n- Books 📚\n- Porn 🔞\n\n2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。\n\n2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。\n\n看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。\n\n2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。\n\n后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。\n\n> 世上无难事，只要肯放弃。\n\n我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。\n\n>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。\n\n这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。\n\n### 「间奏曲，怀抱既然不能逗留」\n\n**2012 - 2016**\n\n2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。\n\n>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。\n\n2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。\n\n2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。\n\n我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。\n\n2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：\n\n- IT 公论\n- 反派影评\n- 观影风向标\n- 内核恐慌\n- 得意忘形\n- 游戏领航员\n- 味之道\n- 流行通信\n\n从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。\n\n### 「美丽生活」\n\n2010 - 2012\n\n更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。\n\n每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。\n\n现在还保存的三张电影光盘：\n\n- 裂缝\n- 时间的灰烬\n- 惧乳：伤心的奶水\n\n![IMG_1578](/images/IMG_1578.JPG)\n\n后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。\n\n尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。\n\n### 后记\n\n**2020 - 未知**\n\n生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。\n\n","source":"_posts/十年回顾.md","raw":"---\ntitle: 十年回顾\ndate: 2020-01-01 13:50:15\ntags:\ncategories: 'I/O'\n---\n\n我在两个月前的某[测评网站](https://www.apesk.com/mbti/)上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是[「蝙蝠侠：黑暗骑士」](https://movie.douban.com/subject/1851857/)，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。\n\n从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。\n\n<!--more-->\n\n### 「骑着白马入地狱，叼着纸烟进天堂」\n\n**2017 - 2019**\n\n这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。\n\n2017.9.10，自己的文章标题[「骑着白马入地狱，叼着纸烟进天堂」]([https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/](https://reyshawn.com/2017/09/10/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」/))，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。\n\n到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。\n\n在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：\n\n>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。\n\n处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：\n\n- Movies 🎬\n- Coding 💻\n- Basketball 🏀\n- Books 📚\n- Porn 🔞\n\n2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。\n\n2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。\n\n看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。\n\n2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。\n\n后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。\n\n> 世上无难事，只要肯放弃。\n\n我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。\n\n>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。\n\n这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。\n\n### 「间奏曲，怀抱既然不能逗留」\n\n**2012 - 2016**\n\n2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。\n\n>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。\n\n2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。\n\n2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。\n\n我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。\n\n2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：\n\n- IT 公论\n- 反派影评\n- 观影风向标\n- 内核恐慌\n- 得意忘形\n- 游戏领航员\n- 味之道\n- 流行通信\n\n从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。\n\n### 「美丽生活」\n\n2010 - 2012\n\n更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。\n\n每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。\n\n现在还保存的三张电影光盘：\n\n- 裂缝\n- 时间的灰烬\n- 惧乳：伤心的奶水\n\n![IMG_1578](/images/IMG_1578.JPG)\n\n后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。\n\n尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。\n\n### 后记\n\n**2020 - 未知**\n\n生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。\n\n","slug":"十年回顾","published":1,"updated":"2020-12-31T02:27:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c003vrg1v6b2ahwnm","content":"<p>我在两个月前的某<a href=\"https://www.apesk.com/mbti/\">测评网站</a>上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是<a href=\"https://movie.douban.com/subject/1851857/\">「蝙蝠侠：黑暗骑士」</a>，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。</p>\n<p>从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"「骑着白马入地狱，叼着纸烟进天堂」\"><a href=\"#「骑着白马入地狱，叼着纸烟进天堂」\" class=\"headerlink\" title=\"「骑着白马入地狱，叼着纸烟进天堂」\"></a>「骑着白马入地狱，叼着纸烟进天堂」</h3><p><strong>2017 - 2019</strong></p>\n<p>这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。</p>\n<p>2017.9.10，自己的文章标题<a href=\"%5Bhttps://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/%5D(https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/)\">「骑着白马入地狱，叼着纸烟进天堂」</a>，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。</p>\n<p>到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。</p>\n<p>在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：</p>\n<blockquote>\n<p>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。</p>\n</blockquote>\n<p>处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：</p>\n<ul>\n<li>Movies 🎬</li>\n<li>Coding 💻</li>\n<li>Basketball 🏀</li>\n<li>Books 📚</li>\n<li>Porn 🔞</li>\n</ul>\n<p>2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。</p>\n<p>2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。</p>\n<p>看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。</p>\n<p>2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。</p>\n<p>后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。</p>\n<blockquote>\n<p>世上无难事，只要肯放弃。</p>\n</blockquote>\n<p>我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。</p>\n<blockquote>\n<p>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。</p>\n</blockquote>\n<p>这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。</p>\n<h3 id=\"「间奏曲，怀抱既然不能逗留」\"><a href=\"#「间奏曲，怀抱既然不能逗留」\" class=\"headerlink\" title=\"「间奏曲，怀抱既然不能逗留」\"></a>「间奏曲，怀抱既然不能逗留」</h3><p><strong>2012 - 2016</strong></p>\n<p>2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。</p>\n<blockquote>\n<p>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。</p>\n</blockquote>\n<p>2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。</p>\n<p>2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。</p>\n<p>我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。</p>\n<p>2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：</p>\n<ul>\n<li>IT 公论</li>\n<li>反派影评</li>\n<li>观影风向标</li>\n<li>内核恐慌</li>\n<li>得意忘形</li>\n<li>游戏领航员</li>\n<li>味之道</li>\n<li>流行通信</li>\n</ul>\n<p>从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。</p>\n<h3 id=\"「美丽生活」\"><a href=\"#「美丽生活」\" class=\"headerlink\" title=\"「美丽生活」\"></a>「美丽生活」</h3><p>2010 - 2012</p>\n<p>更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。</p>\n<p>每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。</p>\n<p>现在还保存的三张电影光盘：</p>\n<ul>\n<li>裂缝</li>\n<li>时间的灰烬</li>\n<li>惧乳：伤心的奶水</li>\n</ul>\n<p><img src=\"/images/IMG_1578.JPG\" alt=\"IMG_1578\"></p>\n<p>后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。</p>\n<p>尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p><strong>2020 - 未知</strong></p>\n<p>生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。</p>\n","site":{"data":{}},"excerpt":"<p>我在两个月前的某<a href=\"https://www.apesk.com/mbti/\">测评网站</a>上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是<a href=\"https://movie.douban.com/subject/1851857/\">「蝙蝠侠：黑暗骑士」</a>，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。</p>\n<p>从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。</p>","more":"<h3 id=\"「骑着白马入地狱，叼着纸烟进天堂」\"><a href=\"#「骑着白马入地狱，叼着纸烟进天堂」\" class=\"headerlink\" title=\"「骑着白马入地狱，叼着纸烟进天堂」\"></a>「骑着白马入地狱，叼着纸烟进天堂」</h3><p><strong>2017 - 2019</strong></p>\n<p>这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。</p>\n<p>2017.9.10，自己的文章标题<a href=\"%5Bhttps://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/%5D(https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/)\">「骑着白马入地狱，叼着纸烟进天堂」</a>，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。</p>\n<p>到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。</p>\n<p>在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：</p>\n<blockquote>\n<p>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。</p>\n</blockquote>\n<p>处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：</p>\n<ul>\n<li>Movies 🎬</li>\n<li>Coding 💻</li>\n<li>Basketball 🏀</li>\n<li>Books 📚</li>\n<li>Porn 🔞</li>\n</ul>\n<p>2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。</p>\n<p>2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。</p>\n<p>看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。</p>\n<p>2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。</p>\n<p>后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。</p>\n<blockquote>\n<p>世上无难事，只要肯放弃。</p>\n</blockquote>\n<p>我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。</p>\n<blockquote>\n<p>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。</p>\n</blockquote>\n<p>这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。</p>\n<h3 id=\"「间奏曲，怀抱既然不能逗留」\"><a href=\"#「间奏曲，怀抱既然不能逗留」\" class=\"headerlink\" title=\"「间奏曲，怀抱既然不能逗留」\"></a>「间奏曲，怀抱既然不能逗留」</h3><p><strong>2012 - 2016</strong></p>\n<p>2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。</p>\n<blockquote>\n<p>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。</p>\n</blockquote>\n<p>2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。</p>\n<p>2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。</p>\n<p>我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。</p>\n<p>2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：</p>\n<ul>\n<li>IT 公论</li>\n<li>反派影评</li>\n<li>观影风向标</li>\n<li>内核恐慌</li>\n<li>得意忘形</li>\n<li>游戏领航员</li>\n<li>味之道</li>\n<li>流行通信</li>\n</ul>\n<p>从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。</p>\n<h3 id=\"「美丽生活」\"><a href=\"#「美丽生活」\" class=\"headerlink\" title=\"「美丽生活」\"></a>「美丽生活」</h3><p>2010 - 2012</p>\n<p>更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。</p>\n<p>每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。</p>\n<p>现在还保存的三张电影光盘：</p>\n<ul>\n<li>裂缝</li>\n<li>时间的灰烬</li>\n<li>惧乳：伤心的奶水</li>\n</ul>\n<p><img src=\"/images/IMG_1578.JPG\" alt=\"IMG_1578\"></p>\n<p>后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。</p>\n<p>尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p><strong>2020 - 未知</strong></p>\n<p>生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。</p>"},{"title":"多个项目共享 Webpack","date":"2019-08-29T13:00:03.000Z","_content":"\n最近在看 [@keyframer]() 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。\n\n因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  `package.json` 里预先定义好 \n\n```json\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\",\n    \"build\": \"webpack\"\n}\n```\n\n然后 `npm run dev`。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。\n\n<!--more-->\n\n项目的结构是这样的：\n\n```shell\n.\n├── Project1\n│   ├── dist\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project2\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project3\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── node_modules // all webpack related node modules\n├── package-lock.json\n└── package.json\n```\n\n需要一个parent directory，在 parent directory 里首先 `npn init -y`，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 `package.json` 中的  `script` 修改成：\n\n```json\n\"scripts\": {\n    \"dev\": \"../node_modules/.bin/webpack-dev-server\",\n    \"build\": \"../node_modules/.bin/webpack\"\n }\n```\n\n这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 `webpack.config.js`。\n\n","source":"_posts/多个项目共享-Webpack.md","raw":"---\ntitle: 多个项目共享 Webpack\ndate: 2019-08-29 21:00:03\ntags:\n- JavaScript\n- Front-end\n---\n\n最近在看 [@keyframer]() 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。\n\n因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  `package.json` 里预先定义好 \n\n```json\n\"scripts\": {\n    \"dev\": \"webpack-dev-server\",\n    \"build\": \"webpack\"\n}\n```\n\n然后 `npm run dev`。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。\n\n<!--more-->\n\n项目的结构是这样的：\n\n```shell\n.\n├── Project1\n│   ├── dist\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project2\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project3\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── node_modules // all webpack related node modules\n├── package-lock.json\n└── package.json\n```\n\n需要一个parent directory，在 parent directory 里首先 `npn init -y`，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 `package.json` 中的  `script` 修改成：\n\n```json\n\"scripts\": {\n    \"dev\": \"../node_modules/.bin/webpack-dev-server\",\n    \"build\": \"../node_modules/.bin/webpack\"\n }\n```\n\n这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 `webpack.config.js`。\n\n","slug":"多个项目共享-Webpack","published":1,"updated":"2019-08-29T13:48:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c003xrg1v22b1dk0t","content":"<p>最近在看 <a href=\"\">@keyframer</a> 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。</p>\n<p>因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  <code>package.json</code> 里预先定义好 </p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server&quot;,\n    &quot;build&quot;: &quot;webpack&quot;\n&#125;\n</code></pre>\n<p>然后 <code>npm run dev</code>。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。</p>\n<span id=\"more\"></span>\n\n<p>项目的结构是这样的：</p>\n<pre><code class=\"shell\">.\n├── Project1\n│   ├── dist\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project2\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project3\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── node_modules // all webpack related node modules\n├── package-lock.json\n└── package.json\n</code></pre>\n<p>需要一个parent directory，在 parent directory 里首先 <code>npn init -y</code>，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 <code>package.json</code> 中的  <code>script</code> 修改成：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;../node_modules/.bin/webpack-dev-server&quot;,\n    &quot;build&quot;: &quot;../node_modules/.bin/webpack&quot;\n &#125;\n</code></pre>\n<p>这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 <code>webpack.config.js</code>。</p>\n","site":{"data":{}},"excerpt":"<p>最近在看 <a href=\"\">@keyframer</a> 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。</p>\n<p>因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  <code>package.json</code> 里预先定义好 </p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server&quot;,\n    &quot;build&quot;: &quot;webpack&quot;\n&#125;\n</code></pre>\n<p>然后 <code>npm run dev</code>。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。</p>","more":"<p>项目的结构是这样的：</p>\n<pre><code class=\"shell\">.\n├── Project1\n│   ├── dist\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project2\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── Project3\n│   ├── dist\n│   ├── package-lock.json\n│   ├── package.json\n│   ├── src\n│   └── webpack.config.js\n├── node_modules // all webpack related node modules\n├── package-lock.json\n└── package.json\n</code></pre>\n<p>需要一个parent directory，在 parent directory 里首先 <code>npn init -y</code>，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 <code>package.json</code> 中的  <code>script</code> 修改成：</p>\n<pre><code class=\"json\">&quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;../node_modules/.bin/webpack-dev-server&quot;,\n    &quot;build&quot;: &quot;../node_modules/.bin/webpack&quot;\n &#125;\n</code></pre>\n<p>这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 <code>webpack.config.js</code>。</p>"},{"title":"异步 & callback","date":"2019-01-25T08:52:18.000Z","_content":"\n\n\n最近开始学习 Node.js。主要看两本书：*Node.js in Practice* 和 *Node.js Design Patterns*。前者类似于 o'reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&solution 实现的。后者就是 [Packt Publishing](https://search.packtpub.com/) 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。\n\n这篇文章以 *Node.js Design Patterns* 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。\n\n<!--more-->\n\n## callback，递归，libuv\n\n>Callbacks are to be used when we don’t know **when** something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.\n>\n>--[Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n\n在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  [Call stack](http://www.wikiwand.com/en/Call_stack)。那么为什么可以通过 callback 来实现异步？\n\n```javascript\n// This is synchronous.\nfunction processData() {   \n    let data = fetchData();   \n    data += 1;   \n    return data; \n}\n// This is asynchronous... \nfunction processData(callback) {   \n    fetchData(function (err, data) {     \n        if (err) {\n           return callback(err);\n        }     \n        data += 1;     \n        callback(null, data);   \n    }); \n}\n```\n\n在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 `fetchData()` 多了一个 callback 参数，后续的数据处理，`data += 1 ` 写在了这个 callback 里。也就意味着，当调用 `fetchData()` 后，整个程序不会停下来等待，而是接着进行下面的操作。当 `fetchData()` 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。\n\n> Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.\n>\n> --[Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n\n看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 `libuv` 来实现。`libuv` 让 Node.js 有了 non-blocking I/O 特性。\n\n> For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.\n>\n> -- p17 *Node.js Design Patterns*\n\n> This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.\n>\n> --p71 *Node.js Design Patterns*\n\n> 每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 \n>\n> --[libuv — 知乎专栏](https://zhuanlan.zhihu.com/p/50480439)\n\n这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 `libuv`，会让有着 callback 的函数会进行「异步」操作。\n\n>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.\n>\n>--[JavaScript: What the heck is a Callback?](https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced)\n\n关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。\n\n>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. \n>\n>-- [understanding node.js callback structure](https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure)\n\n## Web Spider 的 callback 实现\n\n在 *Node.js Design Patterns* 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 `fs.stat(path, callback)` 和 `request(url, callback)`[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。\n\n```javascript\nfunction download(url, filename, callback) {\n  console.log(`Downloading ${url}`);\n  request(url, (err, response, body) => {\n    if(err) {\n      return callback(err);\n    }\n    saveFile(filename, body, err => {\n      if(err) {\n        return callback(err);\n      }\n      console.log(`Downloaded and saved: ${url}`);\n      callback(null, body);\n    });\n  });\n}\n\nfunction spider(url, callback) {\n  const filename = utilities.urlToFilename(url);\n  fs.stat(filename, err => {\n    if(!err) {\n      return callback(null, filename, false);\n    }\n    download(url, filename, err => {\n      if(err) {\n        return callback(err);\n      }\n      callback(null, filename, true);\n    })\n  });\n}\n```\n\n\n\n### fs.stat()\n\n首先进入 `fs.stat()` 函数：\n\n```javascript\nfunction stat(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = toPathIfFileURL(path);\n  validatePath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\n```\n\nline 2 到 line 5 是参数判断和转换。line 6 `makeStatsCallback(callback)`，调用：\n\n```Javascript\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK();\n  }\n\n  return (err, stats) => {\n    if (err) return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  };\n}\n```\n\n按照注释说明，是 `makeCallback()` 的特殊情况，那我们就去看看 `makeCallback()` 是什么。\n\n```javascript\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK();\n  }\n\n  return (...args) => {\n    return Reflect.apply(cb, undefined, args);\n  };\n}\n```\n\n这段 code  的关键是 `Reflect.apply(cb, undefined, args);`。按照 MDN 的叙述，`Reflect` 是：\n\n>**Reflect** is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of [proxy handlers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler). `Reflect` is not a function object, so it's not constructible.\n>\n>Unlike most global objects, `Reflect` is not a constructor. You cannot use it with a [`new`operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) or invoke the `Reflect` object as a function. All properties and methods of `Reflect`are static (just like the [`Math`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math) object).\n\nReflect 是一个 global object。那么当调用 `Reflect.apply()`，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。\n\n`makeStatsCallback(callback)`之后关键的三步是：\n\n```javascript\nconst req = new FSReqCallback(options.bigint);\nreq.oncomplete = callback;\nbinding.stat(pathModule.toNamespacedPath(path), \n```\n\n`FSReqCallback` 和 `binding` 都是对更底层的 C library 调用。\n\n```javascript\nconst binding = process.binding('fs');\nconst { FSReqCallback, statValues } = binding;\n```\n\n从这里开始，就逐渐进入 `libuv` ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 `req.oncomplete = callback;` 字面含义所写的那样。\n\n\n\n### request\n\nrequest 是一个简单的 Http client。这是它们的 [Git repo](https://github.com/request/request)。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 `fs.stat()` 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 `body` 内容。这些操作，都是通过 `request` 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 `request.Request(params)` 来实现的。\n\n```javascript\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n```\n\nline 6 对参数进行初始化：\n\n```javascript\n// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n```\n\n`request()` 函数返回的  `request.Request(params)`  如下：\n\n```javascript\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n```\n\n注意一下 line 17，`stream.Stream.call(self)`，在进入这个函数内部后，来到：\n\n```javascript\n// legacy.js\nconst EE = require('events');\nconst util = require('util');\n\nfunction Stream() {\n  EE.call(this);\n}\n```\n\n因为 EE 是来自 events 导出的 EventEmitter，`EE.call(this)` 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：\n\n`EventEmitter` <- `stream.Stream` <- `Request`\n\n## 后记\n\n这篇文章最初是想弄清楚 `fs` 和 `request` 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 `libuv` ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。\n\n\n\n[^1]: 原文判断文件存在用的是 `fs.exists()`，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。\n\n \n\n---\n\n\n\n参考：\n\n- [Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n- [Nodejs: What does `process.binding` mean?](https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean)\n- [深入出不来nodejs源码-从fs.stat看node架构](https://zhuanlan.zhihu.com/p/40977678)\n- [Node.js_Design Patterns Second Edition Code](https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code)","source":"_posts/异步 & callback.md","raw":"---\ntitle: '异步 & callback'\ndate: \ntags:\n- Node.js\n- JavaScript\ncategories: \n- Coding\n---\n\n\n\n最近开始学习 Node.js。主要看两本书：*Node.js in Practice* 和 *Node.js Design Patterns*。前者类似于 o'reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&solution 实现的。后者就是 [Packt Publishing](https://search.packtpub.com/) 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。\n\n这篇文章以 *Node.js Design Patterns* 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。\n\n<!--more-->\n\n## callback，递归，libuv\n\n>Callbacks are to be used when we don’t know **when** something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.\n>\n>--[Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n\n在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  [Call stack](http://www.wikiwand.com/en/Call_stack)。那么为什么可以通过 callback 来实现异步？\n\n```javascript\n// This is synchronous.\nfunction processData() {   \n    let data = fetchData();   \n    data += 1;   \n    return data; \n}\n// This is asynchronous... \nfunction processData(callback) {   \n    fetchData(function (err, data) {     \n        if (err) {\n           return callback(err);\n        }     \n        data += 1;     \n        callback(null, data);   \n    }); \n}\n```\n\n在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 `fetchData()` 多了一个 callback 参数，后续的数据处理，`data += 1 ` 写在了这个 callback 里。也就意味着，当调用 `fetchData()` 后，整个程序不会停下来等待，而是接着进行下面的操作。当 `fetchData()` 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。\n\n> Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.\n>\n> --[Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n\n看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 `libuv` 来实现。`libuv` 让 Node.js 有了 non-blocking I/O 特性。\n\n> For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.\n>\n> -- p17 *Node.js Design Patterns*\n\n> This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.\n>\n> --p71 *Node.js Design Patterns*\n\n> 每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 \n>\n> --[libuv — 知乎专栏](https://zhuanlan.zhihu.com/p/50480439)\n\n这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 `libuv`，会让有着 callback 的函数会进行「异步」操作。\n\n>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.\n>\n>--[JavaScript: What the heck is a Callback?](https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced)\n\n关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。\n\n>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. \n>\n>-- [understanding node.js callback structure](https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure)\n\n## Web Spider 的 callback 实现\n\n在 *Node.js Design Patterns* 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 `fs.stat(path, callback)` 和 `request(url, callback)`[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。\n\n```javascript\nfunction download(url, filename, callback) {\n  console.log(`Downloading ${url}`);\n  request(url, (err, response, body) => {\n    if(err) {\n      return callback(err);\n    }\n    saveFile(filename, body, err => {\n      if(err) {\n        return callback(err);\n      }\n      console.log(`Downloaded and saved: ${url}`);\n      callback(null, body);\n    });\n  });\n}\n\nfunction spider(url, callback) {\n  const filename = utilities.urlToFilename(url);\n  fs.stat(filename, err => {\n    if(!err) {\n      return callback(null, filename, false);\n    }\n    download(url, filename, err => {\n      if(err) {\n        return callback(err);\n      }\n      callback(null, filename, true);\n    })\n  });\n}\n```\n\n\n\n### fs.stat()\n\n首先进入 `fs.stat()` 函数：\n\n```javascript\nfunction stat(path, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = toPathIfFileURL(path);\n  validatePath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n}\n```\n\nline 2 到 line 5 是参数判断和转换。line 6 `makeStatsCallback(callback)`，调用：\n\n```Javascript\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK();\n  }\n\n  return (err, stats) => {\n    if (err) return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  };\n}\n```\n\n按照注释说明，是 `makeCallback()` 的特殊情况，那我们就去看看 `makeCallback()` 是什么。\n\n```javascript\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (typeof cb !== 'function') {\n    throw new ERR_INVALID_CALLBACK();\n  }\n\n  return (...args) => {\n    return Reflect.apply(cb, undefined, args);\n  };\n}\n```\n\n这段 code  的关键是 `Reflect.apply(cb, undefined, args);`。按照 MDN 的叙述，`Reflect` 是：\n\n>**Reflect** is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of [proxy handlers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler). `Reflect` is not a function object, so it's not constructible.\n>\n>Unlike most global objects, `Reflect` is not a constructor. You cannot use it with a [`new`operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new) or invoke the `Reflect` object as a function. All properties and methods of `Reflect`are static (just like the [`Math`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math) object).\n\nReflect 是一个 global object。那么当调用 `Reflect.apply()`，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。\n\n`makeStatsCallback(callback)`之后关键的三步是：\n\n```javascript\nconst req = new FSReqCallback(options.bigint);\nreq.oncomplete = callback;\nbinding.stat(pathModule.toNamespacedPath(path), \n```\n\n`FSReqCallback` 和 `binding` 都是对更底层的 C library 调用。\n\n```javascript\nconst binding = process.binding('fs');\nconst { FSReqCallback, statValues } = binding;\n```\n\n从这里开始，就逐渐进入 `libuv` ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 `req.oncomplete = callback;` 字面含义所写的那样。\n\n\n\n### request\n\nrequest 是一个简单的 Http client。这是它们的 [Git repo](https://github.com/request/request)。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 `fs.stat()` 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 `body` 内容。这些操作，都是通过 `request` 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 `request.Request(params)` 来实现的。\n\n```javascript\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n```\n\nline 6 对参数进行初始化：\n\n```javascript\n// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n```\n\n`request()` 函数返回的  `request.Request(params)`  如下：\n\n```javascript\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n```\n\n注意一下 line 17，`stream.Stream.call(self)`，在进入这个函数内部后，来到：\n\n```javascript\n// legacy.js\nconst EE = require('events');\nconst util = require('util');\n\nfunction Stream() {\n  EE.call(this);\n}\n```\n\n因为 EE 是来自 events 导出的 EventEmitter，`EE.call(this)` 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：\n\n`EventEmitter` <- `stream.Stream` <- `Request`\n\n## 后记\n\n这篇文章最初是想弄清楚 `fs` 和 `request` 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 `libuv` ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。\n\n\n\n[^1]: 原文判断文件存在用的是 `fs.exists()`，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。\n\n \n\n---\n\n\n\n参考：\n\n- [Callbacks in Node.js: Why, When, How?](https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca)\n- [Nodejs: What does `process.binding` mean?](https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean)\n- [深入出不来nodejs源码-从fs.stat看node架构](https://zhuanlan.zhihu.com/p/40977678)\n- [Node.js_Design Patterns Second Edition Code](https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code)","slug":"异步 & callback","published":1,"updated":"2019-01-25T08:52:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c0040rg1vgi4bevol","content":"<p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href=\"https://search.packtpub.com/\">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p>\n<p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"callback，递归，libuv\"><a href=\"#callback，递归，libuv\" class=\"headerlink\" title=\"callback，递归，libuv\"></a>callback，递归，libuv</h2><blockquote>\n<p>Callbacks are to be used when we don’t know <strong>when</strong> something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.</p>\n<p>–<a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></p>\n</blockquote>\n<p>在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  <a href=\"http://www.wikiwand.com/en/Call_stack\">Call stack</a>。那么为什么可以通过 callback 来实现异步？</p>\n<pre><code class=\"javascript\">// This is synchronous.\nfunction processData() &#123;   \n    let data = fetchData();   \n    data += 1;   \n    return data; \n&#125;\n// This is asynchronous... \nfunction processData(callback) &#123;   \n    fetchData(function (err, data) &#123;     \n        if (err) &#123;\n           return callback(err);\n        &#125;     \n        data += 1;     \n        callback(null, data);   \n    &#125;); \n&#125;\n</code></pre>\n<p>在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 <code>fetchData()</code> 多了一个 callback 参数，后续的数据处理，<code>data += 1 </code> 写在了这个 callback 里。也就意味着，当调用 <code>fetchData()</code> 后，整个程序不会停下来等待，而是接着进行下面的操作。当 <code>fetchData()</code> 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。</p>\n<blockquote>\n<p>Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.</p>\n<p>–<a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></p>\n</blockquote>\n<p>看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 <code>libuv</code> 来实现。<code>libuv</code> 让 Node.js 有了 non-blocking I/O 特性。</p>\n<blockquote>\n<p>For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p>\n<p>– p17 <em>Node.js Design Patterns</em></p>\n</blockquote>\n<blockquote>\n<p>This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.</p>\n<p>–p71 <em>Node.js Design Patterns</em></p>\n</blockquote>\n<blockquote>\n<p>每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 </p>\n<p>–<a href=\"https://zhuanlan.zhihu.com/p/50480439\">libuv — 知乎专栏</a></p>\n</blockquote>\n<p>这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 <code>libuv</code>，会让有着 callback 的函数会进行「异步」操作。</p>\n<blockquote>\n<p>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p>\n<p>–<a href=\"https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced\">JavaScript: What the heck is a Callback?</a></p>\n</blockquote>\n<p>关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。</p>\n<blockquote>\n<p>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. </p>\n<p>– <a href=\"https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure\">understanding node.js callback structure</a></p>\n</blockquote>\n<h2 id=\"Web-Spider-的-callback-实现\"><a href=\"#Web-Spider-的-callback-实现\" class=\"headerlink\" title=\"Web Spider 的 callback 实现\"></a>Web Spider 的 callback 实现</h2><p>在 <em>Node.js Design Patterns</em> 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 <code>fs.stat(path, callback)</code> 和 <code>request(url, callback)</code>[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。</p>\n<pre><code class=\"javascript\">function download(url, filename, callback) &#123;\n  console.log(`Downloading $&#123;url&#125;`);\n  request(url, (err, response, body) =&gt; &#123;\n    if(err) &#123;\n      return callback(err);\n    &#125;\n    saveFile(filename, body, err =&gt; &#123;\n      if(err) &#123;\n        return callback(err);\n      &#125;\n      console.log(`Downloaded and saved: $&#123;url&#125;`);\n      callback(null, body);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction spider(url, callback) &#123;\n  const filename = utilities.urlToFilename(url);\n  fs.stat(filename, err =&gt; &#123;\n    if(!err) &#123;\n      return callback(null, filename, false);\n    &#125;\n    download(url, filename, err =&gt; &#123;\n      if(err) &#123;\n        return callback(err);\n      &#125;\n      callback(null, filename, true);\n    &#125;)\n  &#125;);\n&#125;\n</code></pre>\n<h3 id=\"fs-stat\"><a href=\"#fs-stat\" class=\"headerlink\" title=\"fs.stat()\"></a>fs.stat()</h3><p>首先进入 <code>fs.stat()</code> 函数：</p>\n<pre><code class=\"javascript\">function stat(path, options, callback) &#123;\n  if (typeof options === &#39;function&#39;) &#123;\n    callback = options;\n    options = &#123;&#125;;\n  &#125;\n  callback = makeStatsCallback(callback);\n  path = toPathIfFileURL(path);\n  validatePath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n&#125;\n</code></pre>\n<p>line 2 到 line 5 是参数判断和转换。line 6 <code>makeStatsCallback(callback)</code>，调用：</p>\n<pre><code class=\"Javascript\">// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) &#123;\n  if (typeof cb !== &#39;function&#39;) &#123;\n    throw new ERR_INVALID_CALLBACK();\n  &#125;\n\n  return (err, stats) =&gt; &#123;\n    if (err) return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  &#125;;\n&#125;\n</code></pre>\n<p>按照注释说明，是 <code>makeCallback()</code> 的特殊情况，那我们就去看看 <code>makeCallback()</code> 是什么。</p>\n<pre><code class=\"javascript\">// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) &#123;\n  if (typeof cb !== &#39;function&#39;) &#123;\n    throw new ERR_INVALID_CALLBACK();\n  &#125;\n\n  return (...args) =&gt; &#123;\n    return Reflect.apply(cb, undefined, args);\n  &#125;;\n&#125;\n</code></pre>\n<p>这段 code  的关键是 <code>Reflect.apply(cb, undefined, args);</code>。按照 MDN 的叙述，<code>Reflect</code> 是：</p>\n<blockquote>\n<p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler\">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p>\n<p>Unlike most global objects, <code>Reflect</code> is not a constructor. You cannot use it with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\"><code>new</code>operator</a> or invoke the <code>Reflect</code> object as a function. All properties and methods of <code>Reflect</code>are static (just like the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math\"><code>Math</code></a> object).</p>\n</blockquote>\n<p>Reflect 是一个 global object。那么当调用 <code>Reflect.apply()</code>，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。</p>\n<p><code>makeStatsCallback(callback)</code>之后关键的三步是：</p>\n<pre><code class=\"javascript\">const req = new FSReqCallback(options.bigint);\nreq.oncomplete = callback;\nbinding.stat(pathModule.toNamespacedPath(path), \n</code></pre>\n<p><code>FSReqCallback</code> 和 <code>binding</code> 都是对更底层的 C library 调用。</p>\n<pre><code class=\"javascript\">const binding = process.binding(&#39;fs&#39;);\nconst &#123; FSReqCallback, statValues &#125; = binding;\n</code></pre>\n<p>从这里开始，就逐渐进入 <code>libuv</code> ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 <code>req.oncomplete = callback;</code> 字面含义所写的那样。</p>\n<h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p>request 是一个简单的 Http client。这是它们的 <a href=\"https://github.com/request/request\">Git repo</a>。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 <code>fs.stat()</code> 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 <code>body</code> 内容。这些操作，都是通过 <code>request</code> 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 <code>request.Request(params)</code> 来实现的。</p>\n<pre><code class=\"javascript\">function request (uri, options, callback) &#123;\n  if (typeof uri === &#39;undefined&#39;) &#123;\n    throw new Error(&#39;undefined is not a valid uri or options object.&#39;)\n  &#125;\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === &#39;HEAD&#39; &amp;&amp; paramsHaveRequestBody(params)) &#123;\n    throw new Error(&#39;HTTP HEAD requests MUST NOT include a request body.&#39;)\n  &#125;\n\n  return new request.Request(params)\n&#125;\n</code></pre>\n<p>line 6 对参数进行初始化：</p>\n<pre><code class=\"javascript\">// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) &#123;\n  if (typeof options === &#39;function&#39;) &#123;\n    callback = options\n  &#125;\n\n  var params = &#123;&#125;\n  if (typeof options === &#39;object&#39;) &#123;\n    extend(params, options, &#123;uri: uri&#125;)\n  &#125; else if (typeof uri === &#39;string&#39;) &#123;\n    extend(params, &#123;uri: uri&#125;)\n  &#125; else &#123;\n    extend(params, uri)\n  &#125;\n\n  params.callback = callback || params.callback\n  return params\n&#125;\n</code></pre>\n<p><code>request()</code> 函数返回的  <code>request.Request(params)</code>  如下：</p>\n<pre><code class=\"javascript\">function Request (options) &#123;\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) &#123;\n    self._har = new Har(self)\n    options = self._har.options(options)\n  &#125;\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) &#123;\n    self.explicitMethod = true\n  &#125;\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n&#125;\n</code></pre>\n<p>注意一下 line 17，<code>stream.Stream.call(self)</code>，在进入这个函数内部后，来到：</p>\n<pre><code class=\"javascript\">// legacy.js\nconst EE = require(&#39;events&#39;);\nconst util = require(&#39;util&#39;);\n\nfunction Stream() &#123;\n  EE.call(this);\n&#125;\n</code></pre>\n<p>因为 EE 是来自 events 导出的 EventEmitter，<code>EE.call(this)</code> 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：</p>\n<p><code>EventEmitter</code> &lt;- <code>stream.Stream</code> &lt;- <code>Request</code></p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这篇文章最初是想弄清楚 <code>fs</code> 和 <code>request</code> 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 <code>libuv</code> ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。</p>\n<p>[^1]: 原文判断文件存在用的是 <code>fs.exists()</code>，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean\">Nodejs: What does <code>process.binding</code> mean?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40977678\">深入出不来nodejs源码-从fs.stat看node架构</a></li>\n<li><a href=\"https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code\">Node.js_Design Patterns Second Edition Code</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href=\"https://search.packtpub.com/\">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p>\n<p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p>","more":"<h2 id=\"callback，递归，libuv\"><a href=\"#callback，递归，libuv\" class=\"headerlink\" title=\"callback，递归，libuv\"></a>callback，递归，libuv</h2><blockquote>\n<p>Callbacks are to be used when we don’t know <strong>when</strong> something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.</p>\n<p>–<a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></p>\n</blockquote>\n<p>在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  <a href=\"http://www.wikiwand.com/en/Call_stack\">Call stack</a>。那么为什么可以通过 callback 来实现异步？</p>\n<pre><code class=\"javascript\">// This is synchronous.\nfunction processData() &#123;   \n    let data = fetchData();   \n    data += 1;   \n    return data; \n&#125;\n// This is asynchronous... \nfunction processData(callback) &#123;   \n    fetchData(function (err, data) &#123;     \n        if (err) &#123;\n           return callback(err);\n        &#125;     \n        data += 1;     \n        callback(null, data);   \n    &#125;); \n&#125;\n</code></pre>\n<p>在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 <code>fetchData()</code> 多了一个 callback 参数，后续的数据处理，<code>data += 1 </code> 写在了这个 callback 里。也就意味着，当调用 <code>fetchData()</code> 后，整个程序不会停下来等待，而是接着进行下面的操作。当 <code>fetchData()</code> 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。</p>\n<blockquote>\n<p>Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.</p>\n<p>–<a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></p>\n</blockquote>\n<p>看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 <code>libuv</code> 来实现。<code>libuv</code> 让 Node.js 有了 non-blocking I/O 特性。</p>\n<blockquote>\n<p>For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p>\n<p>– p17 <em>Node.js Design Patterns</em></p>\n</blockquote>\n<blockquote>\n<p>This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.</p>\n<p>–p71 <em>Node.js Design Patterns</em></p>\n</blockquote>\n<blockquote>\n<p>每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 </p>\n<p>–<a href=\"https://zhuanlan.zhihu.com/p/50480439\">libuv — 知乎专栏</a></p>\n</blockquote>\n<p>这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 <code>libuv</code>，会让有着 callback 的函数会进行「异步」操作。</p>\n<blockquote>\n<p>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p>\n<p>–<a href=\"https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced\">JavaScript: What the heck is a Callback?</a></p>\n</blockquote>\n<p>关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。</p>\n<blockquote>\n<p>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. </p>\n<p>– <a href=\"https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure\">understanding node.js callback structure</a></p>\n</blockquote>\n<h2 id=\"Web-Spider-的-callback-实现\"><a href=\"#Web-Spider-的-callback-实现\" class=\"headerlink\" title=\"Web Spider 的 callback 实现\"></a>Web Spider 的 callback 实现</h2><p>在 <em>Node.js Design Patterns</em> 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 <code>fs.stat(path, callback)</code> 和 <code>request(url, callback)</code>[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。</p>\n<pre><code class=\"javascript\">function download(url, filename, callback) &#123;\n  console.log(`Downloading $&#123;url&#125;`);\n  request(url, (err, response, body) =&gt; &#123;\n    if(err) &#123;\n      return callback(err);\n    &#125;\n    saveFile(filename, body, err =&gt; &#123;\n      if(err) &#123;\n        return callback(err);\n      &#125;\n      console.log(`Downloaded and saved: $&#123;url&#125;`);\n      callback(null, body);\n    &#125;);\n  &#125;);\n&#125;\n\nfunction spider(url, callback) &#123;\n  const filename = utilities.urlToFilename(url);\n  fs.stat(filename, err =&gt; &#123;\n    if(!err) &#123;\n      return callback(null, filename, false);\n    &#125;\n    download(url, filename, err =&gt; &#123;\n      if(err) &#123;\n        return callback(err);\n      &#125;\n      callback(null, filename, true);\n    &#125;)\n  &#125;);\n&#125;\n</code></pre>\n<h3 id=\"fs-stat\"><a href=\"#fs-stat\" class=\"headerlink\" title=\"fs.stat()\"></a>fs.stat()</h3><p>首先进入 <code>fs.stat()</code> 函数：</p>\n<pre><code class=\"javascript\">function stat(path, options, callback) &#123;\n  if (typeof options === &#39;function&#39;) &#123;\n    callback = options;\n    options = &#123;&#125;;\n  &#125;\n  callback = makeStatsCallback(callback);\n  path = toPathIfFileURL(path);\n  validatePath(path);\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n&#125;\n</code></pre>\n<p>line 2 到 line 5 是参数判断和转换。line 6 <code>makeStatsCallback(callback)</code>，调用：</p>\n<pre><code class=\"Javascript\">// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) &#123;\n  if (typeof cb !== &#39;function&#39;) &#123;\n    throw new ERR_INVALID_CALLBACK();\n  &#125;\n\n  return (err, stats) =&gt; &#123;\n    if (err) return cb(err);\n    cb(err, getStatsFromBinding(stats));\n  &#125;;\n&#125;\n</code></pre>\n<p>按照注释说明，是 <code>makeCallback()</code> 的特殊情况，那我们就去看看 <code>makeCallback()</code> 是什么。</p>\n<pre><code class=\"javascript\">// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) &#123;\n  if (typeof cb !== &#39;function&#39;) &#123;\n    throw new ERR_INVALID_CALLBACK();\n  &#125;\n\n  return (...args) =&gt; &#123;\n    return Reflect.apply(cb, undefined, args);\n  &#125;;\n&#125;\n</code></pre>\n<p>这段 code  的关键是 <code>Reflect.apply(cb, undefined, args);</code>。按照 MDN 的叙述，<code>Reflect</code> 是：</p>\n<blockquote>\n<p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler\">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p>\n<p>Unlike most global objects, <code>Reflect</code> is not a constructor. You cannot use it with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\"><code>new</code>operator</a> or invoke the <code>Reflect</code> object as a function. All properties and methods of <code>Reflect</code>are static (just like the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math\"><code>Math</code></a> object).</p>\n</blockquote>\n<p>Reflect 是一个 global object。那么当调用 <code>Reflect.apply()</code>，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。</p>\n<p><code>makeStatsCallback(callback)</code>之后关键的三步是：</p>\n<pre><code class=\"javascript\">const req = new FSReqCallback(options.bigint);\nreq.oncomplete = callback;\nbinding.stat(pathModule.toNamespacedPath(path), \n</code></pre>\n<p><code>FSReqCallback</code> 和 <code>binding</code> 都是对更底层的 C library 调用。</p>\n<pre><code class=\"javascript\">const binding = process.binding(&#39;fs&#39;);\nconst &#123; FSReqCallback, statValues &#125; = binding;\n</code></pre>\n<p>从这里开始，就逐渐进入 <code>libuv</code> ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 <code>req.oncomplete = callback;</code> 字面含义所写的那样。</p>\n<h3 id=\"request\"><a href=\"#request\" class=\"headerlink\" title=\"request\"></a>request</h3><p>request 是一个简单的 Http client。这是它们的 <a href=\"https://github.com/request/request\">Git repo</a>。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 <code>fs.stat()</code> 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 <code>body</code> 内容。这些操作，都是通过 <code>request</code> 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 <code>request.Request(params)</code> 来实现的。</p>\n<pre><code class=\"javascript\">function request (uri, options, callback) &#123;\n  if (typeof uri === &#39;undefined&#39;) &#123;\n    throw new Error(&#39;undefined is not a valid uri or options object.&#39;)\n  &#125;\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === &#39;HEAD&#39; &amp;&amp; paramsHaveRequestBody(params)) &#123;\n    throw new Error(&#39;HTTP HEAD requests MUST NOT include a request body.&#39;)\n  &#125;\n\n  return new request.Request(params)\n&#125;\n</code></pre>\n<p>line 6 对参数进行初始化：</p>\n<pre><code class=\"javascript\">// organize params for patch, post, put, head, del\nfunction initParams (uri, options, callback) &#123;\n  if (typeof options === &#39;function&#39;) &#123;\n    callback = options\n  &#125;\n\n  var params = &#123;&#125;\n  if (typeof options === &#39;object&#39;) &#123;\n    extend(params, options, &#123;uri: uri&#125;)\n  &#125; else if (typeof uri === &#39;string&#39;) &#123;\n    extend(params, &#123;uri: uri&#125;)\n  &#125; else &#123;\n    extend(params, uri)\n  &#125;\n\n  params.callback = callback || params.callback\n  return params\n&#125;\n</code></pre>\n<p><code>request()</code> 函数返回的  <code>request.Request(params)</code>  如下：</p>\n<pre><code class=\"javascript\">function Request (options) &#123;\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) &#123;\n    self._har = new Har(self)\n    options = self._har.options(options)\n  &#125;\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) &#123;\n    self.explicitMethod = true\n  &#125;\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n&#125;\n</code></pre>\n<p>注意一下 line 17，<code>stream.Stream.call(self)</code>，在进入这个函数内部后，来到：</p>\n<pre><code class=\"javascript\">// legacy.js\nconst EE = require(&#39;events&#39;);\nconst util = require(&#39;util&#39;);\n\nfunction Stream() &#123;\n  EE.call(this);\n&#125;\n</code></pre>\n<p>因为 EE 是来自 events 导出的 EventEmitter，<code>EE.call(this)</code> 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：</p>\n<p><code>EventEmitter</code> &lt;- <code>stream.Stream</code> &lt;- <code>Request</code></p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这篇文章最初是想弄清楚 <code>fs</code> 和 <code>request</code> 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 <code>libuv</code> ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。</p>\n<p>[^1]: 原文判断文件存在用的是 <code>fs.exists()</code>，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。</p>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca\">Callbacks in Node.js: Why, When, How?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean\">Nodejs: What does <code>process.binding</code> mean?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/40977678\">深入出不来nodejs源码-从fs.stat看node架构</a></li>\n<li><a href=\"https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code\">Node.js_Design Patterns Second Edition Code</a></li>\n</ul>"},{"title":"棋盘上的「古墓丽影」","date":"2019-02-07T13:39:29.000Z","_content":"\n又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。\n\n![Lara Go 1](/images/Game/Lara Go 1.jpg)\n\n\n\n游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto's Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。\n\n以下内容涉及剧透。\n\n<!--more-->\n\n![Go-Trilogy](/images/Game/Go-Trilogy.png)\n\nLara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。\n\n最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。\n\n![Lara Go ](/images/Game/Lara Go .jpg)\n\n![Lara Go 3](/images/Game/Lara Go 3.jpg)\n\n说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。\n\n![Lara Go 2](/images/Game/Lara Go 2.jpg)\n\n这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。\n\n> Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new *Go* games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the *Go* games are each $4.99), saying that it’s “such a big barrier for mobile users.”\n\n在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。\n\n\n\n参考：\n\n- [Square Enix Montreal is no longer making Go games - The Verge](https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play)","source":"_posts/棋盘上的「古墓丽影」.md","raw":"---\ntitle: '棋盘上的「古墓丽影」'\ndate: \ntags: \n- 游戏\n- 故事\ncategories: \n---\n\n又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。\n\n![Lara Go 1](/images/Game/Lara Go 1.jpg)\n\n\n\n游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto's Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。\n\n以下内容涉及剧透。\n\n<!--more-->\n\n![Go-Trilogy](/images/Game/Go-Trilogy.png)\n\nLara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。\n\n最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。\n\n![Lara Go ](/images/Game/Lara Go .jpg)\n\n![Lara Go 3](/images/Game/Lara Go 3.jpg)\n\n说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。\n\n![Lara Go 2](/images/Game/Lara Go 2.jpg)\n\n这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。\n\n> Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new *Go* games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the *Go* games are each $4.99), saying that it’s “such a big barrier for mobile users.”\n\n在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。\n\n\n\n参考：\n\n- [Square Enix Montreal is no longer making Go games - The Verge](https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play)","slug":"棋盘上的「古墓丽影」","published":1,"updated":"2019-02-07T13:39:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c0042rg1v3igld588","content":"<p>又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。</p>\n<p>![Lara Go 1](/images/Game/Lara Go 1.jpg)</p>\n<p>游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。</p>\n<p>以下内容涉及剧透。</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/images/Game/Go-Trilogy.png\" alt=\"Go-Trilogy\"></p>\n<p>Lara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。</p>\n<p>最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。</p>\n<p>![Lara Go ](/images/Game/Lara Go .jpg)</p>\n<p>![Lara Go 3](/images/Game/Lara Go 3.jpg)</p>\n<p>说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。</p>\n<p>![Lara Go 2](/images/Game/Lara Go 2.jpg)</p>\n<p>这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。</p>\n<blockquote>\n<p>Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new <em>Go</em> games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the <em>Go</em> games are each $4.99), saying that it’s “such a big barrier for mobile users.”</p>\n</blockquote>\n<p>在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play\">Square Enix Montreal is no longer making Go games - The Verge</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。</p>\n<p>![Lara Go 1](/images/Game/Lara Go 1.jpg)</p>\n<p>游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。</p>\n<p>以下内容涉及剧透。</p>","more":"<p><img src=\"/images/Game/Go-Trilogy.png\" alt=\"Go-Trilogy\"></p>\n<p>Lara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。</p>\n<p>最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。</p>\n<p>![Lara Go ](/images/Game/Lara Go .jpg)</p>\n<p>![Lara Go 3](/images/Game/Lara Go 3.jpg)</p>\n<p>说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。</p>\n<p>![Lara Go 2](/images/Game/Lara Go 2.jpg)</p>\n<p>这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。</p>\n<blockquote>\n<p>Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new <em>Go</em> games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the <em>Go</em> games are each $4.99), saying that it’s “such a big barrier for mobile users.”</p>\n</blockquote>\n<p>在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play\">Square Enix Montreal is no longer making Go games - The Verge</a></li>\n</ul>"},{"title":"象棋 (Xiangqi/Chinese Chess) Board Validator | 4kyu","date":"2019-01-22T15:18:52.000Z","_content":"\n## Details\n\nYour friend recently has shown you some chess puzzles he found somewhere. It's not your ordinary chess: but the mysterious, distinct relative of chess, the legendary [象棋](http://www.wikiwand.com/en/Xiangqi), also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn't know anything in Chinese besides recognizing a few sigils (for example, he doesn't know what is `七步擒士` or `雙馬飲泉`), so it's probably likely that the \"puzzles\" he got is actually bogus, and the pieces are not placed properly. However, you don't want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.\n\n------\n\nYou will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:\n\n```\nExample (the starting Xiangqi board):\n\n車馬象士將士象馬車\n　　　｜Ｘ｜　　　\n　砲　＋－＋　砲　\n卒　卒　卒　卒　卒\n－－－－－－－－－\n－－－－－－－－－\n兵　兵　兵　兵　兵\n　炮　＋－＋　炮　\n　　　｜Ｘ｜　　　\n俥傌相仕帥仕相傌俥\n\nThe bottom and top half corresponds to red and black pieces, respectively.\nNote that red and black have different characters to distinguish the same piece of both sides.\n```\n\nYour function, `chessValidator`, should determine whether the pieces in argument `board` are placed legally. Unlike the chess you're familiar with, there are restrictions as to where the various chess pieces can be at:\n\n<!--more-->\n\n```\n俥/車, 傌/馬, 炮/砲 (2 max): no restrictions\n\n相/象 (2 max): they can only stay at 7 spots at their side of the board:\n－－Ｏ－－－Ｏ－－\n　　　　　　　　　\nＯ　　＋Ｏ＋　　Ｏ\n　　　｜Ｘ｜　　　\n　　Ｏ＋－＋Ｏ　　\nDon't let them go to the other side of the board: it's called 飛象過河, which is bad and you should feel bad about it.\n\n仕/士 (2 max): they can only stay at the center or the 4 corners of the 3x3 \"palace\" (九宮):\n－－－－－－－－－\n　　　　　　　　　\n　　　Ｏ－Ｏ　　　\n　　　｜Ｏ｜　　　\n　　　Ｏ－Ｏ　　　\n\n帥/將 (always 1): they can stay at every tile inside the palace, and nowhere else:\n－－－－－－－－－\n　　　　　　　　　\n　　　＋－＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　    // anywhere inside this 3x3 block is okay\nBecause they are your \"kings\" in Xiangqi, it is mandatory that one and only one exists.\n\nAdditionally, 帥/將 cannot face each other vertically without any pieces inbetween:\n　　　＋將＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　\n　　　　　　　　　\n－－－－－－－－－\n－－－－－－－－－\n　　　　　　　　　\n　　　＋帥＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　  // this is illegal because they're directly facing each other at the same column\n\n\n兵/卒 (5 max): at their starting positions (look at the above starting board), they can only move forward. However, once they reached the other side, they can move sideways as well as moving forward, at least until they reach the last row of the opponent side (no falling back, though!):\n　　　　　　　　　\n－－－－兵－－－－\n－－－－－－－－兵\n兵　　　　　　　　\nThe left and right 兵s can do nothing but moving forward. The center one, however, can move sideways since it has crossed the center line.\n\n(By the way, there is no such thing as pawn promotion in Xiangqi.)\n```\n\n------\n\nYou program should validate that:\n\n- Number of pieces of each side is within their respective limits\n- The pieces are placed in a legal position\n- Said configuration is legal (in respect to 帥/將 and 兵/卒 rules). Note that we don't care about whether it is practically reachable in-game, Xiangqi endgame puzzles can be pretty ridiculous at piece placements, and you might even start out being checked. We only care about whether it is legal. For example:\n\n```\n－－－－兵－兵－兵\n兵－－－－－－－－\n兵\n```\n\nwould be illegal because 兵 cannot move sideways before they go across the center row, which means the above configuration is fundamentally impossible.\n\nYou can assume that the board will always be well-formatted. Always assume red is at the bottom.\n\nSee example test cases for some examples.\n\n ## My Solution\n\n```javascript\nfunction chessValidator(board) {\n    let b = board.split('\\n').map(x => x.split(''));\n\n    // check the number of 俥/車, 傌/馬, 炮/砲\n    let chariot1 = chessIndex(b, '車');\n    let chariot2 = chessIndex(b, '俥');\n    let horse1 = chessIndex(b, '馬');\n    let horse2 = chessIndex(b, '傌');\n    let cannon1 = chessIndex(b, '砲');\n    let cannon2 = chessIndex(b, '炮');\n\n    let elep1 = chessIndex(b, '象');\n    let elep2 = chessIndex(b, '相');\n\n    let advisor1 = chessIndex(b, '士');\n    let advisor2 = chessIndex(b, '仕');\n\n    let two = [chariot1, chariot2, horse1, horse2,cannon1,cannon2, elep1, elep2, advisor1, advisor2];\n    for (var i = 0; i < two.length; i++) {\n        if (two[i].length > 2) {\n            console.log('over two pieces for the same kind')\n            return false;\n        }\n    }\n\n    // 相/象\n    let elep1T = [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];\n    let elep2T = [[9,2], [9,6], [7,0], [7,4], [7,8], [5,2], [5,6]];\n\n\n    for (var i = 0; i < elep1.length; i++) {\n        if(!isArrayInArray(elep1T,elep1[i])) {\n            console.log('象 at the wrong position')\n            return false;\n        }\n    }\n    for (var i = 0; i < elep2.length; i++) {\n        if(!isArrayInArray(elep2T,elep2[i])) {\n            console.log('相 at the wrong position')\n            return false;\n        }\n    }\n\n    // 仕/士\n    let advisor1T = [[0,3], [0,5], [1,4], [2,3], [2,5]]\n    let advisor2T = [[9,3], [9,5], [8,4], [7,3], [7,5]]\n\n\n    for (var i = 0; i < advisor1.length; i++) {\n        if(!isArrayInArray(advisor1T,advisor1[i])) {\n            console.log('士 at the wrong position')\n            return false;\n        }\n    }\n    for (var i = 0; i < advisor2.length; i++) {\n        if(!isArrayInArray(advisor2T,advisor2[i])) {\n            console.log('仕 at the wrong position')\n            return false;\n        }\n    }\n\n    // 兵/卒\n    let soldier1 = chessIndex(b, '卒');\n    let soldier2 = chessIndex(b, '兵');\n    for (var i = 0; i < soldier1.length; i++) {\n        if (soldier1[i][0] < 3) {\n            console.log('卒 at the wrong position')\n            return false;\n        } else if(soldier1[i][0] < 5 && soldier1[i][1] % 2 === 1 ) {\n            console.log('卒 at the wrong position')\n            return false;\n        }\n    }\n\n    for (var i = 0; i < soldier2.length; i++) {\n        if (soldier2[i][0] > 6) {\n            console.log('兵 at the wrong position')\n            return false;\n        } else if(soldier2[i][0] > 4 && soldier2[i][1] % 2 === 1 ) {\n            console.log('兵 at the wrong position')\n            return false;\n        }\n    }\n\n    for (var i = 0; i < 9; i++) {\n        if(b[3][i] === '卒' && b[4][i] === '卒') {\n            console.log('卒 at the wrong position')\n            return false;\n        }\n        if(b[5][i] === '兵' && b[6][i] === '兵') {\n            console.log('兵 at the wrong position')\n            return false;\n        }\n    }\n\n    // 帥/將\n    let general1 = chessIndex(b, '將');\n    let general2 = chessIndex(b, '帥');\n    if (general1.length !== 1 || general2.length !== 1) {\n        console.log( '帥/將 lost ')\n        return false;\n    }\n    if (general1[0][0] > 2 ||\n        general1[0][1] < 3 ||\n        general1[0][1] > 5 ||\n        general2[0][0] < 7 ||\n        general2[0][1] < 3 ||\n        general2[0][1] > 5) {\n        console.log( '帥/將 at the wrong position ')\n        return false;\n    }\n\n    if(general1[0][1] === general2[0][1]) {\n        let k = general1[0][1]\n        for (var i = general1[0][0]+1; i < general2[0][0]; i++) {\n            if (b[i][k] !== 'Ｘ' &&\n                b[i][k] !== '－' &&\n                b[i][k] !== '　' &&\n                b[i][k] !== '｜' &&\n                b[i][k] !== '＋') {\n                break;\n            }\n        }\n        if(i === general2[0][0]) {\n            console.log('帥/將 are directly facing each other at the same column')\n            return false;\n        }\n    }\n\n    //if a flipped starting board\n\n    return true;\n}\n\nfunction chessIndex(b, s) {\n    let res = [];\n    for (var i = 0; i < b.length; i++) {\n        let k = -1;\n        while((k = b[i].indexOf(s,k+1)) !== -1) {\n            res.push([i,k]);\n        }\n    }\n    return res;\n}\n\nfunction isArrayInArray(arr, item){\n  var item_as_string = JSON.stringify(item);\n\n  var contains = arr.some(function(ele){\n    return JSON.stringify(ele) === item_as_string;\n  });\n  return contains;\n}\n```\n\n主要讲一下重复用到的两个 function 吧，一个是 `chessIndex()` 来得到棋盘上某个棋子的坐标，输出的是一个二维 array。另一个 `isArrayInArray(arr, item)` ，arr 是一个二维 array，item 是一个 array，检测 item 是否再 arr 里面。\n\n`chessIndex()` 难点在与处理一行内重复的元素。比如:\n\n```javascript\n>a = a.split(\"\")\n[ '　', '砲', '　', '＋', '－', '＋', '　', '砲', '　' ]\n>a.indexOf('砲')\n1\n>a.indexOf('砲',2)\n7\n>\n```\n\n这里 array 中含有两个 `'砲'`。要获取第二个 `'砲'`，就要给 `indexOf()` 加上第二个参数。\n\n`isArrayInArray()` 方法中用到 `JSON.stringfy`：\n\n```javascript\n>a = [[1,2],[2,3]]\n[ [ 1, 2 ], [ 2, 3 ] ]\n>JSON.stringify(a)\n'[[1,2],[2,3]]'\n>obj = { \"name\":\"John\", \"age\":30, \"city\":\"New York\"};\n{ name: 'John', age: 30, city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}'\n>obj = { \"name\":\"John\", \"today\":new Date(), \"city\":\"New York\"};\n{ name: 'John',\n  today: 2018-06-10T03:44:24.742Z,\n  city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"today\":\"2018-06-10T03:44:24.742Z\",\"city\":\"New York\"}'\n> obj = { \"name\":\"John\", \"age\":function () {return 30;}, \"city\":\"New York\"};\n{ name: 'John', age: [Function: age], city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"city\":\"New York\"}'\n>obj.age = obj.age.toString()\n'function () {return 30;}'\n>obj \n{ name: 'John',\n  age: 'function () {return 30;}',\n  city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"age\":\"function () {return 30;}\",\"city\":\"New York\"}'\n>\n```\n\n上面的例子，后面一大部分摘自 [JSON.stringify()](https://www.w3schools.com/js/js_json_stringify.asp)，可以看到，可以把  array，object 等直接转化成 string。最后两个例子是讲，如果 object 中包含函数，则会被忽略。\n\n用到了 `some()` 方法，[MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) 给出的解释：\n\n> The `some()` method tests whether at least one element in the array passes the test implemented by the provided function.\n\n上述两个函数方法的构造是关键。在这两个函数的基础上，对棋盘的棋子进行依此按照相应的的规则进行检测，剩下的只是一些比较繁琐的工作，和细节上的修饰。\n\n","source":"_posts/象棋 (XiangqiChinese Chess) Board Validator | 4kyu.md","raw":"---\ntitle: '象棋 (Xiangqi/Chinese Chess) Board Validator | 4kyu'\ndate: \ntags:\n- Algorithm\n- codewars\n- JavaScript\ncategories: \n- Coding\n---\n\n## Details\n\nYour friend recently has shown you some chess puzzles he found somewhere. It's not your ordinary chess: but the mysterious, distinct relative of chess, the legendary [象棋](http://www.wikiwand.com/en/Xiangqi), also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn't know anything in Chinese besides recognizing a few sigils (for example, he doesn't know what is `七步擒士` or `雙馬飲泉`), so it's probably likely that the \"puzzles\" he got is actually bogus, and the pieces are not placed properly. However, you don't want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.\n\n------\n\nYou will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:\n\n```\nExample (the starting Xiangqi board):\n\n車馬象士將士象馬車\n　　　｜Ｘ｜　　　\n　砲　＋－＋　砲　\n卒　卒　卒　卒　卒\n－－－－－－－－－\n－－－－－－－－－\n兵　兵　兵　兵　兵\n　炮　＋－＋　炮　\n　　　｜Ｘ｜　　　\n俥傌相仕帥仕相傌俥\n\nThe bottom and top half corresponds to red and black pieces, respectively.\nNote that red and black have different characters to distinguish the same piece of both sides.\n```\n\nYour function, `chessValidator`, should determine whether the pieces in argument `board` are placed legally. Unlike the chess you're familiar with, there are restrictions as to where the various chess pieces can be at:\n\n<!--more-->\n\n```\n俥/車, 傌/馬, 炮/砲 (2 max): no restrictions\n\n相/象 (2 max): they can only stay at 7 spots at their side of the board:\n－－Ｏ－－－Ｏ－－\n　　　　　　　　　\nＯ　　＋Ｏ＋　　Ｏ\n　　　｜Ｘ｜　　　\n　　Ｏ＋－＋Ｏ　　\nDon't let them go to the other side of the board: it's called 飛象過河, which is bad and you should feel bad about it.\n\n仕/士 (2 max): they can only stay at the center or the 4 corners of the 3x3 \"palace\" (九宮):\n－－－－－－－－－\n　　　　　　　　　\n　　　Ｏ－Ｏ　　　\n　　　｜Ｏ｜　　　\n　　　Ｏ－Ｏ　　　\n\n帥/將 (always 1): they can stay at every tile inside the palace, and nowhere else:\n－－－－－－－－－\n　　　　　　　　　\n　　　＋－＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　    // anywhere inside this 3x3 block is okay\nBecause they are your \"kings\" in Xiangqi, it is mandatory that one and only one exists.\n\nAdditionally, 帥/將 cannot face each other vertically without any pieces inbetween:\n　　　＋將＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　\n　　　　　　　　　\n－－－－－－－－－\n－－－－－－－－－\n　　　　　　　　　\n　　　＋帥＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　  // this is illegal because they're directly facing each other at the same column\n\n\n兵/卒 (5 max): at their starting positions (look at the above starting board), they can only move forward. However, once they reached the other side, they can move sideways as well as moving forward, at least until they reach the last row of the opponent side (no falling back, though!):\n　　　　　　　　　\n－－－－兵－－－－\n－－－－－－－－兵\n兵　　　　　　　　\nThe left and right 兵s can do nothing but moving forward. The center one, however, can move sideways since it has crossed the center line.\n\n(By the way, there is no such thing as pawn promotion in Xiangqi.)\n```\n\n------\n\nYou program should validate that:\n\n- Number of pieces of each side is within their respective limits\n- The pieces are placed in a legal position\n- Said configuration is legal (in respect to 帥/將 and 兵/卒 rules). Note that we don't care about whether it is practically reachable in-game, Xiangqi endgame puzzles can be pretty ridiculous at piece placements, and you might even start out being checked. We only care about whether it is legal. For example:\n\n```\n－－－－兵－兵－兵\n兵－－－－－－－－\n兵\n```\n\nwould be illegal because 兵 cannot move sideways before they go across the center row, which means the above configuration is fundamentally impossible.\n\nYou can assume that the board will always be well-formatted. Always assume red is at the bottom.\n\nSee example test cases for some examples.\n\n ## My Solution\n\n```javascript\nfunction chessValidator(board) {\n    let b = board.split('\\n').map(x => x.split(''));\n\n    // check the number of 俥/車, 傌/馬, 炮/砲\n    let chariot1 = chessIndex(b, '車');\n    let chariot2 = chessIndex(b, '俥');\n    let horse1 = chessIndex(b, '馬');\n    let horse2 = chessIndex(b, '傌');\n    let cannon1 = chessIndex(b, '砲');\n    let cannon2 = chessIndex(b, '炮');\n\n    let elep1 = chessIndex(b, '象');\n    let elep2 = chessIndex(b, '相');\n\n    let advisor1 = chessIndex(b, '士');\n    let advisor2 = chessIndex(b, '仕');\n\n    let two = [chariot1, chariot2, horse1, horse2,cannon1,cannon2, elep1, elep2, advisor1, advisor2];\n    for (var i = 0; i < two.length; i++) {\n        if (two[i].length > 2) {\n            console.log('over two pieces for the same kind')\n            return false;\n        }\n    }\n\n    // 相/象\n    let elep1T = [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];\n    let elep2T = [[9,2], [9,6], [7,0], [7,4], [7,8], [5,2], [5,6]];\n\n\n    for (var i = 0; i < elep1.length; i++) {\n        if(!isArrayInArray(elep1T,elep1[i])) {\n            console.log('象 at the wrong position')\n            return false;\n        }\n    }\n    for (var i = 0; i < elep2.length; i++) {\n        if(!isArrayInArray(elep2T,elep2[i])) {\n            console.log('相 at the wrong position')\n            return false;\n        }\n    }\n\n    // 仕/士\n    let advisor1T = [[0,3], [0,5], [1,4], [2,3], [2,5]]\n    let advisor2T = [[9,3], [9,5], [8,4], [7,3], [7,5]]\n\n\n    for (var i = 0; i < advisor1.length; i++) {\n        if(!isArrayInArray(advisor1T,advisor1[i])) {\n            console.log('士 at the wrong position')\n            return false;\n        }\n    }\n    for (var i = 0; i < advisor2.length; i++) {\n        if(!isArrayInArray(advisor2T,advisor2[i])) {\n            console.log('仕 at the wrong position')\n            return false;\n        }\n    }\n\n    // 兵/卒\n    let soldier1 = chessIndex(b, '卒');\n    let soldier2 = chessIndex(b, '兵');\n    for (var i = 0; i < soldier1.length; i++) {\n        if (soldier1[i][0] < 3) {\n            console.log('卒 at the wrong position')\n            return false;\n        } else if(soldier1[i][0] < 5 && soldier1[i][1] % 2 === 1 ) {\n            console.log('卒 at the wrong position')\n            return false;\n        }\n    }\n\n    for (var i = 0; i < soldier2.length; i++) {\n        if (soldier2[i][0] > 6) {\n            console.log('兵 at the wrong position')\n            return false;\n        } else if(soldier2[i][0] > 4 && soldier2[i][1] % 2 === 1 ) {\n            console.log('兵 at the wrong position')\n            return false;\n        }\n    }\n\n    for (var i = 0; i < 9; i++) {\n        if(b[3][i] === '卒' && b[4][i] === '卒') {\n            console.log('卒 at the wrong position')\n            return false;\n        }\n        if(b[5][i] === '兵' && b[6][i] === '兵') {\n            console.log('兵 at the wrong position')\n            return false;\n        }\n    }\n\n    // 帥/將\n    let general1 = chessIndex(b, '將');\n    let general2 = chessIndex(b, '帥');\n    if (general1.length !== 1 || general2.length !== 1) {\n        console.log( '帥/將 lost ')\n        return false;\n    }\n    if (general1[0][0] > 2 ||\n        general1[0][1] < 3 ||\n        general1[0][1] > 5 ||\n        general2[0][0] < 7 ||\n        general2[0][1] < 3 ||\n        general2[0][1] > 5) {\n        console.log( '帥/將 at the wrong position ')\n        return false;\n    }\n\n    if(general1[0][1] === general2[0][1]) {\n        let k = general1[0][1]\n        for (var i = general1[0][0]+1; i < general2[0][0]; i++) {\n            if (b[i][k] !== 'Ｘ' &&\n                b[i][k] !== '－' &&\n                b[i][k] !== '　' &&\n                b[i][k] !== '｜' &&\n                b[i][k] !== '＋') {\n                break;\n            }\n        }\n        if(i === general2[0][0]) {\n            console.log('帥/將 are directly facing each other at the same column')\n            return false;\n        }\n    }\n\n    //if a flipped starting board\n\n    return true;\n}\n\nfunction chessIndex(b, s) {\n    let res = [];\n    for (var i = 0; i < b.length; i++) {\n        let k = -1;\n        while((k = b[i].indexOf(s,k+1)) !== -1) {\n            res.push([i,k]);\n        }\n    }\n    return res;\n}\n\nfunction isArrayInArray(arr, item){\n  var item_as_string = JSON.stringify(item);\n\n  var contains = arr.some(function(ele){\n    return JSON.stringify(ele) === item_as_string;\n  });\n  return contains;\n}\n```\n\n主要讲一下重复用到的两个 function 吧，一个是 `chessIndex()` 来得到棋盘上某个棋子的坐标，输出的是一个二维 array。另一个 `isArrayInArray(arr, item)` ，arr 是一个二维 array，item 是一个 array，检测 item 是否再 arr 里面。\n\n`chessIndex()` 难点在与处理一行内重复的元素。比如:\n\n```javascript\n>a = a.split(\"\")\n[ '　', '砲', '　', '＋', '－', '＋', '　', '砲', '　' ]\n>a.indexOf('砲')\n1\n>a.indexOf('砲',2)\n7\n>\n```\n\n这里 array 中含有两个 `'砲'`。要获取第二个 `'砲'`，就要给 `indexOf()` 加上第二个参数。\n\n`isArrayInArray()` 方法中用到 `JSON.stringfy`：\n\n```javascript\n>a = [[1,2],[2,3]]\n[ [ 1, 2 ], [ 2, 3 ] ]\n>JSON.stringify(a)\n'[[1,2],[2,3]]'\n>obj = { \"name\":\"John\", \"age\":30, \"city\":\"New York\"};\n{ name: 'John', age: 30, city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"age\":30,\"city\":\"New York\"}'\n>obj = { \"name\":\"John\", \"today\":new Date(), \"city\":\"New York\"};\n{ name: 'John',\n  today: 2018-06-10T03:44:24.742Z,\n  city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"today\":\"2018-06-10T03:44:24.742Z\",\"city\":\"New York\"}'\n> obj = { \"name\":\"John\", \"age\":function () {return 30;}, \"city\":\"New York\"};\n{ name: 'John', age: [Function: age], city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"city\":\"New York\"}'\n>obj.age = obj.age.toString()\n'function () {return 30;}'\n>obj \n{ name: 'John',\n  age: 'function () {return 30;}',\n  city: 'New York' }\n>JSON.stringify(obj)\n'{\"name\":\"John\",\"age\":\"function () {return 30;}\",\"city\":\"New York\"}'\n>\n```\n\n上面的例子，后面一大部分摘自 [JSON.stringify()](https://www.w3schools.com/js/js_json_stringify.asp)，可以看到，可以把  array，object 等直接转化成 string。最后两个例子是讲，如果 object 中包含函数，则会被忽略。\n\n用到了 `some()` 方法，[MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) 给出的解释：\n\n> The `some()` method tests whether at least one element in the array passes the test implemented by the provided function.\n\n上述两个函数方法的构造是关键。在这两个函数的基础上，对棋盘的棋子进行依此按照相应的的规则进行检测，剩下的只是一些比较繁琐的工作，和细节上的修饰。\n\n","slug":"象棋 (XiangqiChinese Chess) Board Validator | 4kyu","published":1,"updated":"2019-01-22T15:18:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c0045rg1vclzrhli1","content":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Your friend recently has shown you some chess puzzles he found somewhere. It’s not your ordinary chess: but the mysterious, distinct relative of chess, the legendary <a href=\"http://www.wikiwand.com/en/Xiangqi\">象棋</a>, also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn’t know anything in Chinese besides recognizing a few sigils (for example, he doesn’t know what is <code>七步擒士</code> or <code>雙馬飲泉</code>), so it’s probably likely that the “puzzles” he got is actually bogus, and the pieces are not placed properly. However, you don’t want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.</p>\n<hr>\n<p>You will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:</p>\n<pre><code>Example (the starting Xiangqi board):\n\n車馬象士將士象馬車\n　　　｜Ｘ｜　　　\n　砲　＋－＋　砲　\n卒　卒　卒　卒　卒\n－－－－－－－－－\n－－－－－－－－－\n兵　兵　兵　兵　兵\n　炮　＋－＋　炮　\n　　　｜Ｘ｜　　　\n俥傌相仕帥仕相傌俥\n\nThe bottom and top half corresponds to red and black pieces, respectively.\nNote that red and black have different characters to distinguish the same piece of both sides.\n</code></pre>\n<p>Your function, <code>chessValidator</code>, should determine whether the pieces in argument <code>board</code> are placed legally. Unlike the chess you’re familiar with, there are restrictions as to where the various chess pieces can be at:</p>\n<span id=\"more\"></span>\n\n<pre><code>俥/車, 傌/馬, 炮/砲 (2 max): no restrictions\n\n相/象 (2 max): they can only stay at 7 spots at their side of the board:\n－－Ｏ－－－Ｏ－－\n　　　　　　　　　\nＯ　　＋Ｏ＋　　Ｏ\n　　　｜Ｘ｜　　　\n　　Ｏ＋－＋Ｏ　　\nDon&#39;t let them go to the other side of the board: it&#39;s called 飛象過河, which is bad and you should feel bad about it.\n\n仕/士 (2 max): they can only stay at the center or the 4 corners of the 3x3 &quot;palace&quot; (九宮):\n－－－－－－－－－\n　　　　　　　　　\n　　　Ｏ－Ｏ　　　\n　　　｜Ｏ｜　　　\n　　　Ｏ－Ｏ　　　\n\n帥/將 (always 1): they can stay at every tile inside the palace, and nowhere else:\n－－－－－－－－－\n　　　　　　　　　\n　　　＋－＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　    // anywhere inside this 3x3 block is okay\nBecause they are your &quot;kings&quot; in Xiangqi, it is mandatory that one and only one exists.\n\nAdditionally, 帥/將 cannot face each other vertically without any pieces inbetween:\n　　　＋將＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　\n　　　　　　　　　\n－－－－－－－－－\n－－－－－－－－－\n　　　　　　　　　\n　　　＋帥＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　  // this is illegal because they&#39;re directly facing each other at the same column\n\n\n兵/卒 (5 max): at their starting positions (look at the above starting board), they can only move forward. However, once they reached the other side, they can move sideways as well as moving forward, at least until they reach the last row of the opponent side (no falling back, though!):\n　　　　　　　　　\n－－－－兵－－－－\n－－－－－－－－兵\n兵　　　　　　　　\nThe left and right 兵s can do nothing but moving forward. The center one, however, can move sideways since it has crossed the center line.\n\n(By the way, there is no such thing as pawn promotion in Xiangqi.)\n</code></pre>\n<hr>\n<p>You program should validate that:</p>\n<ul>\n<li>Number of pieces of each side is within their respective limits</li>\n<li>The pieces are placed in a legal position</li>\n<li>Said configuration is legal (in respect to 帥/將 and 兵/卒 rules). Note that we don’t care about whether it is practically reachable in-game, Xiangqi endgame puzzles can be pretty ridiculous at piece placements, and you might even start out being checked. We only care about whether it is legal. For example:</li>\n</ul>\n<pre><code>－－－－兵－兵－兵\n兵－－－－－－－－\n兵\n</code></pre>\n<p>would be illegal because 兵 cannot move sideways before they go across the center row, which means the above configuration is fundamentally impossible.</p>\n<p>You can assume that the board will always be well-formatted. Always assume red is at the bottom.</p>\n<p>See example test cases for some examples.</p>\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function chessValidator(board) &#123;\n    let b = board.split(&#39;\\n&#39;).map(x =&gt; x.split(&#39;&#39;));\n\n    // check the number of 俥/車, 傌/馬, 炮/砲\n    let chariot1 = chessIndex(b, &#39;車&#39;);\n    let chariot2 = chessIndex(b, &#39;俥&#39;);\n    let horse1 = chessIndex(b, &#39;馬&#39;);\n    let horse2 = chessIndex(b, &#39;傌&#39;);\n    let cannon1 = chessIndex(b, &#39;砲&#39;);\n    let cannon2 = chessIndex(b, &#39;炮&#39;);\n\n    let elep1 = chessIndex(b, &#39;象&#39;);\n    let elep2 = chessIndex(b, &#39;相&#39;);\n\n    let advisor1 = chessIndex(b, &#39;士&#39;);\n    let advisor2 = chessIndex(b, &#39;仕&#39;);\n\n    let two = [chariot1, chariot2, horse1, horse2,cannon1,cannon2, elep1, elep2, advisor1, advisor2];\n    for (var i = 0; i &lt; two.length; i++) &#123;\n        if (two[i].length &gt; 2) &#123;\n            console.log(&#39;over two pieces for the same kind&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 相/象\n    let elep1T = [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];\n    let elep2T = [[9,2], [9,6], [7,0], [7,4], [7,8], [5,2], [5,6]];\n\n\n    for (var i = 0; i &lt; elep1.length; i++) &#123;\n        if(!isArrayInArray(elep1T,elep1[i])) &#123;\n            console.log(&#39;象 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n    for (var i = 0; i &lt; elep2.length; i++) &#123;\n        if(!isArrayInArray(elep2T,elep2[i])) &#123;\n            console.log(&#39;相 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 仕/士\n    let advisor1T = [[0,3], [0,5], [1,4], [2,3], [2,5]]\n    let advisor2T = [[9,3], [9,5], [8,4], [7,3], [7,5]]\n\n\n    for (var i = 0; i &lt; advisor1.length; i++) &#123;\n        if(!isArrayInArray(advisor1T,advisor1[i])) &#123;\n            console.log(&#39;士 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n    for (var i = 0; i &lt; advisor2.length; i++) &#123;\n        if(!isArrayInArray(advisor2T,advisor2[i])) &#123;\n            console.log(&#39;仕 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 兵/卒\n    let soldier1 = chessIndex(b, &#39;卒&#39;);\n    let soldier2 = chessIndex(b, &#39;兵&#39;);\n    for (var i = 0; i &lt; soldier1.length; i++) &#123;\n        if (soldier1[i][0] &lt; 3) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125; else if(soldier1[i][0] &lt; 5 &amp;&amp; soldier1[i][1] % 2 === 1 ) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    for (var i = 0; i &lt; soldier2.length; i++) &#123;\n        if (soldier2[i][0] &gt; 6) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125; else if(soldier2[i][0] &gt; 4 &amp;&amp; soldier2[i][1] % 2 === 1 ) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    for (var i = 0; i &lt; 9; i++) &#123;\n        if(b[3][i] === &#39;卒&#39; &amp;&amp; b[4][i] === &#39;卒&#39;) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125;\n        if(b[5][i] === &#39;兵&#39; &amp;&amp; b[6][i] === &#39;兵&#39;) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 帥/將\n    let general1 = chessIndex(b, &#39;將&#39;);\n    let general2 = chessIndex(b, &#39;帥&#39;);\n    if (general1.length !== 1 || general2.length !== 1) &#123;\n        console.log( &#39;帥/將 lost &#39;)\n        return false;\n    &#125;\n    if (general1[0][0] &gt; 2 ||\n        general1[0][1] &lt; 3 ||\n        general1[0][1] &gt; 5 ||\n        general2[0][0] &lt; 7 ||\n        general2[0][1] &lt; 3 ||\n        general2[0][1] &gt; 5) &#123;\n        console.log( &#39;帥/將 at the wrong position &#39;)\n        return false;\n    &#125;\n\n    if(general1[0][1] === general2[0][1]) &#123;\n        let k = general1[0][1]\n        for (var i = general1[0][0]+1; i &lt; general2[0][0]; i++) &#123;\n            if (b[i][k] !== &#39;Ｘ&#39; &amp;&amp;\n                b[i][k] !== &#39;－&#39; &amp;&amp;\n                b[i][k] !== &#39;　&#39; &amp;&amp;\n                b[i][k] !== &#39;｜&#39; &amp;&amp;\n                b[i][k] !== &#39;＋&#39;) &#123;\n                break;\n            &#125;\n        &#125;\n        if(i === general2[0][0]) &#123;\n            console.log(&#39;帥/將 are directly facing each other at the same column&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    //if a flipped starting board\n\n    return true;\n&#125;\n\nfunction chessIndex(b, s) &#123;\n    let res = [];\n    for (var i = 0; i &lt; b.length; i++) &#123;\n        let k = -1;\n        while((k = b[i].indexOf(s,k+1)) !== -1) &#123;\n            res.push([i,k]);\n        &#125;\n    &#125;\n    return res;\n&#125;\n\nfunction isArrayInArray(arr, item)&#123;\n  var item_as_string = JSON.stringify(item);\n\n  var contains = arr.some(function(ele)&#123;\n    return JSON.stringify(ele) === item_as_string;\n  &#125;);\n  return contains;\n&#125;\n</code></pre>\n<p>主要讲一下重复用到的两个 function 吧，一个是 <code>chessIndex()</code> 来得到棋盘上某个棋子的坐标，输出的是一个二维 array。另一个 <code>isArrayInArray(arr, item)</code> ，arr 是一个二维 array，item 是一个 array，检测 item 是否再 arr 里面。</p>\n<p><code>chessIndex()</code> 难点在与处理一行内重复的元素。比如:</p>\n<pre><code class=\"javascript\">&gt;a = a.split(&quot;&quot;)\n[ &#39;　&#39;, &#39;砲&#39;, &#39;　&#39;, &#39;＋&#39;, &#39;－&#39;, &#39;＋&#39;, &#39;　&#39;, &#39;砲&#39;, &#39;　&#39; ]\n&gt;a.indexOf(&#39;砲&#39;)\n1\n&gt;a.indexOf(&#39;砲&#39;,2)\n7\n&gt;\n</code></pre>\n<p>这里 array 中含有两个 <code>&#39;砲&#39;</code>。要获取第二个 <code>&#39;砲&#39;</code>，就要给 <code>indexOf()</code> 加上第二个参数。</p>\n<p><code>isArrayInArray()</code> 方法中用到 <code>JSON.stringfy</code>：</p>\n<pre><code class=\"javascript\">&gt;a = [[1,2],[2,3]]\n[ [ 1, 2 ], [ 2, 3 ] ]\n&gt;JSON.stringify(a)\n&#39;[[1,2],[2,3]]&#39;\n&gt;obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:30, &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;, age: 30, city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;today&quot;:new Date(), &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;,\n  today: 2018-06-10T03:44:24.742Z,\n  city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;today&quot;:&quot;2018-06-10T03:44:24.742Z&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt; obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:function () &#123;return 30;&#125;, &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;, age: [Function: age], city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;obj.age = obj.age.toString()\n&#39;function () &#123;return 30;&#125;&#39;\n&gt;obj \n&#123; name: &#39;John&#39;,\n  age: &#39;function () &#123;return 30;&#125;&#39;,\n  city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:&quot;function () &#123;return 30;&#125;&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;\n</code></pre>\n<p>上面的例子，后面一大部分摘自 <a href=\"https://www.w3schools.com/js/js_json_stringify.asp\">JSON.stringify()</a>，可以看到，可以把  array，object 等直接转化成 string。最后两个例子是讲，如果 object 中包含函数，则会被忽略。</p>\n<p>用到了 <code>some()</code> 方法，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\">MDN docs</a> 给出的解释：</p>\n<blockquote>\n<p>The <code>some()</code> method tests whether at least one element in the array passes the test implemented by the provided function.</p>\n</blockquote>\n<p>上述两个函数方法的构造是关键。在这两个函数的基础上，对棋盘的棋子进行依此按照相应的的规则进行检测，剩下的只是一些比较繁琐的工作，和细节上的修饰。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Details\"><a href=\"#Details\" class=\"headerlink\" title=\"Details\"></a>Details</h2><p>Your friend recently has shown you some chess puzzles he found somewhere. It’s not your ordinary chess: but the mysterious, distinct relative of chess, the legendary <a href=\"http://www.wikiwand.com/en/Xiangqi\">象棋</a>, also known as Xiangqi/Chinese chess! As a Chinese, you know that your friend doesn’t know anything in Chinese besides recognizing a few sigils (for example, he doesn’t know what is <code>七步擒士</code> or <code>雙馬飲泉</code>), so it’s probably likely that the “puzzles” he got is actually bogus, and the pieces are not placed properly. However, you don’t want to actually teach him Xiangqi either (yet), so the best tactic you could come up with is to write a validator program and let your friend use it instead of using you.</p>\n<hr>\n<p>You will be given an ASCII board. Xiangqi board is 9 tiles wide and 10 tiles high, with the pieces placed as follows:</p>\n<pre><code>Example (the starting Xiangqi board):\n\n車馬象士將士象馬車\n　　　｜Ｘ｜　　　\n　砲　＋－＋　砲　\n卒　卒　卒　卒　卒\n－－－－－－－－－\n－－－－－－－－－\n兵　兵　兵　兵　兵\n　炮　＋－＋　炮　\n　　　｜Ｘ｜　　　\n俥傌相仕帥仕相傌俥\n\nThe bottom and top half corresponds to red and black pieces, respectively.\nNote that red and black have different characters to distinguish the same piece of both sides.\n</code></pre>\n<p>Your function, <code>chessValidator</code>, should determine whether the pieces in argument <code>board</code> are placed legally. Unlike the chess you’re familiar with, there are restrictions as to where the various chess pieces can be at:</p>","more":"<pre><code>俥/車, 傌/馬, 炮/砲 (2 max): no restrictions\n\n相/象 (2 max): they can only stay at 7 spots at their side of the board:\n－－Ｏ－－－Ｏ－－\n　　　　　　　　　\nＯ　　＋Ｏ＋　　Ｏ\n　　　｜Ｘ｜　　　\n　　Ｏ＋－＋Ｏ　　\nDon&#39;t let them go to the other side of the board: it&#39;s called 飛象過河, which is bad and you should feel bad about it.\n\n仕/士 (2 max): they can only stay at the center or the 4 corners of the 3x3 &quot;palace&quot; (九宮):\n－－－－－－－－－\n　　　　　　　　　\n　　　Ｏ－Ｏ　　　\n　　　｜Ｏ｜　　　\n　　　Ｏ－Ｏ　　　\n\n帥/將 (always 1): they can stay at every tile inside the palace, and nowhere else:\n－－－－－－－－－\n　　　　　　　　　\n　　　＋－＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　    // anywhere inside this 3x3 block is okay\nBecause they are your &quot;kings&quot; in Xiangqi, it is mandatory that one and only one exists.\n\nAdditionally, 帥/將 cannot face each other vertically without any pieces inbetween:\n　　　＋將＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　\n　　　　　　　　　\n－－－－－－－－－\n－－－－－－－－－\n　　　　　　　　　\n　　　＋帥＋　　　\n　　　｜Ｘ｜　　　\n　　　＋－＋　　　  // this is illegal because they&#39;re directly facing each other at the same column\n\n\n兵/卒 (5 max): at their starting positions (look at the above starting board), they can only move forward. However, once they reached the other side, they can move sideways as well as moving forward, at least until they reach the last row of the opponent side (no falling back, though!):\n　　　　　　　　　\n－－－－兵－－－－\n－－－－－－－－兵\n兵　　　　　　　　\nThe left and right 兵s can do nothing but moving forward. The center one, however, can move sideways since it has crossed the center line.\n\n(By the way, there is no such thing as pawn promotion in Xiangqi.)\n</code></pre>\n<hr>\n<p>You program should validate that:</p>\n<ul>\n<li>Number of pieces of each side is within their respective limits</li>\n<li>The pieces are placed in a legal position</li>\n<li>Said configuration is legal (in respect to 帥/將 and 兵/卒 rules). Note that we don’t care about whether it is practically reachable in-game, Xiangqi endgame puzzles can be pretty ridiculous at piece placements, and you might even start out being checked. We only care about whether it is legal. For example:</li>\n</ul>\n<pre><code>－－－－兵－兵－兵\n兵－－－－－－－－\n兵\n</code></pre>\n<p>would be illegal because 兵 cannot move sideways before they go across the center row, which means the above configuration is fundamentally impossible.</p>\n<p>You can assume that the board will always be well-formatted. Always assume red is at the bottom.</p>\n<p>See example test cases for some examples.</p>\n<h2 id=\"My-Solution\"><a href=\"#My-Solution\" class=\"headerlink\" title=\"My Solution\"></a>My Solution</h2><pre><code class=\"javascript\">function chessValidator(board) &#123;\n    let b = board.split(&#39;\\n&#39;).map(x =&gt; x.split(&#39;&#39;));\n\n    // check the number of 俥/車, 傌/馬, 炮/砲\n    let chariot1 = chessIndex(b, &#39;車&#39;);\n    let chariot2 = chessIndex(b, &#39;俥&#39;);\n    let horse1 = chessIndex(b, &#39;馬&#39;);\n    let horse2 = chessIndex(b, &#39;傌&#39;);\n    let cannon1 = chessIndex(b, &#39;砲&#39;);\n    let cannon2 = chessIndex(b, &#39;炮&#39;);\n\n    let elep1 = chessIndex(b, &#39;象&#39;);\n    let elep2 = chessIndex(b, &#39;相&#39;);\n\n    let advisor1 = chessIndex(b, &#39;士&#39;);\n    let advisor2 = chessIndex(b, &#39;仕&#39;);\n\n    let two = [chariot1, chariot2, horse1, horse2,cannon1,cannon2, elep1, elep2, advisor1, advisor2];\n    for (var i = 0; i &lt; two.length; i++) &#123;\n        if (two[i].length &gt; 2) &#123;\n            console.log(&#39;over two pieces for the same kind&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 相/象\n    let elep1T = [[0,2], [0,6], [2,0], [2,4], [2,8], [4,2], [4,6]];\n    let elep2T = [[9,2], [9,6], [7,0], [7,4], [7,8], [5,2], [5,6]];\n\n\n    for (var i = 0; i &lt; elep1.length; i++) &#123;\n        if(!isArrayInArray(elep1T,elep1[i])) &#123;\n            console.log(&#39;象 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n    for (var i = 0; i &lt; elep2.length; i++) &#123;\n        if(!isArrayInArray(elep2T,elep2[i])) &#123;\n            console.log(&#39;相 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 仕/士\n    let advisor1T = [[0,3], [0,5], [1,4], [2,3], [2,5]]\n    let advisor2T = [[9,3], [9,5], [8,4], [7,3], [7,5]]\n\n\n    for (var i = 0; i &lt; advisor1.length; i++) &#123;\n        if(!isArrayInArray(advisor1T,advisor1[i])) &#123;\n            console.log(&#39;士 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n    for (var i = 0; i &lt; advisor2.length; i++) &#123;\n        if(!isArrayInArray(advisor2T,advisor2[i])) &#123;\n            console.log(&#39;仕 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 兵/卒\n    let soldier1 = chessIndex(b, &#39;卒&#39;);\n    let soldier2 = chessIndex(b, &#39;兵&#39;);\n    for (var i = 0; i &lt; soldier1.length; i++) &#123;\n        if (soldier1[i][0] &lt; 3) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125; else if(soldier1[i][0] &lt; 5 &amp;&amp; soldier1[i][1] % 2 === 1 ) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    for (var i = 0; i &lt; soldier2.length; i++) &#123;\n        if (soldier2[i][0] &gt; 6) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125; else if(soldier2[i][0] &gt; 4 &amp;&amp; soldier2[i][1] % 2 === 1 ) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    for (var i = 0; i &lt; 9; i++) &#123;\n        if(b[3][i] === &#39;卒&#39; &amp;&amp; b[4][i] === &#39;卒&#39;) &#123;\n            console.log(&#39;卒 at the wrong position&#39;)\n            return false;\n        &#125;\n        if(b[5][i] === &#39;兵&#39; &amp;&amp; b[6][i] === &#39;兵&#39;) &#123;\n            console.log(&#39;兵 at the wrong position&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    // 帥/將\n    let general1 = chessIndex(b, &#39;將&#39;);\n    let general2 = chessIndex(b, &#39;帥&#39;);\n    if (general1.length !== 1 || general2.length !== 1) &#123;\n        console.log( &#39;帥/將 lost &#39;)\n        return false;\n    &#125;\n    if (general1[0][0] &gt; 2 ||\n        general1[0][1] &lt; 3 ||\n        general1[0][1] &gt; 5 ||\n        general2[0][0] &lt; 7 ||\n        general2[0][1] &lt; 3 ||\n        general2[0][1] &gt; 5) &#123;\n        console.log( &#39;帥/將 at the wrong position &#39;)\n        return false;\n    &#125;\n\n    if(general1[0][1] === general2[0][1]) &#123;\n        let k = general1[0][1]\n        for (var i = general1[0][0]+1; i &lt; general2[0][0]; i++) &#123;\n            if (b[i][k] !== &#39;Ｘ&#39; &amp;&amp;\n                b[i][k] !== &#39;－&#39; &amp;&amp;\n                b[i][k] !== &#39;　&#39; &amp;&amp;\n                b[i][k] !== &#39;｜&#39; &amp;&amp;\n                b[i][k] !== &#39;＋&#39;) &#123;\n                break;\n            &#125;\n        &#125;\n        if(i === general2[0][0]) &#123;\n            console.log(&#39;帥/將 are directly facing each other at the same column&#39;)\n            return false;\n        &#125;\n    &#125;\n\n    //if a flipped starting board\n\n    return true;\n&#125;\n\nfunction chessIndex(b, s) &#123;\n    let res = [];\n    for (var i = 0; i &lt; b.length; i++) &#123;\n        let k = -1;\n        while((k = b[i].indexOf(s,k+1)) !== -1) &#123;\n            res.push([i,k]);\n        &#125;\n    &#125;\n    return res;\n&#125;\n\nfunction isArrayInArray(arr, item)&#123;\n  var item_as_string = JSON.stringify(item);\n\n  var contains = arr.some(function(ele)&#123;\n    return JSON.stringify(ele) === item_as_string;\n  &#125;);\n  return contains;\n&#125;\n</code></pre>\n<p>主要讲一下重复用到的两个 function 吧，一个是 <code>chessIndex()</code> 来得到棋盘上某个棋子的坐标，输出的是一个二维 array。另一个 <code>isArrayInArray(arr, item)</code> ，arr 是一个二维 array，item 是一个 array，检测 item 是否再 arr 里面。</p>\n<p><code>chessIndex()</code> 难点在与处理一行内重复的元素。比如:</p>\n<pre><code class=\"javascript\">&gt;a = a.split(&quot;&quot;)\n[ &#39;　&#39;, &#39;砲&#39;, &#39;　&#39;, &#39;＋&#39;, &#39;－&#39;, &#39;＋&#39;, &#39;　&#39;, &#39;砲&#39;, &#39;　&#39; ]\n&gt;a.indexOf(&#39;砲&#39;)\n1\n&gt;a.indexOf(&#39;砲&#39;,2)\n7\n&gt;\n</code></pre>\n<p>这里 array 中含有两个 <code>&#39;砲&#39;</code>。要获取第二个 <code>&#39;砲&#39;</code>，就要给 <code>indexOf()</code> 加上第二个参数。</p>\n<p><code>isArrayInArray()</code> 方法中用到 <code>JSON.stringfy</code>：</p>\n<pre><code class=\"javascript\">&gt;a = [[1,2],[2,3]]\n[ [ 1, 2 ], [ 2, 3 ] ]\n&gt;JSON.stringify(a)\n&#39;[[1,2],[2,3]]&#39;\n&gt;obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:30, &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;, age: 30, city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;today&quot;:new Date(), &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;,\n  today: 2018-06-10T03:44:24.742Z,\n  city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;today&quot;:&quot;2018-06-10T03:44:24.742Z&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt; obj = &#123; &quot;name&quot;:&quot;John&quot;, &quot;age&quot;:function () &#123;return 30;&#125;, &quot;city&quot;:&quot;New York&quot;&#125;;\n&#123; name: &#39;John&#39;, age: [Function: age], city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;obj.age = obj.age.toString()\n&#39;function () &#123;return 30;&#125;&#39;\n&gt;obj \n&#123; name: &#39;John&#39;,\n  age: &#39;function () &#123;return 30;&#125;&#39;,\n  city: &#39;New York&#39; &#125;\n&gt;JSON.stringify(obj)\n&#39;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:&quot;function () &#123;return 30;&#125;&quot;,&quot;city&quot;:&quot;New York&quot;&#125;&#39;\n&gt;\n</code></pre>\n<p>上面的例子，后面一大部分摘自 <a href=\"https://www.w3schools.com/js/js_json_stringify.asp\">JSON.stringify()</a>，可以看到，可以把  array，object 等直接转化成 string。最后两个例子是讲，如果 object 中包含函数，则会被忽略。</p>\n<p>用到了 <code>some()</code> 方法，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\">MDN docs</a> 给出的解释：</p>\n<blockquote>\n<p>The <code>some()</code> method tests whether at least one element in the array passes the test implemented by the provided function.</p>\n</blockquote>\n<p>上述两个函数方法的构造是关键。在这两个函数的基础上，对棋盘的棋子进行依此按照相应的的规则进行检测，剩下的只是一些比较繁琐的工作，和细节上的修饰。</p>"},{"title":"热病","date":"2022-12-31T03:35:10.000Z","_content":"\n在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。\n\n战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。\n\n我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。\n\n这是关于发烧，最神奇的一次经历。\n\n<!--more-->\n\n# 游戏\n\n- [The Last of Us™ Part I](https://www.playstation.com/en-us/games/the-last-of-us-part-i/) | PlayStation 5\n- [Xenoblade Chronicles™ 3](https://www.nintendo.com.hk/switch/az3ha/) | Nintendo Switch\n- [Xenoblade Chronicles™ 2](https://www.nintendo.com/store/products/xenoblade-chronicles-2-switch/) | Nintendo Switch\n- [スプラトゥーン3](https://www.nintendo.co.jp/switch/av5ja/index.html) | Nintendo Switch\n- [Elden Ring](https://en.bandainamcoent.eu/elden-ring/elden-ring) | PlayStation 5\n- [Detroit: Become Human]() | PlayStation 5\n\nThe Last of Us™ Part I 是我今年玩到的游戏中，带给我无限感伤的游戏。游戏的总体流程不长，线性关卡，有些许的解谜要素，战斗部分在重制版中，加入了陀螺仪瞄准和 ps5 手柄的适配。游戏通关后，自己又去重新听了三年前 Hard Image 的两期播客：\n\n- [Episode 76: The Last of Us：故事的意义与元素（一）](https://hardimage.pro/episodes/76)\n- [Episode 77: The Last of US：故事的意义与元素（二）](https://hardimage.pro/episodes/77)\n\n> 冗长的感想主要集中在故事的讲法，性格如何塑造，以及对不可知做法的一些想象。\n\n以前就经常和其他人讲，游戏之所以能够在艺术表达上高于电影等艺术媒介，因为游戏比电影多了一层「交互」的维度。然而真正能把「交互」这一维度用好的游戏叙事却很少，但恰恰 The Last of Us™ Part I 算是这么一部作品。其中有很多设计都很精巧，比如主角 Joel 被绳子吊起来，整个屏幕视角上下颠倒，然后要在这样一种状态下保护 Ellie。以及 Joel 和 Ellie 被突如其来的意外事件分开，经历险阻为 Ellie 的第一次开抢埋下伏笔。一些场景至今想起依然难以释怀，第一次陪着 Ellie 穿越酒店，在一间一间房间中经过时，看到浴室里的相对而坐的骷髅，它们临死的前一刻在想些什么呢。在后来的大学场景中，和 Ellie 一起走过学生宿舍，你能看到下午三点半的阳光，透过窗子打在了学生宿舍的书桌上，上下铺的床铺上积了很厚的一层灰尘，墙上还挂着当时流行的游戏海报，书柜中几本书，还有几盒游戏。后来到了一个临时的地下避难所，这里不久之前明明就有幸存者，周边的玩具，黑板也证明了有小孩子在这里生活。然后因为一次意外，里面的幸存的人都不见了踪影。\n\n游戏手法的高明之处，就在于他把上述作者想要表达的内容，传递的情感，透过游戏场景，剧情设计，关卡设计给到玩家，最后由玩家亲自去经历，去体验这样的一个末日故事。\n\n![tlou](tlou.jpeg)\n\n「异度之刃2」很早就买了，21 年元旦的时候沉迷过一段时间，后来因为别的事情不了了之，就搁置了。今年是因为「异度之刃3」要发售，就赶紧把「异度之刃2」拿出来，给通关了。七月份的时候通的关，那一天为了一口气看到最后的剧情，一直熬到了凌晨四点。\n\n「异度之刃3」整体上游玩体验还是很不错的，游戏的整体机制，寻路系统，英雄任务等等，相比前作都是巨大的提升。可能唯一不太舒服的是后半段的节奏问题，在世界观展开以后就突然急转直下，反派也都太过脸谱化。导致最后的 boss 战也没有太多亮眼的地方。\n\nSplatoon3 可以算上十月份以来，游玩时间最长的游戏。此前的自己唯一接触过的射击游戏就是 CS，那还是十几年前的的事情。Splatoon 作为一款 TPS ( 第三人称射击游戏 ) 真的很独特。从玩法，到设计，再到创意，都是独一无二。赞叹任天堂的想象力。\n\nElden Ring 我到最后也没有玩完，大概是玩到王城下水道那个地方，玩不下去了。此前从没有过任何魂游戏的经验，导致我刚开始玩 Elden Ring 时，甚至新手村都出不去。后来找了一个攻略，就想着按照攻略玩，但那样每一步都按照攻略走，就完全丧失了玩游戏的意义。到后来就索性不去玩了。也许以后会有某个契机，把剩余的内容玩完。\n\n# 音乐\n\n- Can't Take My Eyes Off You - Joytastic Sarah\n- The Last of Us - Gustavo Santaolalla\n- The Path ( A New Beginning) - Gustavo Santaolalla\n- The Choice - Gustavo Santaolalla\n- All Gone - Gustavo Santaolalla\n- [Moebius Battle](https://www.youtube.com/watch?v=4hqSSb5rPE0)\n\n其中的很多首都是出自 The Last of Us™ Part I 游戏中的配乐。\n\n# 电影\n\n![drive-my-car](drive-my-car.jpeg)\n\n- 『钛』\n- 『间谍之妻』\n- 『坏小子』\n- 『黑客帝国』\n- 『驾驶我的车』\n- 『鬼灭之刃』\n- 『反叛的鲁鲁修』\n- 『死亡笔记』\n- 『冰菓』\n- 『春风沉醉的夜晚』\n- 『旺角卡门』\n- 『弥留之国的爱丽丝 第二季』\n\n今年并没有很认真地去标记电影了，主要是因为自己在写自己的 app，也就没有很大的动力再去打开 douban。看了很多动漫，有一些没有标记上。\n\n# 书\n\n技术类\n\n- iOS Animations by Tutorials\n- iOS 15 Programming for Beginners\n- Advanced iOS App Architecture\n- Design Patterns By Tutorials\n- Core Data by Tutorials\n\n非技术类\n\n- 斯普特尼克恋人\n- 没有女人的男人们\n- 神的孩子全跳舞\n\n# 时刻\n\n今年有很多神奇的时刻和神奇的故事，比如蛰伏一年，Golden State Warriors 终于又重新回到季后赛，过五关斩六将，杀到总决赛，在 6 月 17 日这天终于捧杯，Steph Curry 也终于拿下了 FMVP。\n\n比如 Messi 的故事也终于圆满，成为了传奇。\n\n后来发现，小智也在这一年拿到了属于他的冠军。\n\n### @xiaolwl\n\n今年的很多时候，我会去看 @xiaolwl 生前最后一条微博下面的评论。我感觉那里的评论是真实的。\n\n### 炉石停服\n\n14 年炉石刚开始的时候，是主打 iPad 上的卡牌游戏，当时的手边刚好有一台 iPad mini2，就不知不觉上手了。但当时只是玩了一段时间之后就不玩了。一直到 2018 年，当时的自己阴差阳错，机缘巧合又再次打开炉石，一直玩到了现在。炉石可以算做陪伴我走过了很长一段低谷的游戏。\n\n# 结语\n\n大概在一周以前，平安夜那晚。自己突然感觉身体不适，看了一下 Apple Watch，明明是静坐，心率却一直在 100 上下，摸了摸额头，额头也烫的厉害。心想，大概率是感染了。那一天晚上很痛苦，躺在床上翻来覆去睡不着，身体发烫，心脏也跳的很快，能清楚听到心脏每一次跳动的的声音，还伴随着心绞痛。想着时间快快过去吧，快点跳到早上，好出去买药。可时间却走的无比缓慢，从十二点到一点，从一点到两点，从两点到三点。最后挨到五点钟的时候，起床烧了一壶水，坐在椅子上，半闭着双眼，轻瞥到 Apple Watch 上的心率依然在 100 上下。然后我大概就是那样半躺着靠着椅背，一直挨到七八点钟，出门买药。\n\n从小到大，有过几次发烧，但都没有这次来得这么凶猛猛烈。希望之后能慢慢恢复过来，希望爸爸妈妈，身边的亲人也都身体健康。\n\n🌻\n","source":"_posts/热病.md","raw":"---\ntitle: 热病\ndate: 2022-12-31 11:35:10\ntags:\n- 电影\n- 游戏\n- 音乐\ncategories: 'I/O'\n---\n\n在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。\n\n战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。\n\n我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。\n\n这是关于发烧，最神奇的一次经历。\n\n<!--more-->\n\n# 游戏\n\n- [The Last of Us™ Part I](https://www.playstation.com/en-us/games/the-last-of-us-part-i/) | PlayStation 5\n- [Xenoblade Chronicles™ 3](https://www.nintendo.com.hk/switch/az3ha/) | Nintendo Switch\n- [Xenoblade Chronicles™ 2](https://www.nintendo.com/store/products/xenoblade-chronicles-2-switch/) | Nintendo Switch\n- [スプラトゥーン3](https://www.nintendo.co.jp/switch/av5ja/index.html) | Nintendo Switch\n- [Elden Ring](https://en.bandainamcoent.eu/elden-ring/elden-ring) | PlayStation 5\n- [Detroit: Become Human]() | PlayStation 5\n\nThe Last of Us™ Part I 是我今年玩到的游戏中，带给我无限感伤的游戏。游戏的总体流程不长，线性关卡，有些许的解谜要素，战斗部分在重制版中，加入了陀螺仪瞄准和 ps5 手柄的适配。游戏通关后，自己又去重新听了三年前 Hard Image 的两期播客：\n\n- [Episode 76: The Last of Us：故事的意义与元素（一）](https://hardimage.pro/episodes/76)\n- [Episode 77: The Last of US：故事的意义与元素（二）](https://hardimage.pro/episodes/77)\n\n> 冗长的感想主要集中在故事的讲法，性格如何塑造，以及对不可知做法的一些想象。\n\n以前就经常和其他人讲，游戏之所以能够在艺术表达上高于电影等艺术媒介，因为游戏比电影多了一层「交互」的维度。然而真正能把「交互」这一维度用好的游戏叙事却很少，但恰恰 The Last of Us™ Part I 算是这么一部作品。其中有很多设计都很精巧，比如主角 Joel 被绳子吊起来，整个屏幕视角上下颠倒，然后要在这样一种状态下保护 Ellie。以及 Joel 和 Ellie 被突如其来的意外事件分开，经历险阻为 Ellie 的第一次开抢埋下伏笔。一些场景至今想起依然难以释怀，第一次陪着 Ellie 穿越酒店，在一间一间房间中经过时，看到浴室里的相对而坐的骷髅，它们临死的前一刻在想些什么呢。在后来的大学场景中，和 Ellie 一起走过学生宿舍，你能看到下午三点半的阳光，透过窗子打在了学生宿舍的书桌上，上下铺的床铺上积了很厚的一层灰尘，墙上还挂着当时流行的游戏海报，书柜中几本书，还有几盒游戏。后来到了一个临时的地下避难所，这里不久之前明明就有幸存者，周边的玩具，黑板也证明了有小孩子在这里生活。然后因为一次意外，里面的幸存的人都不见了踪影。\n\n游戏手法的高明之处，就在于他把上述作者想要表达的内容，传递的情感，透过游戏场景，剧情设计，关卡设计给到玩家，最后由玩家亲自去经历，去体验这样的一个末日故事。\n\n![tlou](tlou.jpeg)\n\n「异度之刃2」很早就买了，21 年元旦的时候沉迷过一段时间，后来因为别的事情不了了之，就搁置了。今年是因为「异度之刃3」要发售，就赶紧把「异度之刃2」拿出来，给通关了。七月份的时候通的关，那一天为了一口气看到最后的剧情，一直熬到了凌晨四点。\n\n「异度之刃3」整体上游玩体验还是很不错的，游戏的整体机制，寻路系统，英雄任务等等，相比前作都是巨大的提升。可能唯一不太舒服的是后半段的节奏问题，在世界观展开以后就突然急转直下，反派也都太过脸谱化。导致最后的 boss 战也没有太多亮眼的地方。\n\nSplatoon3 可以算上十月份以来，游玩时间最长的游戏。此前的自己唯一接触过的射击游戏就是 CS，那还是十几年前的的事情。Splatoon 作为一款 TPS ( 第三人称射击游戏 ) 真的很独特。从玩法，到设计，再到创意，都是独一无二。赞叹任天堂的想象力。\n\nElden Ring 我到最后也没有玩完，大概是玩到王城下水道那个地方，玩不下去了。此前从没有过任何魂游戏的经验，导致我刚开始玩 Elden Ring 时，甚至新手村都出不去。后来找了一个攻略，就想着按照攻略玩，但那样每一步都按照攻略走，就完全丧失了玩游戏的意义。到后来就索性不去玩了。也许以后会有某个契机，把剩余的内容玩完。\n\n# 音乐\n\n- Can't Take My Eyes Off You - Joytastic Sarah\n- The Last of Us - Gustavo Santaolalla\n- The Path ( A New Beginning) - Gustavo Santaolalla\n- The Choice - Gustavo Santaolalla\n- All Gone - Gustavo Santaolalla\n- [Moebius Battle](https://www.youtube.com/watch?v=4hqSSb5rPE0)\n\n其中的很多首都是出自 The Last of Us™ Part I 游戏中的配乐。\n\n# 电影\n\n![drive-my-car](drive-my-car.jpeg)\n\n- 『钛』\n- 『间谍之妻』\n- 『坏小子』\n- 『黑客帝国』\n- 『驾驶我的车』\n- 『鬼灭之刃』\n- 『反叛的鲁鲁修』\n- 『死亡笔记』\n- 『冰菓』\n- 『春风沉醉的夜晚』\n- 『旺角卡门』\n- 『弥留之国的爱丽丝 第二季』\n\n今年并没有很认真地去标记电影了，主要是因为自己在写自己的 app，也就没有很大的动力再去打开 douban。看了很多动漫，有一些没有标记上。\n\n# 书\n\n技术类\n\n- iOS Animations by Tutorials\n- iOS 15 Programming for Beginners\n- Advanced iOS App Architecture\n- Design Patterns By Tutorials\n- Core Data by Tutorials\n\n非技术类\n\n- 斯普特尼克恋人\n- 没有女人的男人们\n- 神的孩子全跳舞\n\n# 时刻\n\n今年有很多神奇的时刻和神奇的故事，比如蛰伏一年，Golden State Warriors 终于又重新回到季后赛，过五关斩六将，杀到总决赛，在 6 月 17 日这天终于捧杯，Steph Curry 也终于拿下了 FMVP。\n\n比如 Messi 的故事也终于圆满，成为了传奇。\n\n后来发现，小智也在这一年拿到了属于他的冠军。\n\n### @xiaolwl\n\n今年的很多时候，我会去看 @xiaolwl 生前最后一条微博下面的评论。我感觉那里的评论是真实的。\n\n### 炉石停服\n\n14 年炉石刚开始的时候，是主打 iPad 上的卡牌游戏，当时的手边刚好有一台 iPad mini2，就不知不觉上手了。但当时只是玩了一段时间之后就不玩了。一直到 2018 年，当时的自己阴差阳错，机缘巧合又再次打开炉石，一直玩到了现在。炉石可以算做陪伴我走过了很长一段低谷的游戏。\n\n# 结语\n\n大概在一周以前，平安夜那晚。自己突然感觉身体不适，看了一下 Apple Watch，明明是静坐，心率却一直在 100 上下，摸了摸额头，额头也烫的厉害。心想，大概率是感染了。那一天晚上很痛苦，躺在床上翻来覆去睡不着，身体发烫，心脏也跳的很快，能清楚听到心脏每一次跳动的的声音，还伴随着心绞痛。想着时间快快过去吧，快点跳到早上，好出去买药。可时间却走的无比缓慢，从十二点到一点，从一点到两点，从两点到三点。最后挨到五点钟的时候，起床烧了一壶水，坐在椅子上，半闭着双眼，轻瞥到 Apple Watch 上的心率依然在 100 上下。然后我大概就是那样半躺着靠着椅背，一直挨到七八点钟，出门买药。\n\n从小到大，有过几次发烧，但都没有这次来得这么凶猛猛烈。希望之后能慢慢恢复过来，希望爸爸妈妈，身边的亲人也都身体健康。\n\n🌻\n","slug":"热病","published":1,"updated":"2022-12-31T15:10:04.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2c0047rg1v66cg2rrp","content":"<p>在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。</p>\n<p>战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。</p>\n<p>我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。</p>\n<p>这是关于发烧，最神奇的一次经历。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h1><ul>\n<li><a href=\"https://www.playstation.com/en-us/games/the-last-of-us-part-i/\">The Last of Us™ Part I</a> | PlayStation 5</li>\n<li><a href=\"https://www.nintendo.com.hk/switch/az3ha/\">Xenoblade Chronicles™ 3</a> | Nintendo Switch</li>\n<li><a href=\"https://www.nintendo.com/store/products/xenoblade-chronicles-2-switch/\">Xenoblade Chronicles™ 2</a> | Nintendo Switch</li>\n<li><a href=\"https://www.nintendo.co.jp/switch/av5ja/index.html\">スプラトゥーン3</a> | Nintendo Switch</li>\n<li><a href=\"https://en.bandainamcoent.eu/elden-ring/elden-ring\">Elden Ring</a> | PlayStation 5</li>\n<li><a href=\"\">Detroit: Become Human</a> | PlayStation 5</li>\n</ul>\n<p>The Last of Us™ Part I 是我今年玩到的游戏中，带给我无限感伤的游戏。游戏的总体流程不长，线性关卡，有些许的解谜要素，战斗部分在重制版中，加入了陀螺仪瞄准和 ps5 手柄的适配。游戏通关后，自己又去重新听了三年前 Hard Image 的两期播客：</p>\n<ul>\n<li><a href=\"https://hardimage.pro/episodes/76\">Episode 76: The Last of Us：故事的意义与元素（一）</a></li>\n<li><a href=\"https://hardimage.pro/episodes/77\">Episode 77: The Last of US：故事的意义与元素（二）</a></li>\n</ul>\n<blockquote>\n<p>冗长的感想主要集中在故事的讲法，性格如何塑造，以及对不可知做法的一些想象。</p>\n</blockquote>\n<p>以前就经常和其他人讲，游戏之所以能够在艺术表达上高于电影等艺术媒介，因为游戏比电影多了一层「交互」的维度。然而真正能把「交互」这一维度用好的游戏叙事却很少，但恰恰 The Last of Us™ Part I 算是这么一部作品。其中有很多设计都很精巧，比如主角 Joel 被绳子吊起来，整个屏幕视角上下颠倒，然后要在这样一种状态下保护 Ellie。以及 Joel 和 Ellie 被突如其来的意外事件分开，经历险阻为 Ellie 的第一次开抢埋下伏笔。一些场景至今想起依然难以释怀，第一次陪着 Ellie 穿越酒店，在一间一间房间中经过时，看到浴室里的相对而坐的骷髅，它们临死的前一刻在想些什么呢。在后来的大学场景中，和 Ellie 一起走过学生宿舍，你能看到下午三点半的阳光，透过窗子打在了学生宿舍的书桌上，上下铺的床铺上积了很厚的一层灰尘，墙上还挂着当时流行的游戏海报，书柜中几本书，还有几盒游戏。后来到了一个临时的地下避难所，这里不久之前明明就有幸存者，周边的玩具，黑板也证明了有小孩子在这里生活。然后因为一次意外，里面的幸存的人都不见了踪影。</p>\n<p>游戏手法的高明之处，就在于他把上述作者想要表达的内容，传递的情感，透过游戏场景，剧情设计，关卡设计给到玩家，最后由玩家亲自去经历，去体验这样的一个末日故事。</p>\n<p><img src=\"tlou.jpeg\" alt=\"tlou\"></p>\n<p>「异度之刃2」很早就买了，21 年元旦的时候沉迷过一段时间，后来因为别的事情不了了之，就搁置了。今年是因为「异度之刃3」要发售，就赶紧把「异度之刃2」拿出来，给通关了。七月份的时候通的关，那一天为了一口气看到最后的剧情，一直熬到了凌晨四点。</p>\n<p>「异度之刃3」整体上游玩体验还是很不错的，游戏的整体机制，寻路系统，英雄任务等等，相比前作都是巨大的提升。可能唯一不太舒服的是后半段的节奏问题，在世界观展开以后就突然急转直下，反派也都太过脸谱化。导致最后的 boss 战也没有太多亮眼的地方。</p>\n<p>Splatoon3 可以算上十月份以来，游玩时间最长的游戏。此前的自己唯一接触过的射击游戏就是 CS，那还是十几年前的的事情。Splatoon 作为一款 TPS ( 第三人称射击游戏 ) 真的很独特。从玩法，到设计，再到创意，都是独一无二。赞叹任天堂的想象力。</p>\n<p>Elden Ring 我到最后也没有玩完，大概是玩到王城下水道那个地方，玩不下去了。此前从没有过任何魂游戏的经验，导致我刚开始玩 Elden Ring 时，甚至新手村都出不去。后来找了一个攻略，就想着按照攻略玩，但那样每一步都按照攻略走，就完全丧失了玩游戏的意义。到后来就索性不去玩了。也许以后会有某个契机，把剩余的内容玩完。</p>\n<h1 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h1><ul>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>The Last of Us - Gustavo Santaolalla</li>\n<li>The Path ( A New Beginning) - Gustavo Santaolalla</li>\n<li>The Choice - Gustavo Santaolalla</li>\n<li>All Gone - Gustavo Santaolalla</li>\n<li><a href=\"https://www.youtube.com/watch?v=4hqSSb5rPE0\">Moebius Battle</a></li>\n</ul>\n<p>其中的很多首都是出自 The Last of Us™ Part I 游戏中的配乐。</p>\n<h1 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h1><p><img src=\"drive-my-car.jpeg\" alt=\"drive-my-car\"></p>\n<ul>\n<li>『钛』</li>\n<li>『间谍之妻』</li>\n<li>『坏小子』</li>\n<li>『黑客帝国』</li>\n<li>『驾驶我的车』</li>\n<li>『鬼灭之刃』</li>\n<li>『反叛的鲁鲁修』</li>\n<li>『死亡笔记』</li>\n<li>『冰菓』</li>\n<li>『春风沉醉的夜晚』</li>\n<li>『旺角卡门』</li>\n<li>『弥留之国的爱丽丝 第二季』</li>\n</ul>\n<p>今年并没有很认真地去标记电影了，主要是因为自己在写自己的 app，也就没有很大的动力再去打开 douban。看了很多动漫，有一些没有标记上。</p>\n<h1 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h1><p>技术类</p>\n<ul>\n<li>iOS Animations by Tutorials</li>\n<li>iOS 15 Programming for Beginners</li>\n<li>Advanced iOS App Architecture</li>\n<li>Design Patterns By Tutorials</li>\n<li>Core Data by Tutorials</li>\n</ul>\n<p>非技术类</p>\n<ul>\n<li>斯普特尼克恋人</li>\n<li>没有女人的男人们</li>\n<li>神的孩子全跳舞</li>\n</ul>\n<h1 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h1><p>今年有很多神奇的时刻和神奇的故事，比如蛰伏一年，Golden State Warriors 终于又重新回到季后赛，过五关斩六将，杀到总决赛，在 6 月 17 日这天终于捧杯，Steph Curry 也终于拿下了 FMVP。</p>\n<p>比如 Messi 的故事也终于圆满，成为了传奇。</p>\n<p>后来发现，小智也在这一年拿到了属于他的冠军。</p>\n<h3 id=\"xiaolwl\"><a href=\"#xiaolwl\" class=\"headerlink\" title=\"@xiaolwl\"></a>@xiaolwl</h3><p>今年的很多时候，我会去看 @xiaolwl 生前最后一条微博下面的评论。我感觉那里的评论是真实的。</p>\n<h3 id=\"炉石停服\"><a href=\"#炉石停服\" class=\"headerlink\" title=\"炉石停服\"></a>炉石停服</h3><p>14 年炉石刚开始的时候，是主打 iPad 上的卡牌游戏，当时的手边刚好有一台 iPad mini2，就不知不觉上手了。但当时只是玩了一段时间之后就不玩了。一直到 2018 年，当时的自己阴差阳错，机缘巧合又再次打开炉石，一直玩到了现在。炉石可以算做陪伴我走过了很长一段低谷的游戏。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>大概在一周以前，平安夜那晚。自己突然感觉身体不适，看了一下 Apple Watch，明明是静坐，心率却一直在 100 上下，摸了摸额头，额头也烫的厉害。心想，大概率是感染了。那一天晚上很痛苦，躺在床上翻来覆去睡不着，身体发烫，心脏也跳的很快，能清楚听到心脏每一次跳动的的声音，还伴随着心绞痛。想着时间快快过去吧，快点跳到早上，好出去买药。可时间却走的无比缓慢，从十二点到一点，从一点到两点，从两点到三点。最后挨到五点钟的时候，起床烧了一壶水，坐在椅子上，半闭着双眼，轻瞥到 Apple Watch 上的心率依然在 100 上下。然后我大概就是那样半躺着靠着椅背，一直挨到七八点钟，出门买药。</p>\n<p>从小到大，有过几次发烧，但都没有这次来得这么凶猛猛烈。希望之后能慢慢恢复过来，希望爸爸妈妈，身边的亲人也都身体健康。</p>\n<p>🌻</p>\n","site":{"data":{}},"excerpt":"<p>在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。</p>\n<p>战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。</p>\n<p>我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。</p>\n<p>这是关于发烧，最神奇的一次经历。</p>","more":"<h1 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h1><ul>\n<li><a href=\"https://www.playstation.com/en-us/games/the-last-of-us-part-i/\">The Last of Us™ Part I</a> | PlayStation 5</li>\n<li><a href=\"https://www.nintendo.com.hk/switch/az3ha/\">Xenoblade Chronicles™ 3</a> | Nintendo Switch</li>\n<li><a href=\"https://www.nintendo.com/store/products/xenoblade-chronicles-2-switch/\">Xenoblade Chronicles™ 2</a> | Nintendo Switch</li>\n<li><a href=\"https://www.nintendo.co.jp/switch/av5ja/index.html\">スプラトゥーン3</a> | Nintendo Switch</li>\n<li><a href=\"https://en.bandainamcoent.eu/elden-ring/elden-ring\">Elden Ring</a> | PlayStation 5</li>\n<li><a href=\"\">Detroit: Become Human</a> | PlayStation 5</li>\n</ul>\n<p>The Last of Us™ Part I 是我今年玩到的游戏中，带给我无限感伤的游戏。游戏的总体流程不长，线性关卡，有些许的解谜要素，战斗部分在重制版中，加入了陀螺仪瞄准和 ps5 手柄的适配。游戏通关后，自己又去重新听了三年前 Hard Image 的两期播客：</p>\n<ul>\n<li><a href=\"https://hardimage.pro/episodes/76\">Episode 76: The Last of Us：故事的意义与元素（一）</a></li>\n<li><a href=\"https://hardimage.pro/episodes/77\">Episode 77: The Last of US：故事的意义与元素（二）</a></li>\n</ul>\n<blockquote>\n<p>冗长的感想主要集中在故事的讲法，性格如何塑造，以及对不可知做法的一些想象。</p>\n</blockquote>\n<p>以前就经常和其他人讲，游戏之所以能够在艺术表达上高于电影等艺术媒介，因为游戏比电影多了一层「交互」的维度。然而真正能把「交互」这一维度用好的游戏叙事却很少，但恰恰 The Last of Us™ Part I 算是这么一部作品。其中有很多设计都很精巧，比如主角 Joel 被绳子吊起来，整个屏幕视角上下颠倒，然后要在这样一种状态下保护 Ellie。以及 Joel 和 Ellie 被突如其来的意外事件分开，经历险阻为 Ellie 的第一次开抢埋下伏笔。一些场景至今想起依然难以释怀，第一次陪着 Ellie 穿越酒店，在一间一间房间中经过时，看到浴室里的相对而坐的骷髅，它们临死的前一刻在想些什么呢。在后来的大学场景中，和 Ellie 一起走过学生宿舍，你能看到下午三点半的阳光，透过窗子打在了学生宿舍的书桌上，上下铺的床铺上积了很厚的一层灰尘，墙上还挂着当时流行的游戏海报，书柜中几本书，还有几盒游戏。后来到了一个临时的地下避难所，这里不久之前明明就有幸存者，周边的玩具，黑板也证明了有小孩子在这里生活。然后因为一次意外，里面的幸存的人都不见了踪影。</p>\n<p>游戏手法的高明之处，就在于他把上述作者想要表达的内容，传递的情感，透过游戏场景，剧情设计，关卡设计给到玩家，最后由玩家亲自去经历，去体验这样的一个末日故事。</p>\n<p><img src=\"tlou.jpeg\" alt=\"tlou\"></p>\n<p>「异度之刃2」很早就买了，21 年元旦的时候沉迷过一段时间，后来因为别的事情不了了之，就搁置了。今年是因为「异度之刃3」要发售，就赶紧把「异度之刃2」拿出来，给通关了。七月份的时候通的关，那一天为了一口气看到最后的剧情，一直熬到了凌晨四点。</p>\n<p>「异度之刃3」整体上游玩体验还是很不错的，游戏的整体机制，寻路系统，英雄任务等等，相比前作都是巨大的提升。可能唯一不太舒服的是后半段的节奏问题，在世界观展开以后就突然急转直下，反派也都太过脸谱化。导致最后的 boss 战也没有太多亮眼的地方。</p>\n<p>Splatoon3 可以算上十月份以来，游玩时间最长的游戏。此前的自己唯一接触过的射击游戏就是 CS，那还是十几年前的的事情。Splatoon 作为一款 TPS ( 第三人称射击游戏 ) 真的很独特。从玩法，到设计，再到创意，都是独一无二。赞叹任天堂的想象力。</p>\n<p>Elden Ring 我到最后也没有玩完，大概是玩到王城下水道那个地方，玩不下去了。此前从没有过任何魂游戏的经验，导致我刚开始玩 Elden Ring 时，甚至新手村都出不去。后来找了一个攻略，就想着按照攻略玩，但那样每一步都按照攻略走，就完全丧失了玩游戏的意义。到后来就索性不去玩了。也许以后会有某个契机，把剩余的内容玩完。</p>\n<h1 id=\"音乐\"><a href=\"#音乐\" class=\"headerlink\" title=\"音乐\"></a>音乐</h1><ul>\n<li>Can’t Take My Eyes Off You - Joytastic Sarah</li>\n<li>The Last of Us - Gustavo Santaolalla</li>\n<li>The Path ( A New Beginning) - Gustavo Santaolalla</li>\n<li>The Choice - Gustavo Santaolalla</li>\n<li>All Gone - Gustavo Santaolalla</li>\n<li><a href=\"https://www.youtube.com/watch?v=4hqSSb5rPE0\">Moebius Battle</a></li>\n</ul>\n<p>其中的很多首都是出自 The Last of Us™ Part I 游戏中的配乐。</p>\n<h1 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h1><p><img src=\"drive-my-car.jpeg\" alt=\"drive-my-car\"></p>\n<ul>\n<li>『钛』</li>\n<li>『间谍之妻』</li>\n<li>『坏小子』</li>\n<li>『黑客帝国』</li>\n<li>『驾驶我的车』</li>\n<li>『鬼灭之刃』</li>\n<li>『反叛的鲁鲁修』</li>\n<li>『死亡笔记』</li>\n<li>『冰菓』</li>\n<li>『春风沉醉的夜晚』</li>\n<li>『旺角卡门』</li>\n<li>『弥留之国的爱丽丝 第二季』</li>\n</ul>\n<p>今年并没有很认真地去标记电影了，主要是因为自己在写自己的 app，也就没有很大的动力再去打开 douban。看了很多动漫，有一些没有标记上。</p>\n<h1 id=\"书\"><a href=\"#书\" class=\"headerlink\" title=\"书\"></a>书</h1><p>技术类</p>\n<ul>\n<li>iOS Animations by Tutorials</li>\n<li>iOS 15 Programming for Beginners</li>\n<li>Advanced iOS App Architecture</li>\n<li>Design Patterns By Tutorials</li>\n<li>Core Data by Tutorials</li>\n</ul>\n<p>非技术类</p>\n<ul>\n<li>斯普特尼克恋人</li>\n<li>没有女人的男人们</li>\n<li>神的孩子全跳舞</li>\n</ul>\n<h1 id=\"时刻\"><a href=\"#时刻\" class=\"headerlink\" title=\"时刻\"></a>时刻</h1><p>今年有很多神奇的时刻和神奇的故事，比如蛰伏一年，Golden State Warriors 终于又重新回到季后赛，过五关斩六将，杀到总决赛，在 6 月 17 日这天终于捧杯，Steph Curry 也终于拿下了 FMVP。</p>\n<p>比如 Messi 的故事也终于圆满，成为了传奇。</p>\n<p>后来发现，小智也在这一年拿到了属于他的冠军。</p>\n<h3 id=\"xiaolwl\"><a href=\"#xiaolwl\" class=\"headerlink\" title=\"@xiaolwl\"></a>@xiaolwl</h3><p>今年的很多时候，我会去看 @xiaolwl 生前最后一条微博下面的评论。我感觉那里的评论是真实的。</p>\n<h3 id=\"炉石停服\"><a href=\"#炉石停服\" class=\"headerlink\" title=\"炉石停服\"></a>炉石停服</h3><p>14 年炉石刚开始的时候，是主打 iPad 上的卡牌游戏，当时的手边刚好有一台 iPad mini2，就不知不觉上手了。但当时只是玩了一段时间之后就不玩了。一直到 2018 年，当时的自己阴差阳错，机缘巧合又再次打开炉石，一直玩到了现在。炉石可以算做陪伴我走过了很长一段低谷的游戏。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>大概在一周以前，平安夜那晚。自己突然感觉身体不适，看了一下 Apple Watch，明明是静坐，心率却一直在 100 上下，摸了摸额头，额头也烫的厉害。心想，大概率是感染了。那一天晚上很痛苦，躺在床上翻来覆去睡不着，身体发烫，心脏也跳的很快，能清楚听到心脏每一次跳动的的声音，还伴随着心绞痛。想着时间快快过去吧，快点跳到早上，好出去买药。可时间却走的无比缓慢，从十二点到一点，从一点到两点，从两点到三点。最后挨到五点钟的时候，起床烧了一壶水，坐在椅子上，半闭着双眼，轻瞥到 Apple Watch 上的心率依然在 100 上下。然后我大概就是那样半躺着靠着椅背，一直挨到七八点钟，出门买药。</p>\n<p>从小到大，有过几次发烧，但都没有这次来得这么凶猛猛烈。希望之后能慢慢恢复过来，希望爸爸妈妈，身边的亲人也都身体健康。</p>\n<p>🌻</p>"},{"title":"阅读摘要 | issue #2","date":"2019-06-12T12:45:12.000Z","_content":"\n## [The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)](https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html)\n\n在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 [foundationmedicine.com](http://foundationmedicine.com/) 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：\n\n- Logo\n- 空白处的填充，space filling；\n- 字体，GT Sectra，本身就具有六边形结构；\n- 分割线；\n- 诸如 qutation marks 这些小的 文字元素\n\n同样的视觉设计，分析也可用在 [The Intercept](https://theintercept.com/) ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 [CSS Tricks](https://css-tricks.com)，则是把「橙黄渐变」作为一种 motif。\n\n## [Level up your .sort game](https://css-tricks.com/level-up-your-sort-game/)\n\n关于 JavaScript 中 `.sort()` 方法的使用。其中提到的几点关键：\n\n- While many of the ES5 array methods such as `.filter`, `.map`, and `.reduce` will return a new array and leave the original untouched, `.sort` will sort the array in place.\n- 要想不让 original variable 发生改变，使用 `...` ；\n- Running functions before comparing values，这里存在一个小的 design pattern；\n- 如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 `reduce` 方法。\n- 如何写一个随机排序；\n\n<!--more-->\n\n## [如何反抗](https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/)\n\n> - 终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；\n> - 关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；\n> - 认真听音乐，在不幹别的的情况下。多人一起更佳； \n> - ...\n> - 意识到「所有人都是残疾人」这个事实；\n> - 一定要屌犬儒者的老母。\n\n## [macOS 10.15 Beta Release Notes](https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257)\n\n苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。\n\n## 六月里发生了一些事\n\n> 走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — [DM.](https://twitter.com/hengdm/status/1135737325323866113) \n>\n> 那是，毕竟吃药的第一步是承认自己有病。 — [妖術](https://twitter.com/ichimaru0223/status/1135737755487498240)\n\n## [INTJ](https://en.wikipedia.org/wiki/INTJ) & [INTP](https://en.wikipedia.org/wiki/INTP)\n\n- INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.\n- INTP: Introversion, Intuition, Thinking, Perceiving\n\n[这篇文章](https://personalityhacker.com/intp-vs-intj/)举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在[某豆瓣小组](https://www.douban.com/group/INT/?ref=sidebar)的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。\n\n看了上面的解释，认为自己可能属于 INTP 多一些。\n\n## Discoveries\n\n[CSS Grid Generator](https://cssgrid-generator.netlify.com)\n\n*自从生成 css grid 代码。*\n\n[Animated Knots](https://www.animatedknots.com/complete-knot-list)\n\n*一个教你如何打结的网站，每种方法都配有动画。*\n\n[Compare package download counts over time](https://www.npmtrends.com)\n\n*用于对比 npm package 的下载量。*\n\n[Pod Hunters: all of the cool podcasts that we recommend](https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup)\n\n*the verge 专栏 pod hunters，推荐好听的播客节目。*\n\n","source":"_posts/阅读摘要-issue-2.md","raw":"---\ntitle: '阅读摘要 | issue #2'\ndate: 2019-06-12 20:45:12\ntags:\n---\n\n## [The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)](https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html)\n\n在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 [foundationmedicine.com](http://foundationmedicine.com/) 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：\n\n- Logo\n- 空白处的填充，space filling；\n- 字体，GT Sectra，本身就具有六边形结构；\n- 分割线；\n- 诸如 qutation marks 这些小的 文字元素\n\n同样的视觉设计，分析也可用在 [The Intercept](https://theintercept.com/) ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 [CSS Tricks](https://css-tricks.com)，则是把「橙黄渐变」作为一种 motif。\n\n## [Level up your .sort game](https://css-tricks.com/level-up-your-sort-game/)\n\n关于 JavaScript 中 `.sort()` 方法的使用。其中提到的几点关键：\n\n- While many of the ES5 array methods such as `.filter`, `.map`, and `.reduce` will return a new array and leave the original untouched, `.sort` will sort the array in place.\n- 要想不让 original variable 发生改变，使用 `...` ；\n- Running functions before comparing values，这里存在一个小的 design pattern；\n- 如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 `reduce` 方法。\n- 如何写一个随机排序；\n\n<!--more-->\n\n## [如何反抗](https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/)\n\n> - 终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；\n> - 关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；\n> - 认真听音乐，在不幹别的的情况下。多人一起更佳； \n> - ...\n> - 意识到「所有人都是残疾人」这个事实；\n> - 一定要屌犬儒者的老母。\n\n## [macOS 10.15 Beta Release Notes](https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257)\n\n苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。\n\n## 六月里发生了一些事\n\n> 走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — [DM.](https://twitter.com/hengdm/status/1135737325323866113) \n>\n> 那是，毕竟吃药的第一步是承认自己有病。 — [妖術](https://twitter.com/ichimaru0223/status/1135737755487498240)\n\n## [INTJ](https://en.wikipedia.org/wiki/INTJ) & [INTP](https://en.wikipedia.org/wiki/INTP)\n\n- INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.\n- INTP: Introversion, Intuition, Thinking, Perceiving\n\n[这篇文章](https://personalityhacker.com/intp-vs-intj/)举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在[某豆瓣小组](https://www.douban.com/group/INT/?ref=sidebar)的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。\n\n看了上面的解释，认为自己可能属于 INTP 多一些。\n\n## Discoveries\n\n[CSS Grid Generator](https://cssgrid-generator.netlify.com)\n\n*自从生成 css grid 代码。*\n\n[Animated Knots](https://www.animatedknots.com/complete-knot-list)\n\n*一个教你如何打结的网站，每种方法都配有动画。*\n\n[Compare package download counts over time](https://www.npmtrends.com)\n\n*用于对比 npm package 的下载量。*\n\n[Pod Hunters: all of the cool podcasts that we recommend](https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup)\n\n*the verge 专栏 pod hunters，推荐好听的播客节目。*\n\n","slug":"阅读摘要-issue-2","published":1,"updated":"2019-07-12T09:37:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2d004arg1vghltcbwh","content":"<h2 id=\"The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand\"><a href=\"#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand\" class=\"headerlink\" title=\"The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)\"></a><a href=\"https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html\">The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)</a></h2><p>在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 <a href=\"http://foundationmedicine.com/\">foundationmedicine.com</a> 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：</p>\n<ul>\n<li>Logo</li>\n<li>空白处的填充，space filling；</li>\n<li>字体，GT Sectra，本身就具有六边形结构；</li>\n<li>分割线；</li>\n<li>诸如 qutation marks 这些小的 文字元素</li>\n</ul>\n<p>同样的视觉设计，分析也可用在 <a href=\"https://theintercept.com/\">The Intercept</a> ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 <a href=\"https://css-tricks.com/\">CSS Tricks</a>，则是把「橙黄渐变」作为一种 motif。</p>\n<h2 id=\"Level-up-your-sort-game\"><a href=\"#Level-up-your-sort-game\" class=\"headerlink\" title=\"Level up your .sort game\"></a><a href=\"https://css-tricks.com/level-up-your-sort-game/\">Level up your .sort game</a></h2><p>关于 JavaScript 中 <code>.sort()</code> 方法的使用。其中提到的几点关键：</p>\n<ul>\n<li>While many of the ES5 array methods such as <code>.filter</code>, <code>.map</code>, and <code>.reduce</code> will return a new array and leave the original untouched, <code>.sort</code> will sort the array in place.</li>\n<li>要想不让 original variable 发生改变，使用 <code>...</code> ；</li>\n<li>Running functions before comparing values，这里存在一个小的 design pattern；</li>\n<li>如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 <code>reduce</code> 方法。</li>\n<li>如何写一个随机排序；</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"如何反抗\"><a href=\"#如何反抗\" class=\"headerlink\" title=\"如何反抗\"></a><a href=\"https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/\">如何反抗</a></h2><blockquote>\n<ul>\n<li>终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；</li>\n<li>关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；</li>\n<li>认真听音乐，在不幹别的的情况下。多人一起更佳； </li>\n<li>…</li>\n<li>意识到「所有人都是残疾人」这个事实；</li>\n<li>一定要屌犬儒者的老母。</li>\n</ul>\n</blockquote>\n<h2 id=\"macOS-10-15-Beta-Release-Notes\"><a href=\"#macOS-10-15-Beta-Release-Notes\" class=\"headerlink\" title=\"macOS 10.15 Beta Release Notes\"></a><a href=\"https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257\">macOS 10.15 Beta Release Notes</a></h2><p>苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。</p>\n<h2 id=\"六月里发生了一些事\"><a href=\"#六月里发生了一些事\" class=\"headerlink\" title=\"六月里发生了一些事\"></a>六月里发生了一些事</h2><blockquote>\n<p>走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — <a href=\"https://twitter.com/hengdm/status/1135737325323866113\">DM.</a> </p>\n<p>那是，毕竟吃药的第一步是承认自己有病。 — <a href=\"https://twitter.com/ichimaru0223/status/1135737755487498240\">妖術</a></p>\n</blockquote>\n<h2 id=\"INTJ-amp-INTP\"><a href=\"#INTJ-amp-INTP\" class=\"headerlink\" title=\"INTJ &amp; INTP\"></a><a href=\"https://en.wikipedia.org/wiki/INTJ\">INTJ</a> &amp; <a href=\"https://en.wikipedia.org/wiki/INTP\">INTP</a></h2><ul>\n<li>INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.</li>\n<li>INTP: Introversion, Intuition, Thinking, Perceiving</li>\n</ul>\n<p><a href=\"https://personalityhacker.com/intp-vs-intj/\">这篇文章</a>举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在<a href=\"https://www.douban.com/group/INT/?ref=sidebar\">某豆瓣小组</a>的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。</p>\n<p>看了上面的解释，认为自己可能属于 INTP 多一些。</p>\n<h2 id=\"Discoveries\"><a href=\"#Discoveries\" class=\"headerlink\" title=\"Discoveries\"></a>Discoveries</h2><p><a href=\"https://cssgrid-generator.netlify.com/\">CSS Grid Generator</a></p>\n<p><em>自从生成 css grid 代码。</em></p>\n<p><a href=\"https://www.animatedknots.com/complete-knot-list\">Animated Knots</a></p>\n<p><em>一个教你如何打结的网站，每种方法都配有动画。</em></p>\n<p><a href=\"https://www.npmtrends.com/\">Compare package download counts over time</a></p>\n<p><em>用于对比 npm package 的下载量。</em></p>\n<p><a href=\"https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup\">Pod Hunters: all of the cool podcasts that we recommend</a></p>\n<p><em>the verge 专栏 pod hunters，推荐好听的播客节目。</em></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand\"><a href=\"#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand\" class=\"headerlink\" title=\"The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)\"></a><a href=\"https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html\">The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)</a></h2><p>在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 <a href=\"http://foundationmedicine.com/\">foundationmedicine.com</a> 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：</p>\n<ul>\n<li>Logo</li>\n<li>空白处的填充，space filling；</li>\n<li>字体，GT Sectra，本身就具有六边形结构；</li>\n<li>分割线；</li>\n<li>诸如 qutation marks 这些小的 文字元素</li>\n</ul>\n<p>同样的视觉设计，分析也可用在 <a href=\"https://theintercept.com/\">The Intercept</a> ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 <a href=\"https://css-tricks.com/\">CSS Tricks</a>，则是把「橙黄渐变」作为一种 motif。</p>\n<h2 id=\"Level-up-your-sort-game\"><a href=\"#Level-up-your-sort-game\" class=\"headerlink\" title=\"Level up your .sort game\"></a><a href=\"https://css-tricks.com/level-up-your-sort-game/\">Level up your .sort game</a></h2><p>关于 JavaScript 中 <code>.sort()</code> 方法的使用。其中提到的几点关键：</p>\n<ul>\n<li>While many of the ES5 array methods such as <code>.filter</code>, <code>.map</code>, and <code>.reduce</code> will return a new array and leave the original untouched, <code>.sort</code> will sort the array in place.</li>\n<li>要想不让 original variable 发生改变，使用 <code>...</code> ；</li>\n<li>Running functions before comparing values，这里存在一个小的 design pattern；</li>\n<li>如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 <code>reduce</code> 方法。</li>\n<li>如何写一个随机排序；</li>\n</ul>","more":"<h2 id=\"如何反抗\"><a href=\"#如何反抗\" class=\"headerlink\" title=\"如何反抗\"></a><a href=\"https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/\">如何反抗</a></h2><blockquote>\n<ul>\n<li>终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；</li>\n<li>关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；</li>\n<li>认真听音乐，在不幹别的的情况下。多人一起更佳； </li>\n<li>…</li>\n<li>意识到「所有人都是残疾人」这个事实；</li>\n<li>一定要屌犬儒者的老母。</li>\n</ul>\n</blockquote>\n<h2 id=\"macOS-10-15-Beta-Release-Notes\"><a href=\"#macOS-10-15-Beta-Release-Notes\" class=\"headerlink\" title=\"macOS 10.15 Beta Release Notes\"></a><a href=\"https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257\">macOS 10.15 Beta Release Notes</a></h2><p>苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。</p>\n<h2 id=\"六月里发生了一些事\"><a href=\"#六月里发生了一些事\" class=\"headerlink\" title=\"六月里发生了一些事\"></a>六月里发生了一些事</h2><blockquote>\n<p>走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — <a href=\"https://twitter.com/hengdm/status/1135737325323866113\">DM.</a> </p>\n<p>那是，毕竟吃药的第一步是承认自己有病。 — <a href=\"https://twitter.com/ichimaru0223/status/1135737755487498240\">妖術</a></p>\n</blockquote>\n<h2 id=\"INTJ-amp-INTP\"><a href=\"#INTJ-amp-INTP\" class=\"headerlink\" title=\"INTJ &amp; INTP\"></a><a href=\"https://en.wikipedia.org/wiki/INTJ\">INTJ</a> &amp; <a href=\"https://en.wikipedia.org/wiki/INTP\">INTP</a></h2><ul>\n<li>INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.</li>\n<li>INTP: Introversion, Intuition, Thinking, Perceiving</li>\n</ul>\n<p><a href=\"https://personalityhacker.com/intp-vs-intj/\">这篇文章</a>举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在<a href=\"https://www.douban.com/group/INT/?ref=sidebar\">某豆瓣小组</a>的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。</p>\n<p>看了上面的解释，认为自己可能属于 INTP 多一些。</p>\n<h2 id=\"Discoveries\"><a href=\"#Discoveries\" class=\"headerlink\" title=\"Discoveries\"></a>Discoveries</h2><p><a href=\"https://cssgrid-generator.netlify.com/\">CSS Grid Generator</a></p>\n<p><em>自从生成 css grid 代码。</em></p>\n<p><a href=\"https://www.animatedknots.com/complete-knot-list\">Animated Knots</a></p>\n<p><em>一个教你如何打结的网站，每种方法都配有动画。</em></p>\n<p><a href=\"https://www.npmtrends.com/\">Compare package download counts over time</a></p>\n<p><em>用于对比 npm package 的下载量。</em></p>\n<p><a href=\"https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup\">Pod Hunters: all of the cool podcasts that we recommend</a></p>\n<p><em>the verge 专栏 pod hunters，推荐好听的播客节目。</em></p>"},{"title":"阅读摘要 | issue #3","date":"2019-07-12T09:33:53.000Z","_content":"\n## [Program analysis](https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases)\n\nGitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？\n\n程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：\n\n1. 程序运行时所需要多少内存；\n2. 得到所有的 dependencies 并生成相应的 graph；\n3. call graph，所有的函数调用关系；\n4. control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；\n\n## [The Designer’s Growth Model](https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137)\n\nhttps://css-tricks.com/the-developers-growth-model/\n\n模仿 [Grenier](https://wiki.mbalib.com/wiki/葛雷纳的企业成长模型) groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：\n\n1. 第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；\n2. 第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；\n3. 第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；\n4. 第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；\n5. 第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；\n\n\n\n<!--more-->\n\n\n\n## [CSS Architecture — Folders & Files Structure](https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b)\n\nElad Shechter 介绍了他的 CSS 文件结构。\n\n## [How to Increase Your Page Size by 1,500% with webpack and Vue](https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/)\n\nBurke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 `main.js` 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。\n\n\n\n## [Blendle](https://launch.blendle.com)\n\n今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。\n\n它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。\n\n## [Matrix.org](https://matrix.org)\n\n一个开源的，e2e 加密，去中心化的 message 项目\n\n> The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I'm currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I'm working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there's no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.\n> — [comments from Hacker News](https://news.ycombinator.com/item?id=20157809)\n\n## Discoveries\n\n[Clippy - CSS clip-path maker](https://bennettfeely.com/clippy/)\n\n[Which programming language is fastest? | Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/)\n\n*Toy-program performance measurements for ~24 language implementations.*\n\n[Observable](https://observablehq.com) \n\n*JavaScript 版本的 Juypter*\n\n[Relearn CSS layout](https://every-layout.dev) \n\n*CSS layout*\n\n[jsPerf: JavaScript performance playground](https://jsperf.com) \n\n*比较不同 js 写法的性能*\n\n[Flutter - Beautiful native apps in record time](https://flutter.dev) \n\n*Google 推出的跨平台 UI 框架*","source":"_posts/阅读摘要-issue-3.md","raw":"---\ntitle: '阅读摘要 | issue #3'\ndate: 2019-07-12 17:33:53\ntags:\n---\n\n## [Program analysis](https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases)\n\nGitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？\n\n程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：\n\n1. 程序运行时所需要多少内存；\n2. 得到所有的 dependencies 并生成相应的 graph；\n3. call graph，所有的函数调用关系；\n4. control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；\n\n## [The Designer’s Growth Model](https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137)\n\nhttps://css-tricks.com/the-developers-growth-model/\n\n模仿 [Grenier](https://wiki.mbalib.com/wiki/葛雷纳的企业成长模型) groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：\n\n1. 第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；\n2. 第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；\n3. 第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；\n4. 第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；\n5. 第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；\n\n\n\n<!--more-->\n\n\n\n## [CSS Architecture — Folders & Files Structure](https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b)\n\nElad Shechter 介绍了他的 CSS 文件结构。\n\n## [How to Increase Your Page Size by 1,500% with webpack and Vue](https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/)\n\nBurke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 `main.js` 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。\n\n\n\n## [Blendle](https://launch.blendle.com)\n\n今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。\n\n它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。\n\n## [Matrix.org](https://matrix.org)\n\n一个开源的，e2e 加密，去中心化的 message 项目\n\n> The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I'm currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I'm working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there's no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.\n> — [comments from Hacker News](https://news.ycombinator.com/item?id=20157809)\n\n## Discoveries\n\n[Clippy - CSS clip-path maker](https://bennettfeely.com/clippy/)\n\n[Which programming language is fastest? | Computer Language Benchmarks Game](https://benchmarksgame-team.pages.debian.net/benchmarksgame/)\n\n*Toy-program performance measurements for ~24 language implementations.*\n\n[Observable](https://observablehq.com) \n\n*JavaScript 版本的 Juypter*\n\n[Relearn CSS layout](https://every-layout.dev) \n\n*CSS layout*\n\n[jsPerf: JavaScript performance playground](https://jsperf.com) \n\n*比较不同 js 写法的性能*\n\n[Flutter - Beautiful native apps in record time](https://flutter.dev) \n\n*Google 推出的跨平台 UI 框架*","slug":"阅读摘要-issue-3","published":1,"updated":"2019-07-12T09:53:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2d004crg1v54ylemcl","content":"<h2 id=\"Program-analysis\"><a href=\"#Program-analysis\" class=\"headerlink\" title=\"Program analysis\"></a><a href=\"https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases\">Program analysis</a></h2><p>GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？</p>\n<p>程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：</p>\n<ol>\n<li>程序运行时所需要多少内存；</li>\n<li>得到所有的 dependencies 并生成相应的 graph；</li>\n<li>call graph，所有的函数调用关系；</li>\n<li>control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；</li>\n</ol>\n<h2 id=\"The-Designer’s-Growth-Model\"><a href=\"#The-Designer’s-Growth-Model\" class=\"headerlink\" title=\"The Designer’s Growth Model\"></a><a href=\"https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137\">The Designer’s Growth Model</a></h2><p><a href=\"https://css-tricks.com/the-developers-growth-model/\">https://css-tricks.com/the-developers-growth-model/</a></p>\n<p>模仿 <a href=\"https://wiki.mbalib.com/wiki/%E8%91%9B%E9%9B%B7%E7%BA%B3%E7%9A%84%E4%BC%81%E4%B8%9A%E6%88%90%E9%95%BF%E6%A8%A1%E5%9E%8B\">Grenier</a> groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：</p>\n<ol>\n<li>第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；</li>\n<li>第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；</li>\n<li>第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；</li>\n<li>第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；</li>\n<li>第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；</li>\n</ol>\n<span id=\"more\"></span>\n\n\n\n<h2 id=\"CSS-Architecture-—-Folders-amp-Files-Structure\"><a href=\"#CSS-Architecture-—-Folders-amp-Files-Structure\" class=\"headerlink\" title=\"CSS Architecture — Folders &amp; Files Structure\"></a><a href=\"https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b\">CSS Architecture — Folders &amp; Files Structure</a></h2><p>Elad Shechter 介绍了他的 CSS 文件结构。</p>\n<h2 id=\"How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue\"><a href=\"#How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue\" class=\"headerlink\" title=\"How to Increase Your Page Size by 1,500% with webpack and Vue\"></a><a href=\"https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/\">How to Increase Your Page Size by 1,500% with webpack and Vue</a></h2><p>Burke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 <code>main.js</code> 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。</p>\n<h2 id=\"Blendle\"><a href=\"#Blendle\" class=\"headerlink\" title=\"Blendle\"></a><a href=\"https://launch.blendle.com/\">Blendle</a></h2><p>今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。</p>\n<p>它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。</p>\n<h2 id=\"Matrix-org\"><a href=\"#Matrix-org\" class=\"headerlink\" title=\"Matrix.org\"></a><a href=\"https://matrix.org/\">Matrix.org</a></h2><p>一个开源的，e2e 加密，去中心化的 message 项目</p>\n<blockquote>\n<p>The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I’m currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I’m working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there’s no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.<br>— <a href=\"https://news.ycombinator.com/item?id=20157809\">comments from Hacker News</a></p>\n</blockquote>\n<h2 id=\"Discoveries\"><a href=\"#Discoveries\" class=\"headerlink\" title=\"Discoveries\"></a>Discoveries</h2><p><a href=\"https://bennettfeely.com/clippy/\">Clippy - CSS clip-path maker</a></p>\n<p><a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/\">Which programming language is fastest? | Computer Language Benchmarks Game</a></p>\n<p><em>Toy-program performance measurements for ~24 language implementations.</em></p>\n<p><a href=\"https://observablehq.com/\">Observable</a> </p>\n<p><em>JavaScript 版本的 Juypter</em></p>\n<p><a href=\"https://every-layout.dev/\">Relearn CSS layout</a> </p>\n<p><em>CSS layout</em></p>\n<p><a href=\"https://jsperf.com/\">jsPerf: JavaScript performance playground</a> </p>\n<p><em>比较不同 js 写法的性能</em></p>\n<p><a href=\"https://flutter.dev/\">Flutter - Beautiful native apps in record time</a> </p>\n<p><em>Google 推出的跨平台 UI 框架</em></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Program-analysis\"><a href=\"#Program-analysis\" class=\"headerlink\" title=\"Program analysis\"></a><a href=\"https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases\">Program analysis</a></h2><p>GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？</p>\n<p>程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：</p>\n<ol>\n<li>程序运行时所需要多少内存；</li>\n<li>得到所有的 dependencies 并生成相应的 graph；</li>\n<li>call graph，所有的函数调用关系；</li>\n<li>control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；</li>\n</ol>\n<h2 id=\"The-Designer’s-Growth-Model\"><a href=\"#The-Designer’s-Growth-Model\" class=\"headerlink\" title=\"The Designer’s Growth Model\"></a><a href=\"https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137\">The Designer’s Growth Model</a></h2><p><a href=\"https://css-tricks.com/the-developers-growth-model/\">https://css-tricks.com/the-developers-growth-model/</a></p>\n<p>模仿 <a href=\"https://wiki.mbalib.com/wiki/%E8%91%9B%E9%9B%B7%E7%BA%B3%E7%9A%84%E4%BC%81%E4%B8%9A%E6%88%90%E9%95%BF%E6%A8%A1%E5%9E%8B\">Grenier</a> groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：</p>\n<ol>\n<li>第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；</li>\n<li>第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；</li>\n<li>第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；</li>\n<li>第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；</li>\n<li>第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；</li>\n</ol>","more":"<h2 id=\"CSS-Architecture-—-Folders-amp-Files-Structure\"><a href=\"#CSS-Architecture-—-Folders-amp-Files-Structure\" class=\"headerlink\" title=\"CSS Architecture — Folders &amp; Files Structure\"></a><a href=\"https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b\">CSS Architecture — Folders &amp; Files Structure</a></h2><p>Elad Shechter 介绍了他的 CSS 文件结构。</p>\n<h2 id=\"How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue\"><a href=\"#How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue\" class=\"headerlink\" title=\"How to Increase Your Page Size by 1,500% with webpack and Vue\"></a><a href=\"https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/\">How to Increase Your Page Size by 1,500% with webpack and Vue</a></h2><p>Burke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 <code>main.js</code> 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。</p>\n<h2 id=\"Blendle\"><a href=\"#Blendle\" class=\"headerlink\" title=\"Blendle\"></a><a href=\"https://launch.blendle.com/\">Blendle</a></h2><p>今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。</p>\n<p>它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。</p>\n<h2 id=\"Matrix-org\"><a href=\"#Matrix-org\" class=\"headerlink\" title=\"Matrix.org\"></a><a href=\"https://matrix.org/\">Matrix.org</a></h2><p>一个开源的，e2e 加密，去中心化的 message 项目</p>\n<blockquote>\n<p>The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I’m currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I’m working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there’s no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.<br>— <a href=\"https://news.ycombinator.com/item?id=20157809\">comments from Hacker News</a></p>\n</blockquote>\n<h2 id=\"Discoveries\"><a href=\"#Discoveries\" class=\"headerlink\" title=\"Discoveries\"></a>Discoveries</h2><p><a href=\"https://bennettfeely.com/clippy/\">Clippy - CSS clip-path maker</a></p>\n<p><a href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/\">Which programming language is fastest? | Computer Language Benchmarks Game</a></p>\n<p><em>Toy-program performance measurements for ~24 language implementations.</em></p>\n<p><a href=\"https://observablehq.com/\">Observable</a> </p>\n<p><em>JavaScript 版本的 Juypter</em></p>\n<p><a href=\"https://every-layout.dev/\">Relearn CSS layout</a> </p>\n<p><em>CSS layout</em></p>\n<p><a href=\"https://jsperf.com/\">jsPerf: JavaScript performance playground</a> </p>\n<p><em>比较不同 js 写法的性能</em></p>\n<p><a href=\"https://flutter.dev/\">Flutter - Beautiful native apps in record time</a> </p>\n<p><em>Google 推出的跨平台 UI 框架</em></p>"},{"title":"赤烛 - 『还愿』","date":"2019-02-23T03:18:14.000Z","_content":"\n\n\n『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。\n\n> 奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。\n>\n> --[『奇异的……』 Episode 32 - 硬影像](https://hardimage.pro/32)\n\n『还愿』同样是具有「奇情片」内核的恐怖游戏。\n\n以下内容涉及剧透。\n\n『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。\n\n<!--more-->\n\n> 以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。\n>\n> ...\n>\n> 此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。\n>\n> --wikipedia 美麗島事件\n\n「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。\n\n最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际~~游玩~~（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。\n\n![devotion](/images/Game/devotion.png)\n\n1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。\n\n> 台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。\n>\n> 电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。\n>\n> --『我们台湾这些年』\n\n也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。\n\n> 民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。\n>\n> --wikipedia 大家樂 (賭博) \n\n就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。\n\n父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。\n\n故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。\n\n母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。\n\n整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。\n\n\n\n参考\n\n- [『奇异的……』 Episode 32 - 硬影像](https://hardimage.pro/32)\n- 『我们台湾这些年』\n- [還願Devotion | 玩之前必知的七大民俗文化知識AdamDD](https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl%2Cwn)\n\n","source":"_posts/赤烛 - 『还愿』.md","raw":"---\ntitle: '赤烛 - 『还愿』'\ndate: \ntags: \n- 游戏\n- 故事\ncategories: \n---\n\n\n\n『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。\n\n> 奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。\n>\n> --[『奇异的……』 Episode 32 - 硬影像](https://hardimage.pro/32)\n\n『还愿』同样是具有「奇情片」内核的恐怖游戏。\n\n以下内容涉及剧透。\n\n『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。\n\n<!--more-->\n\n> 以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。\n>\n> ...\n>\n> 此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。\n>\n> --wikipedia 美麗島事件\n\n「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。\n\n最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际~~游玩~~（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。\n\n![devotion](/images/Game/devotion.png)\n\n1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。\n\n> 台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。\n>\n> 电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。\n>\n> --『我们台湾这些年』\n\n也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。\n\n> 民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。\n>\n> --wikipedia 大家樂 (賭博) \n\n就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。\n\n父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。\n\n故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。\n\n母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。\n\n整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。\n\n\n\n参考\n\n- [『奇异的……』 Episode 32 - 硬影像](https://hardimage.pro/32)\n- 『我们台湾这些年』\n- [還願Devotion | 玩之前必知的七大民俗文化知識AdamDD](https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl%2Cwn)\n\n","slug":"赤烛 - 『还愿』","published":1,"updated":"2019-02-23T03:18:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2d004frg1v6zwe4s9c","content":"<p>『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。</p>\n<blockquote>\n<p>奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。</p>\n<p>–<a href=\"https://hardimage.pro/32\">『奇异的……』 Episode 32 - 硬影像</a></p>\n</blockquote>\n<p>『还愿』同样是具有「奇情片」内核的恐怖游戏。</p>\n<p>以下内容涉及剧透。</p>\n<p>『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。</p>\n<p>…</p>\n<p>此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。</p>\n<p>–wikipedia 美麗島事件</p>\n</blockquote>\n<p>「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。</p>\n<p>最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际<del>游玩</del>（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。</p>\n<p><img src=\"/images/Game/devotion.png\" alt=\"devotion\"></p>\n<p>1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。</p>\n<blockquote>\n<p>台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。</p>\n<p>电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。</p>\n<p>–『我们台湾这些年』</p>\n</blockquote>\n<p>也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。</p>\n<blockquote>\n<p>民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。</p>\n<p>–wikipedia 大家樂 (賭博) </p>\n</blockquote>\n<p>就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。</p>\n<p>父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。</p>\n<p>故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。</p>\n<p>母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。</p>\n<p>整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://hardimage.pro/32\">『奇异的……』 Episode 32 - 硬影像</a></li>\n<li>『我们台湾这些年』</li>\n<li><a href=\"https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl,wn\">還願Devotion | 玩之前必知的七大民俗文化知識AdamDD</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。</p>\n<blockquote>\n<p>奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。</p>\n<p>–<a href=\"https://hardimage.pro/32\">『奇异的……』 Episode 32 - 硬影像</a></p>\n</blockquote>\n<p>『还愿』同样是具有「奇情片」内核的恐怖游戏。</p>\n<p>以下内容涉及剧透。</p>\n<p>『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。</p>","more":"<blockquote>\n<p>以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。</p>\n<p>…</p>\n<p>此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。</p>\n<p>–wikipedia 美麗島事件</p>\n</blockquote>\n<p>「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。</p>\n<p>最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际<del>游玩</del>（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。</p>\n<p><img src=\"/images/Game/devotion.png\" alt=\"devotion\"></p>\n<p>1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。</p>\n<blockquote>\n<p>台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。</p>\n<p>电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。</p>\n<p>–『我们台湾这些年』</p>\n</blockquote>\n<p>也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。</p>\n<blockquote>\n<p>民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。</p>\n<p>–wikipedia 大家樂 (賭博) </p>\n</blockquote>\n<p>就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。</p>\n<p>父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。</p>\n<p>故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。</p>\n<p>母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。</p>\n<p>整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。</p>\n<p>参考</p>\n<ul>\n<li><a href=\"https://hardimage.pro/32\">『奇异的……』 Episode 32 - 硬影像</a></li>\n<li>『我们台湾这些年』</li>\n<li><a href=\"https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl,wn\">還願Devotion | 玩之前必知的七大民俗文化知識AdamDD</a></li>\n</ul>"},{"title":"阅读摘要 | issues #1","date":"2019-05-31T11:44:37.000Z","_content":"\n## [Complex life may only exist because of millions of years of groundwork by ancient fungi](https://news.ycombinator.com/item?id=20039980)\n\n在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。\n\n## [Why specialization can be a downside in our ever-changing world](https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview)\n\n作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。\n\n<!--more-->\n\n## https://t.me/yifenshijie/2973\n\n[T. Greer](https://twitter.com/Scholars_Stage/status/1099238789363294208) 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：\n\n- blog 更专注内容，后者只期望于把用户留在自己的平台里；\n- blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；\n- blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；\n\n李如一看到这条 thread 后，[停止更新了他在 telegram 平台的「一分世界」](https://t.me/s/yifenshijie/2973)，认为要知行合一。\n\n## [霍洛维兹的欺骗](https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/)\n\nHorowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。\n\n> Apple Music 上，[在这里](https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029)可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），[这里](https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362)可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。\n\n以及这里给出网易云音乐的链接，方便收听。[edited](https://music.163.com/#/song?id=405318766) & [unedited](https://music.163.com/#/song?id=1298480910)。\n\n","source":"_posts/阅读摘要-issues-1.md","raw":"---\ntitle: '阅读摘要 | issues #1'\ndate: 2019-05-31 19:44:37\ntags:\n- 音乐\n---\n\n## [Complex life may only exist because of millions of years of groundwork by ancient fungi](https://news.ycombinator.com/item?id=20039980)\n\n在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。\n\n## [Why specialization can be a downside in our ever-changing world](https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview)\n\n作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。\n\n<!--more-->\n\n## https://t.me/yifenshijie/2973\n\n[T. Greer](https://twitter.com/Scholars_Stage/status/1099238789363294208) 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：\n\n- blog 更专注内容，后者只期望于把用户留在自己的平台里；\n- blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；\n- blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；\n\n李如一看到这条 thread 后，[停止更新了他在 telegram 平台的「一分世界」](https://t.me/s/yifenshijie/2973)，认为要知行合一。\n\n## [霍洛维兹的欺骗](https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/)\n\nHorowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。\n\n> Apple Music 上，[在这里](https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029)可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），[这里](https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362)可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。\n\n以及这里给出网易云音乐的链接，方便收听。[edited](https://music.163.com/#/song?id=405318766) & [unedited](https://music.163.com/#/song?id=1298480910)。\n\n","slug":"阅读摘要-issues-1","published":1,"updated":"2019-06-12T12:57:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm5cprx2d004irg1v5zwg4k7i","content":"<h2 id=\"Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi\"><a href=\"#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi\" class=\"headerlink\" title=\"Complex life may only exist because of millions of years of groundwork by ancient fungi\"></a><a href=\"https://news.ycombinator.com/item?id=20039980\">Complex life may only exist because of millions of years of groundwork by ancient fungi</a></h2><p>在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。</p>\n<h2 id=\"Why-specialization-can-be-a-downside-in-our-ever-changing-world\"><a href=\"#Why-specialization-can-be-a-downside-in-our-ever-changing-world\" class=\"headerlink\" title=\"Why specialization can be a downside in our ever-changing world\"></a><a href=\"https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview\">Why specialization can be a downside in our ever-changing world</a></h2><p>作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"https-t-me-yifenshijie-2973\"><a href=\"#https-t-me-yifenshijie-2973\" class=\"headerlink\" title=\"https://t.me/yifenshijie/2973\"></a><a href=\"https://t.me/yifenshijie/2973\">https://t.me/yifenshijie/2973</a></h2><p><a href=\"https://twitter.com/Scholars_Stage/status/1099238789363294208\">T. Greer</a> 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：</p>\n<ul>\n<li>blog 更专注内容，后者只期望于把用户留在自己的平台里；</li>\n<li>blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；</li>\n<li>blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；</li>\n</ul>\n<p>李如一看到这条 thread 后，<a href=\"https://t.me/s/yifenshijie/2973\">停止更新了他在 telegram 平台的「一分世界」</a>，认为要知行合一。</p>\n<h2 id=\"霍洛维兹的欺骗\"><a href=\"#霍洛维兹的欺骗\" class=\"headerlink\" title=\"霍洛维兹的欺骗\"></a><a href=\"https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/\">霍洛维兹的欺骗</a></h2><p>Horowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。</p>\n<blockquote>\n<p>Apple Music 上，<a href=\"https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029\">在这里</a>可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），<a href=\"https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362\">这里</a>可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。</p>\n</blockquote>\n<p>以及这里给出网易云音乐的链接，方便收听。<a href=\"https://music.163.com/#/song?id=405318766\">edited</a> &amp; <a href=\"https://music.163.com/#/song?id=1298480910\">unedited</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi\"><a href=\"#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi\" class=\"headerlink\" title=\"Complex life may only exist because of millions of years of groundwork by ancient fungi\"></a><a href=\"https://news.ycombinator.com/item?id=20039980\">Complex life may only exist because of millions of years of groundwork by ancient fungi</a></h2><p>在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。</p>\n<h2 id=\"Why-specialization-can-be-a-downside-in-our-ever-changing-world\"><a href=\"#Why-specialization-can-be-a-downside-in-our-ever-changing-world\" class=\"headerlink\" title=\"Why specialization can be a downside in our ever-changing world\"></a><a href=\"https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview\">Why specialization can be a downside in our ever-changing world</a></h2><p>作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。</p>","more":"<h2 id=\"https-t-me-yifenshijie-2973\"><a href=\"#https-t-me-yifenshijie-2973\" class=\"headerlink\" title=\"https://t.me/yifenshijie/2973\"></a><a href=\"https://t.me/yifenshijie/2973\">https://t.me/yifenshijie/2973</a></h2><p><a href=\"https://twitter.com/Scholars_Stage/status/1099238789363294208\">T. Greer</a> 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：</p>\n<ul>\n<li>blog 更专注内容，后者只期望于把用户留在自己的平台里；</li>\n<li>blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；</li>\n<li>blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；</li>\n</ul>\n<p>李如一看到这条 thread 后，<a href=\"https://t.me/s/yifenshijie/2973\">停止更新了他在 telegram 平台的「一分世界」</a>，认为要知行合一。</p>\n<h2 id=\"霍洛维兹的欺骗\"><a href=\"#霍洛维兹的欺骗\" class=\"headerlink\" title=\"霍洛维兹的欺骗\"></a><a href=\"https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/\">霍洛维兹的欺骗</a></h2><p>Horowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。</p>\n<blockquote>\n<p>Apple Music 上，<a href=\"https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029\">在这里</a>可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），<a href=\"https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362\">这里</a>可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。</p>\n</blockquote>\n<p>以及这里给出网易云音乐的链接，方便收听。<a href=\"https://music.163.com/#/song?id=405318766\">edited</a> &amp; <a href=\"https://music.163.com/#/song?id=1298480910\">unedited</a>。</p>"}],"PostAsset":[{"_id":"source/_posts/2024-summary/night.jpeg","slug":"night.jpeg","post":"cm5cprx220006rg1v9x489ph5","modified":0,"renderable":0},{"_id":"source/_posts/2023-summary/first-game.jpg","slug":"first-game.jpg","post":"cm5cprx210003rg1v7b0fcbqv","modified":0,"renderable":0},{"_id":"source/_posts/2023-summary/rye.jpeg","slug":"rye.jpeg","post":"cm5cprx210003rg1v7b0fcbqv","modified":0,"renderable":0},{"_id":"source/_posts/2023-summary/zelda.png","slug":"zelda.png","post":"cm5cprx210003rg1v7b0fcbqv","modified":0,"renderable":0},{"_id":"source/_posts/热病/drive-my-car.jpeg","slug":"drive-my-car.jpeg","post":"cm5cprx2c0047rg1v66cg2rrp","modified":0,"renderable":0},{"_id":"source/_posts/热病/tlou.jpeg","slug":"tlou.jpeg","post":"cm5cprx2c0047rg1v66cg2rrp","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cm5cprx220007rg1vaqug11qj","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx23000drg1v34gtg8lc"},{"post_id":"cm5cprx1z0001rg1v5716ayb2","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx24000hrg1vbxjc1d7h"},{"post_id":"cm5cprx220008rg1vc6b6gsvk","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx24000jrg1veni8fytj"},{"post_id":"cm5cprx23000brg1v1ycthl09","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx25000mrg1vee5z6rj5"},{"post_id":"cm5cprx210003rg1v7b0fcbqv","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx25000prg1vbk9j5yjk"},{"post_id":"cm5cprx23000crg1v1d8ka15e","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx25000trg1v9g8zd1ro"},{"post_id":"cm5cprx24000grg1v10rvav41","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx25000wrg1vg29bcury"},{"post_id":"cm5cprx220006rg1v9x489ph5","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx26000yrg1va7eoeunl"},{"post_id":"cm5cprx24000irg1vcf9q4ghq","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx260011rg1v2qnw4rfp"},{"post_id":"cm5cprx24000lrg1v06ehfj72","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx260013rg1vgmgdg7zi"},{"post_id":"cm5cprx25000org1v8kdmhwvv","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx260016rg1v4162av4f"},{"post_id":"cm5cprx25000srg1v47uedlmz","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx260019rg1v30mh64vh"},{"post_id":"cm5cprx25000xrg1v3v7beeyq","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx27001drg1v1hcq8itx"},{"post_id":"cm5cprx260010rg1vce46b1d8","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx27001grg1v96xme9a4"},{"post_id":"cm5cprx260012rg1v93cnf8s3","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx27001jrg1v6649adsx"},{"post_id":"cm5cprx260015rg1v6e994ti1","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx27001lrg1v9e0x4eaf"},{"post_id":"cm5cprx260018rg1v3z08d6x2","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx28001org1v0h6o0iz7"},{"post_id":"cm5cprx26001crg1vaggfavxk","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx28001rrg1vh5bf4mbr"},{"post_id":"cm5cprx27001frg1vdlwi8fik","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx28001vrg1vd33z9xm3"},{"post_id":"cm5cprx28001zrg1v66igb3nn","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx280024rg1vcd3e2xjm"},{"post_id":"cm5cprx2b003srg1v5mhrat8e","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx2c003yrg1v5bodgha8"},{"post_id":"cm5cprx2c003vrg1v6b2ahwnm","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx2c0043rg1v5kwg1b4r"},{"post_id":"cm5cprx2c0040rg1vgi4bevol","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx2d0048rg1vamb492uv"},{"post_id":"cm5cprx2c0045rg1vclzrhli1","category_id":"cm5cprx210004rg1v9o6fftos","_id":"cm5cprx2d004drg1v9rto1ocg"},{"post_id":"cm5cprx2c0047rg1v66cg2rrp","category_id":"cm5cprx230009rg1vgi8ba7zg","_id":"cm5cprx2d004grg1v3orugwpm"}],"PostTag":[{"post_id":"cm5cprx1z0001rg1v5716ayb2","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx25000nrg1v7y1g3ap3"},{"post_id":"cm5cprx1z0001rg1v5716ayb2","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx25000qrg1v0mh2ew35"},{"post_id":"cm5cprx1z0001rg1v5716ayb2","tag_id":"cm5cprx23000frg1v1vsv8i85","_id":"cm5cprx25000urg1vhulc6kza"},{"post_id":"cm5cprx210003rg1v7b0fcbqv","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx260017rg1vf1vjfwrf"},{"post_id":"cm5cprx210003rg1v7b0fcbqv","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx26001arg1vaw8c306d"},{"post_id":"cm5cprx210003rg1v7b0fcbqv","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx27001erg1vbsetfvpx"},{"post_id":"cm5cprx220006rg1v9x489ph5","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx28001prg1v3n9m3s9a"},{"post_id":"cm5cprx220006rg1v9x489ph5","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx28001srg1v0x5q8ras"},{"post_id":"cm5cprx220006rg1v9x489ph5","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx28001wrg1v3yy4gj6z"},{"post_id":"cm5cprx220007rg1vaqug11qj","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx280020rg1v4r77exs6"},{"post_id":"cm5cprx220007rg1vaqug11qj","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx280021rg1v75gc5dx5"},{"post_id":"cm5cprx220007rg1vaqug11qj","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx280023rg1v5jcv2q4y"},{"post_id":"cm5cprx28001zrg1v66igb3nn","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx280025rg1vgfvn73o4"},{"post_id":"cm5cprx28001zrg1v66igb3nn","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx290027rg1v3wip3d2a"},{"post_id":"cm5cprx28001zrg1v66igb3nn","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx290028rg1vfgsc9glr"},{"post_id":"cm5cprx220008rg1vc6b6gsvk","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002arg1vesjo4vq0"},{"post_id":"cm5cprx220008rg1vc6b6gsvk","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002brg1v23yb0fmy"},{"post_id":"cm5cprx220008rg1vc6b6gsvk","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx29002drg1v8kdm25jq"},{"post_id":"cm5cprx23000brg1v1ycthl09","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002erg1v29uh7ubi"},{"post_id":"cm5cprx23000brg1v1ycthl09","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002grg1vbxyw0brq"},{"post_id":"cm5cprx23000brg1v1ycthl09","tag_id":"cm5cprx23000frg1v1vsv8i85","_id":"cm5cprx29002hrg1vfhh4gcg6"},{"post_id":"cm5cprx23000crg1v1d8ka15e","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002jrg1va1yr2dmv"},{"post_id":"cm5cprx23000crg1v1d8ka15e","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002krg1v6rk9cbkj"},{"post_id":"cm5cprx23000crg1v1d8ka15e","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx29002mrg1v1zmyhxti"},{"post_id":"cm5cprx24000grg1v10rvav41","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002nrg1v72kua7et"},{"post_id":"cm5cprx24000grg1v10rvav41","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002prg1vfgx165tr"},{"post_id":"cm5cprx24000grg1v10rvav41","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx29002qrg1vg12w15k1"},{"post_id":"cm5cprx24000irg1vcf9q4ghq","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002srg1v49vtgu23"},{"post_id":"cm5cprx24000irg1vcf9q4ghq","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002trg1vbcjx8ip3"},{"post_id":"cm5cprx24000irg1vcf9q4ghq","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx29002vrg1v0ve73wsq"},{"post_id":"cm5cprx24000lrg1v06ehfj72","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx29002wrg1v8siye4k8"},{"post_id":"cm5cprx24000lrg1v06ehfj72","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx29002yrg1vgzk2eoq4"},{"post_id":"cm5cprx24000lrg1v06ehfj72","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx29002zrg1vfa9ph702"},{"post_id":"cm5cprx25000org1v8kdmhwvv","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx2a0031rg1vbe9u8te5"},{"post_id":"cm5cprx25000org1v8kdmhwvv","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx2a0032rg1vd5yh2l5h"},{"post_id":"cm5cprx25000org1v8kdmhwvv","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a0034rg1vd9roht1i"},{"post_id":"cm5cprx25000srg1v47uedlmz","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx2a0035rg1vhs17917s"},{"post_id":"cm5cprx25000srg1v47uedlmz","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2a0037rg1vb7km01yy"},{"post_id":"cm5cprx25000srg1v47uedlmz","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx2a0038rg1vg4zh3cvk"},{"post_id":"cm5cprx25000xrg1v3v7beeyq","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx2a003arg1vdhebh2hs"},{"post_id":"cm5cprx25000xrg1v3v7beeyq","tag_id":"cm5cprx29002urg1v1juzbrjg","_id":"cm5cprx2a003brg1v917b7p7y"},{"post_id":"cm5cprx260010rg1vce46b1d8","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2a003drg1v3y0hgxk5"},{"post_id":"cm5cprx260010rg1vce46b1d8","tag_id":"cm5cprx29002xrg1vco1l32ob","_id":"cm5cprx2a003erg1vhuzee22j"},{"post_id":"cm5cprx260012rg1v93cnf8s3","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003grg1v9fjv1yv6"},{"post_id":"cm5cprx260012rg1v93cnf8s3","tag_id":"cm5cprx2a0033rg1vckd26fwq","_id":"cm5cprx2a003hrg1vcz2s6cqn"},{"post_id":"cm5cprx27001irg1vd2vl0v8z","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003jrg1vdq6iantj"},{"post_id":"cm5cprx27001krg1v0c0u8xmc","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003krg1v7x7h5wbz"},{"post_id":"cm5cprx27001nrg1vb7asfy8b","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003lrg1vekudbg6f"},{"post_id":"cm5cprx28001qrg1vheoz20of","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx2a003nrg1v1yuadc0e"},{"post_id":"cm5cprx28001qrg1vheoz20of","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003org1v3hu09mfc"},{"post_id":"cm5cprx28001xrg1v53kzb6gp","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2a003prg1v3jnjehtd"},{"post_id":"cm5cprx28001xrg1v53kzb6gp","tag_id":"cm5cprx2a003irg1vb6f6gyo2","_id":"cm5cprx2a003qrg1vdjtjfvuh"},{"post_id":"cm5cprx28001xrg1v53kzb6gp","tag_id":"cm5cprx2a0033rg1vckd26fwq","_id":"cm5cprx2a003rrg1v6d042xvy"},{"post_id":"cm5cprx2b003srg1v5mhrat8e","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx2b003urg1vbgz5463q"},{"post_id":"cm5cprx2b003srg1v5mhrat8e","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2c003wrg1vd5yu99qr"},{"post_id":"cm5cprx2b003srg1v5mhrat8e","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx2c003zrg1v64bhbgxx"},{"post_id":"cm5cprx2b003trg1v303agc47","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2c0041rg1vf0un1mtq"},{"post_id":"cm5cprx2b003trg1v303agc47","tag_id":"cm5cprx2a003irg1vb6f6gyo2","_id":"cm5cprx2c0044rg1v1r4648hz"},{"post_id":"cm5cprx2b003trg1v303agc47","tag_id":"cm5cprx2a0033rg1vckd26fwq","_id":"cm5cprx2c0046rg1v6exb9tlw"},{"post_id":"cm5cprx2c003xrg1v22b1dk0t","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2d0049rg1v8e8cftv0"},{"post_id":"cm5cprx2c003xrg1v22b1dk0t","tag_id":"cm5cprx2a0033rg1vckd26fwq","_id":"cm5cprx2d004brg1vaqe278ug"},{"post_id":"cm5cprx2c0040rg1vgi4bevol","tag_id":"cm5cprx2a003irg1vb6f6gyo2","_id":"cm5cprx2d004erg1v9ttxc1x5"},{"post_id":"cm5cprx2c0040rg1vgi4bevol","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2d004hrg1v3vfoaoa4"},{"post_id":"cm5cprx2c0042rg1v3igld588","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2d004jrg1v8xgu6qkq"},{"post_id":"cm5cprx2c0042rg1v3igld588","tag_id":"cm5cprx29002xrg1vco1l32ob","_id":"cm5cprx2d004krg1vgkg61dus"},{"post_id":"cm5cprx2c0045rg1vclzrhli1","tag_id":"cm5cprx220005rg1vh2kx7bek","_id":"cm5cprx2d004lrg1vcao3byo2"},{"post_id":"cm5cprx2c0045rg1vclzrhli1","tag_id":"cm5cprx23000arg1v8cgl0x0l","_id":"cm5cprx2d004mrg1v585m9qxj"},{"post_id":"cm5cprx2c0045rg1vclzrhli1","tag_id":"cm5cprx28001trg1vb2r2aduf","_id":"cm5cprx2d004nrg1vd90b9p78"},{"post_id":"cm5cprx2c0047rg1v66cg2rrp","tag_id":"cm5cprx24000krg1vdw1r7hxr","_id":"cm5cprx2d004org1v4phu811u"},{"post_id":"cm5cprx2c0047rg1v66cg2rrp","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2d004prg1v119bgn9x"},{"post_id":"cm5cprx2c0047rg1v66cg2rrp","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx2d004qrg1v7b2tasn5"},{"post_id":"cm5cprx2d004frg1v6zwe4s9c","tag_id":"cm5cprx25000rrg1vh93570eb","_id":"cm5cprx2d004rrg1v52llhwtf"},{"post_id":"cm5cprx2d004frg1v6zwe4s9c","tag_id":"cm5cprx29002xrg1vco1l32ob","_id":"cm5cprx2d004srg1v89gkh22i"},{"post_id":"cm5cprx2d004irg1v5zwg4k7i","tag_id":"cm5cprx26000zrg1v0ktn0z78","_id":"cm5cprx2d004trg1vf0vp89q4"}],"Tag":[{"name":"Algorithm","_id":"cm5cprx220005rg1vh2kx7bek"},{"name":"codewars","_id":"cm5cprx23000arg1v8cgl0x0l"},{"name":"Python","_id":"cm5cprx23000frg1v1vsv8i85"},{"name":"电影","_id":"cm5cprx24000krg1vdw1r7hxr"},{"name":"游戏","_id":"cm5cprx25000rrg1vh93570eb"},{"name":"音乐","_id":"cm5cprx26000zrg1v0ktn0z78"},{"name":"JavaScript","_id":"cm5cprx28001trg1vb2r2aduf"},{"name":"Anime","_id":"cm5cprx29002urg1v1juzbrjg"},{"name":"故事","_id":"cm5cprx29002xrg1vco1l32ob"},{"name":"Front-end","_id":"cm5cprx2a0033rg1vckd26fwq"},{"name":"Node.js","_id":"cm5cprx2a003irg1vb6f6gyo2"}]}}