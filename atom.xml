<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>reyshawn.C</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reyshawn.com/"/>
  <updated>2023-12-31T16:14:58.199Z</updated>
  <id>http://reyshawn.com/</id>
  
  <author>
    <name>Reyshawn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>『別れの予感』</title>
    <link href="http://reyshawn.com/2023/12/30/2023-summary/"/>
    <id>http://reyshawn.com/2023/12/30/2023-summary/</id>
    <published>2023-12-30T03:46:14.000Z</published>
    <updated>2023-12-31T16:14:58.199Z</updated>
    
    <content type="html"><![CDATA[<p>今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。</p><blockquote><p>「说到邓丽君的代表作」<br>「很多粉丝会说〈何日君再来〉」<br>「〈再见我的爱人〉或〈我只在乎你〉」<br>「不瞒大家，其实我最喜欢这首」<br>- 老爸啊，到底想干什么呢？<br>- 干什么？<br>「请听邓丽君的〈别离的预感〉」<br>- 他自己的人生啊<br>- 我不知道，到最后还是搞不懂他<br>- 他很多事无法心想事成吧，都怪时代不好<br>- 他把自己的缺点都怪在时代上<br>- 你干嘛感慨良多<br>- 没有<br>- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。<br>- 我知道<br>- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐<br>- 也许吧<br>- 其实幸福这种东西，没有牺牲就无法入手<br>「比海还深，比天还蓝」<br>- 我到这把年纪了，还没有爱过谁比海还深的<br>- 别说这种孤僻话<br>- 你有吗？<br>- 我？<br>- 还算有吧<br>- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐<br>- 真复杂<br>- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊<br>- 不用啦  - 不然会忘记的<br>- 不用抄啦，我记住了</p><p>-- 『比海更深』</p></blockquote><span id="more"></span><h2 id="「死亡是一种解脱」"><a href="#「死亡是一种解脱」" class="headerlink" title="「死亡是一种解脱」"></a>「死亡是一种解脱」</h2><p>「死亡是一种解脱」，是炉石传说中 Lord Godfrey 高弗雷勋爵的登场语音，尽管炉石传说已经退出中国一年了，可是我时常会想起这句话。以及，还时常在微博上检索「离灯_冬眠mode关闭失败」这个关键词。</p><p>姥爷是三月份离开的。准确的时间是二〇二三年三月十六日。我是三月十日离开的深圳。</p><p>决定离开深圳，对自己而言并没有花太多时间。当时二月底离职，房屋面临到期，继续待下去，无疑要面对一边要找工作，一边要找房子的处境。姥爷从去年开始身体一直都不是很好， 二〇二二年底放开之后，又得了一次新冠，从那开始就一直卧病在床。</p><p>二〇一九年三月份来的深圳，在深圳待了有四年，下决定离开不过是一瞬间的事情。在网上购买几个大号的打包箱，胶带，泡沫。花一周的时间，把行李一点一点的寄回家。上一次这样做，还是二〇一六年大学毕业的时候。订了三月十日的机票，确定衣物啊，显示器啊，游戏机啊这些都寄走准备完毕，三月十日那天很早起床，收拾房间，背起背包，和室友在微信上说明原因并告别，然后一个人返乡。</p><p>回到家的第二天，我和妈妈回老家农村去照顾姥爷。那个时候，姥爷整日都只能躺在床上，床被放置在了客厅，上面盖了两层棉被，旁边开着电热风扇。三月份，农村依然很冷。那天我回到老家，我看到姥爷的眼神，我很清楚，姥爷什么都明白，什么都知道，只是没有力气，声音沙哑说不上话，也坐不起来。我和妈妈从三月十日待到了三月十五日。每晚我妈妈都是睡在姥爷旁别小床上，我舅舅睡在里屋的一个小硬板床上，两个人轮班照顾。那个小床后来我也睡了一晚，整晚都能听到姥爷咳嗽的声音，半夜两三点的时候，我听到姥姥也起来了，姥姥心疼不下姥爷一直咳嗽难受的样子，半夜起来看望姥爷，问姥爷哪里难受，帮姥爷揉肚子。两位老人都八十多岁了，那一晚我躺在偏里屋的小床上，整晚都没睡着，心里很难过。</p><p><strong>有时候，你会特别惧怕明天到来。</strong></p><p>姥爷的葬礼持续了三天，农村，红白喜事都特别复杂。葬礼结束那天我开始发烧。发烧持续了四天才好，那几天我一直在睡觉，做各种各样光怪陆离，魑魅魍魉的梦。</p><h2 id="2018-vs-2023"><a href="#2018-vs-2023" class="headerlink" title="2018 vs 2023"></a>2018 vs 2023</h2><p>2018 年我刚从德国回来的时候，计划着转行，也没有着急出去找工作，那会儿一整年都在家，看电影，打篮球，看书，写代码。</p><p>2023 年离开深圳再次回到家乡，熟悉的场景有些相似，又有些不同。只能说我对这种 gap year 的处境驾轻就熟，有着足够的经验去应对。之后的整个四月一直到五月中旬，自己的大部分时间都投入到了自己的个人项目中，偶尔时间出去打打篮球，偶尔放松的时候玩几局 splatoon，zelda: tears of the kingdom。</p><p>当你花上一周时间，解决了一些技术难题，把心中的想法实现出来的时候，不工作的焦虑感也会稍微消解，但这种消解总是暂时的，焦虑感却总会随着时间的推移越来越大。每晚都要熬到两三点钟才能睡着，在 live stream 中看几局 splatoon，有次还不小心听到某位 splatoon steamer 抱怨已经很久都没有去工作了。</p><h2 id="Bump-Version"><a href="#Bump-Version" class="headerlink" title="Bump Version"></a>Bump Version</h2><p>七月初面试确定，然后决定动身前往上海。</p><p>在家里待了接近四个月，经历了「清明」，「五一」，「端午」，线上观看了六月份 Apple WWDC，去了一次北京。</p><p>宝可梦系列中，小智每次在前往下一个新的区域的时候，都只是带上皮卡丘，把其他的宝可梦留在家里。</p><p><img src="rye.jpeg" alt="rye"></p><p>决定动身前往上海，做一次超大规模的「断舍离」，只带上一些必要的生活用品，电脑，平板，不必要的物件都暂时安置在家中。这样的场景，像极了购买了一款游戏续作，主角还是前作的主角，没有改变，只是这一次需要前往崭新的区域去冒险，去面对此前没有见过的，新的敌人。</p><p>在上海确定好工作事宜，花上周末两天时间去医院做体检，找房子。网络上下单必备的生活用品，纸巾，洗衣液，衣撑，枕芯等等。一切安置妥当不需要花太久的时间。晚间时分在住的地方附近逛一逛，熟悉一下周边的环境和风景。我在 IM 软件中联系在上海的同学，告诉他们我从深圳换到上海这边工作了，有时间可以出来见一面，叙叙旧。</p><p>自己以前总是对未来有着明确的期许，有着可能划分到每一天的明确的计划。但我现在不这样，很多事情并不是事先计划好的，无论是当初去到深圳，离开深圳，还是再次去上海，我都没有明确的规划。只是刚好有什么东西在推着我，好吧，去那里看看吧，去那里也不差。</p><p>二〇二三年的下半年，七月到十二月，时间过得很快。自己又回到了之前那个，周一至周五，挤地铁上班，写代码，周末以及下班回家写写个人项目，或是玩一玩游戏的生活状态。和友人开玩笑，如果周末一直宅在家里，甚至都没有自己是生活在上海的感知，很多大体上的事情都和深圳其实差别不大，其他可感知的区别可能在于饮食，文化。上海这边每个月都有好多的展览可以逛。</p><p>今年自己经历了蛮多的事情的，姥爷的去世其实自己心里早有预期，但还是内心会有些恍惚。因为这不是在看电影，看电影的时候总会安慰自己，一个角色总会在某个时候展现人物弧光和升华。但现实不是拍电影演电影讲故事，现实就是现实，没有来自导演意志的因果叙事逻辑。心里的难过情绪，在姥爷葬礼被我自己压制着的。但这种压抑，会在以后生活中某个不经意的细节，因为某些不经意的片段，会让我突然想到过去一些回忆，然后就突然止不住的，怎么也停不下来的大哭。</p><blockquote><ul><li>Wait… what happened?</li><li>[<em>sadly</em>] He’s been forgotten. When there’s no one left in the living world who remembers you, you disappear from this world. We call it the Final Death.</li><li>Where did he go?</li><li>No one knows.</li></ul><p>– Coco</p></blockquote><p>我忽然理解，为什么侯孝贤导演安排聂隐娘哭泣的时候，需要用布遮住面部。</p><p>以下是按照惯例的盘点内容。</p><h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><h3 id="PlayStation"><a href="#PlayStation" class="headerlink" title="PlayStation"></a>PlayStation</h3><ul><li>The Last of Us™ Part II Remastered - 2023.01.30</li><li>Baldur’s Gate 3 - 109 hours</li><li>It Takes Two</li></ul><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><ul><li>Splatoon™ 3</li><li>ゼルダの伝説 ティアーズ オブ ザ キングダム</li><li>Persona 4 Golden</li></ul><p>二月末三月初离职的那段时间，自己每天一边打包行李，一边把 The Last of Us™ Part II 通关了。这部作品在网络上有着很大的争议，但我总想，一部游戏，至少需要我亲自玩过，我才有资格去评价它。 The Last of Us Part I 主题是很普世价值的「爱」，讲 Joel 和 Ellie 在末世之中，从相互陌生到互相信任，这个叙事逻辑是安全的，玩家也很容易接受。Part II 的主题却是「恨」。它在叙事上走得太超前了，至少我在玩过以后，我认为它是目前迄今为止在玩过的所有游戏中，叙事最超前最先锋的。我始终认为，不管是听音乐的听众，还是看电影的观众，或是玩游戏的玩家，审美品味都是需要一点一点训练和培养的。几十年前的电影观众可能还只是陶醉在正反对立的二元叙事语境，然后电影叙事在不断进化，开始模糊，反讽，辩证，蒙太奇。观众在这个过程也是在不断地训练和品鉴。我认为作为第九艺术的游戏也是这样。The Last of Us Part II 遭受的巨大争议，专业媒体评论者和普通玩家的巨大分歧，是大多数玩家思考游戏叙事还停留在「勇者斗恶龙」的体系下。</p><p>The Last of Us Part II 的双线视角叙事，真的只有亲自玩过才能体会游戏和电影不同媒介叙事的巨大差异。电影始终是以第三者的角度去审视故事，而游戏需要玩家去交互，去操作，去亲自做出选择。强制完全控制带入一个陌生的，让很多人第一眼开始就讨厌的角色，是很困难的。我自己也是，所以我在第一次控制 Abby 的时候，故意让她摔下悬崖好几次。等到玩完整个 Abby 线的时候，我对 Abby 的看法已经改变了好多，这种体会，亲自游玩和在网络上看别人剪辑过的游玩过程会有很大区别，因为当你亲自游玩时，你会在很多地方卡关，你控制 Abby 角色会一遍遍的死亡重新来过，这些内容都会慢慢消解对于 Abby 角色的恨。而如果是在网络上看别人游玩，因为是剪辑过的内容，就没有这种感受了。</p><img src="first-game.jpg" width="300px" style="display: block;margin: 0 auto;"><p>Persona 4 Golden 中能看出很多 P5 的影子，有几首音乐特别好听，另外就是「久慈川理世」这个角色设定太有魅力了。</p><p>五月份自己心心念念的 『ゼルダの伝説 ティアーズ オブ ザ キングダム』（ 薩爾達傳說 王國之淚 ）发售了。有两周的时间，自己除了吃饭就是在玩塞尔达。很多人评论这一作神庙的谜题难度降低了，但其实我想一个原因是这作的能力「通天术」和「倒转乾坤」相比上一部都强了不少，另外就是这一作把很多的谜题都设置在了大地图上。我现在还能记得自己不看攻略再一次成功抵达迷雾森林，推理出格鲁德小镇的壁画谜题。半夜两三点，自己躺在被窝中，摸着黑下到地底，朝着远处的一个光亮一点点探索，那种对整片海拉鲁大陆熟悉又陌生，每处地方都能激发出很强的探索欲，这样的感受是很难得的。</p><p><img src="zelda.png" alt="zelda"></p><p>八月份的时候大家都开始讨论 Baldur’s Gate 3，都在讲它太惊艳了。我是等到十月份才开始玩这款游戏。CRPG 的游戏是有一定的门槛，有很多的专业术语，眼花缭乱的技能设定，专项，魔法，机制等等。好在游戏的引导设计足够好，了解这些内容并不会很吃力。目前我 Baldur’s Gate 3 玩了 109 个小时，进度还停留在一周目的第三章。我理解这游戏好玩的点在哪，但是因为剧情自由度太高了，总是不经意就错过好多内容。（ 一周目因为第一章没有招威尔入队，导致丢失了后面所有的威尔相关剧情 ）。</p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>今年听到的好听的音乐依旧大多数来自于游戏原声（ 因为今年依旧看很少的电影 ）</p><p><a href="https://music.apple.com/us/playlist/replay-2023/pl.rp-kDD5sedLQbl">Replay 2023 - Apple Music for Reyshawn</a></p><ul><li>Song of Balduran - Borislav Slavov</li><li>Can’t Take My Eyes Off You - Joytastic Sarah</li><li>SNOWFLAKES ( powder snow mix ) - Shihoko Hirata</li></ul><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ul><li>『天国大魔境』</li><li>『名侦探柯南：黑铁的鱼影』</li></ul><p>『天国大魔境』，动漫和漫画都强烈推荐，叙述性诡计，伏笔布局都相当精彩。</p><p>六月份的时候由于太过焦虑，花了一周的时间，就重新把整部『柯南』漫画重新看了一遍。我对这部作品有着很强的情感滤镜，因为小时候真的特别特别喜欢。现在随着阅历的加深，我也很清楚这部作品叙事还是人物塑造上存在的问题，但有时候关注一些相关的内容，<strong>会有一种逃离现实的安全感</strong>。</p><p>另外值得一提的是，终于搞定了 Netflix 订阅，之前付款总是失败，然后今年不清楚又试了一次竟然就付款成功了。目前在 Netflix 只是补了 『黑镜』。</p><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>又是没怎么系统性看完完整一本书的一年（ 想到了 2021 年 ）。去年闲暇时开始看『金瓶梅』，只是看了前二十个章节。又重新去读村上的『一九七三年弹子球』也是读到一半，没有读完。</p><p>技术类书籍也没怎么去读，不过倒是看了不少 third library 的源码，web 和 iOS 都有包括。</p><h2 id="时刻"><a href="#时刻" class="headerlink" title="时刻"></a>时刻</h2><p>今年很多值得铭记的时刻，是自己花了很大精力解决了一些技术难题，包括但不限于</p><ul><li>iOS Page Sheet 多段式动画实现</li><li>twitter-like profile page ( tabs with sticky header )</li><li>Transition Component in React</li><li>fragment shader 实现无限网格</li><li>3d line geometry 优化 ( 更少的 vertices )</li></ul><h3 id="推导-Quaternion"><a href="#推导-Quaternion" class="headerlink" title="推导 Quaternion"></a>推导 Quaternion</h3><p>花了一个晚上的时间，按照论文上的步骤，一步一步在 iPad 手写演算进行推导。其中涉及到了一些点乘，叉乘的化简运算，叉乘运算又极其繁琐，加之论文其实省略了一些推导步骤的。不过好在自己最后算对了，算出结果那一刻真的好开心，又感叹发明 Quaternion 来进行 3d 旋转运算的人，真的好厉害！</p><h3 id="拯救暗夜之歌"><a href="#拯救暗夜之歌" class="headerlink" title="拯救暗夜之歌"></a>拯救暗夜之歌</h3><p>我认为 Baldur‘s Gate 3 整个第二章都特别精彩，高潮部分在「拯救暗夜之歌」，演出相当震撼。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>新的城市，新的工作，新的同事。对未来没有太多期许。每周二或周三工作日的晚上去打一场篮球，大汗淋漓之后喝上一杯冰镇的可乐。回到家里再冲上一个热水澡。生活相比以前，有了一些细微的改变。我不清楚，也不去想，不去期许五年十年后的事情，仅以这些文字，纪念即将过去的二〇二三。</p><p>🌻</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年发生了很多事，告别了一些人，也认识了新的朋友，有些说大不大，说小不小的改变，无论是我，还是这个世界。大概是一个月之前就开始构思这篇文章，然后花上两到三天的时间整理链接，图片，文字和回忆。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;「说到邓丽君的代表作」&lt;br&gt;「很多粉丝会说〈何日君再来〉」&lt;br&gt;「〈再见我的爱人〉或〈我只在乎你〉」&lt;br&gt;「不瞒大家，其实我最喜欢这首」&lt;br&gt;- 老爸啊，到底想干什么呢？&lt;br&gt;- 干什么？&lt;br&gt;「请听邓丽君的〈别离的预感〉」&lt;br&gt;- 他自己的人生啊&lt;br&gt;- 我不知道，到最后还是搞不懂他&lt;br&gt;- 他很多事无法心想事成吧，都怪时代不好&lt;br&gt;- 他把自己的缺点都怪在时代上&lt;br&gt;- 你干嘛感慨良多&lt;br&gt;- 没有&lt;br&gt;- 你现在把那柱香当成你爸了吧，人走了之后，再思念都是枉然，还是得在人在的时候，好好对待才行。&lt;br&gt;- 我知道&lt;br&gt;- 为什么男人们都学不会珍惜当下，总是在追逐失去的东西，做着那些虚妄而无法实现的梦，把自己困住，每天怎么会快乐&lt;br&gt;- 也许吧&lt;br&gt;- 其实幸福这种东西，没有牺牲就无法入手&lt;br&gt;「比海还深，比天还蓝」&lt;br&gt;- 我到这把年纪了，还没有爱过谁比海还深的&lt;br&gt;- 别说这种孤僻话&lt;br&gt;- 你有吗？&lt;br&gt;- 我？&lt;br&gt;- 还算有吧&lt;br&gt;- 一般人不会有的啦，但还是每天过得开开心心。不对，就是没有才过得开心，平凡的生活也能自得其乐&lt;br&gt;- 真复杂&lt;br&gt;- 单纯得很，人生很单纯的。我刚讲了很棒的名言吧。借你写到下一本小说里。阿良，笔记一下啊&lt;br&gt;- 不用啦  - 不然会忘记的&lt;br&gt;- 不用抄啦，我记住了&lt;/p&gt;
&lt;p&gt;-- 『比海更深』&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
      <category term="电影" scheme="http://reyshawn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>热病</title>
    <link href="http://reyshawn.com/2022/12/31/%E7%83%AD%E7%97%85/"/>
    <id>http://reyshawn.com/2022/12/31/热病/</id>
    <published>2022-12-31T03:35:10.000Z</published>
    <updated>2022-12-31T15:10:04.089Z</updated>
    
    <content type="html"><![CDATA[<p>在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。</p><p>战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。</p><p>我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。</p><p>这是关于发烧，最神奇的一次经历。</p><span id="more"></span><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><ul><li><a href="https://www.playstation.com/en-us/games/the-last-of-us-part-i/">The Last of Us™ Part I</a> | PlayStation 5</li><li><a href="https://www.nintendo.com.hk/switch/az3ha/">Xenoblade Chronicles™ 3</a> | Nintendo Switch</li><li><a href="https://www.nintendo.com/store/products/xenoblade-chronicles-2-switch/">Xenoblade Chronicles™ 2</a> | Nintendo Switch</li><li><a href="https://www.nintendo.co.jp/switch/av5ja/index.html">スプラトゥーン3</a> | Nintendo Switch</li><li><a href="https://en.bandainamcoent.eu/elden-ring/elden-ring">Elden Ring</a> | PlayStation 5</li><li><a href="">Detroit: Become Human</a> | PlayStation 5</li></ul><p>The Last of Us™ Part I 是我今年玩到的游戏中，带给我无限感伤的游戏。游戏的总体流程不长，线性关卡，有些许的解谜要素，战斗部分在重制版中，加入了陀螺仪瞄准和 ps5 手柄的适配。游戏通关后，自己又去重新听了三年前 Hard Image 的两期播客：</p><ul><li><a href="https://hardimage.pro/episodes/76">Episode 76: The Last of Us：故事的意义与元素（一）</a></li><li><a href="https://hardimage.pro/episodes/77">Episode 77: The Last of US：故事的意义与元素（二）</a></li></ul><blockquote><p>冗长的感想主要集中在故事的讲法，性格如何塑造，以及对不可知做法的一些想象。</p></blockquote><p>以前就经常和其他人讲，游戏之所以能够在艺术表达上高于电影等艺术媒介，因为游戏比电影多了一层「交互」的维度。然而真正能把「交互」这一维度用好的游戏叙事却很少，但恰恰 The Last of Us™ Part I 算是这么一部作品。其中有很多设计都很精巧，比如主角 Joel 被绳子吊起来，整个屏幕视角上下颠倒，然后要在这样一种状态下保护 Ellie。以及 Joel 和 Ellie 被突如其来的意外事件分开，经历险阻为 Ellie 的第一次开抢埋下伏笔。一些场景至今想起依然难以释怀，第一次陪着 Ellie 穿越酒店，在一间一间房间中经过时，看到浴室里的相对而坐的骷髅，它们临死的前一刻在想些什么呢。在后来的大学场景中，和 Ellie 一起走过学生宿舍，你能看到下午三点半的阳光，透过窗子打在了学生宿舍的书桌上，上下铺的床铺上积了很厚的一层灰尘，墙上还挂着当时流行的游戏海报，书柜中几本书，还有几盒游戏。后来到了一个临时的地下避难所，这里不久之前明明就有幸存者，周边的玩具，黑板也证明了有小孩子在这里生活。然后因为一次意外，里面的幸存的人都不见了踪影。</p><p>游戏手法的高明之处，就在于他把上述作者想要表达的内容，传递的情感，透过游戏场景，剧情设计，关卡设计给到玩家，最后由玩家亲自去经历，去体验这样的一个末日故事。</p><p><img src="tlou.jpeg" alt="tlou"></p><p>「异度之刃2」很早就买了，21 年元旦的时候沉迷过一段时间，后来因为别的事情不了了之，就搁置了。今年是因为「异度之刃3」要发售，就赶紧把「异度之刃2」拿出来，给通关了。七月份的时候通的关，那一天为了一口气看到最后的剧情，一直熬到了凌晨四点。</p><p>「异度之刃3」整体上游玩体验还是很不错的，游戏的整体机制，寻路系统，英雄任务等等，相比前作都是巨大的提升。可能唯一不太舒服的是后半段的节奏问题，在世界观展开以后就突然急转直下，反派也都太过脸谱化。导致最后的 boss 战也没有太多亮眼的地方。</p><p>Splatoon3 可以算上十月份以来，游玩时间最长的游戏。此前的自己唯一接触过的射击游戏就是 CS，那还是十几年前的的事情。Splatoon 作为一款 TPS ( 第三人称射击游戏 ) 真的很独特。从玩法，到设计，再到创意，都是独一无二。赞叹任天堂的想象力。</p><p>Elden Ring 我到最后也没有玩完，大概是玩到王城下水道那个地方，玩不下去了。此前从没有过任何魂游戏的经验，导致我刚开始玩 Elden Ring 时，甚至新手村都出不去。后来找了一个攻略，就想着按照攻略玩，但那样每一步都按照攻略走，就完全丧失了玩游戏的意义。到后来就索性不去玩了。也许以后会有某个契机，把剩余的内容玩完。</p><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><ul><li>Can’t Take My Eyes Off You - Joytastic Sarah</li><li>The Last of Us - Gustavo Santaolalla</li><li>The Path ( A New Beginning) - Gustavo Santaolalla</li><li>The Choice - Gustavo Santaolalla</li><li>All Gone - Gustavo Santaolalla</li><li><a href="https://www.youtube.com/watch?v=4hqSSb5rPE0">Moebius Battle</a></li></ul><p>其中的很多首都是出自 The Last of Us™ Part I 游戏中的配乐。</p><h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><p><img src="drive-my-car.jpeg" alt="drive-my-car"></p><ul><li>『钛』</li><li>『间谍之妻』</li><li>『坏小子』</li><li>『黑客帝国』</li><li>『驾驶我的车』</li><li>『鬼灭之刃』</li><li>『反叛的鲁鲁修』</li><li>『死亡笔记』</li><li>『冰菓』</li><li>『春风沉醉的夜晚』</li><li>『旺角卡门』</li><li>『弥留之国的爱丽丝 第二季』</li></ul><p>今年并没有很认真地去标记电影了，主要是因为自己在写自己的 app，也就没有很大的动力再去打开 douban。看了很多动漫，有一些没有标记上。</p><h1 id="书"><a href="#书" class="headerlink" title="书"></a>书</h1><p>技术类</p><ul><li>iOS Animations by Tutorials</li><li>iOS 15 Programming for Beginners</li><li>Advanced iOS App Architecture</li><li>Design Patterns By Tutorials</li><li>Core Data by Tutorials</li></ul><p>非技术类</p><ul><li>斯普特尼克恋人</li><li>没有女人的男人们</li><li>神的孩子全跳舞</li></ul><h1 id="时刻"><a href="#时刻" class="headerlink" title="时刻"></a>时刻</h1><p>今年有很多神奇的时刻和神奇的故事，比如蛰伏一年，Golden State Warriors 终于又重新回到季后赛，过五关斩六将，杀到总决赛，在 6 月 17 日这天终于捧杯，Steph Curry 也终于拿下了 FMVP。</p><p>比如 Messi 的故事也终于圆满，成为了传奇。</p><p>后来发现，小智也在这一年拿到了属于他的冠军。</p><h3 id="xiaolwl"><a href="#xiaolwl" class="headerlink" title="@xiaolwl"></a>@xiaolwl</h3><p>今年的很多时候，我会去看 @xiaolwl 生前最后一条微博下面的评论。我感觉那里的评论是真实的。</p><h3 id="炉石停服"><a href="#炉石停服" class="headerlink" title="炉石停服"></a>炉石停服</h3><p>14 年炉石刚开始的时候，是主打 iPad 上的卡牌游戏，当时的手边刚好有一台 iPad mini2，就不知不觉上手了。但当时只是玩了一段时间之后就不玩了。一直到 2018 年，当时的自己阴差阳错，机缘巧合又再次打开炉石，一直玩到了现在。炉石可以算做陪伴我走过了很长一段低谷的游戏。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大概在一周以前，平安夜那晚。自己突然感觉身体不适，看了一下 Apple Watch，明明是静坐，心率却一直在 100 上下，摸了摸额头，额头也烫的厉害。心想，大概率是感染了。那一天晚上很痛苦，躺在床上翻来覆去睡不着，身体发烫，心脏也跳的很快，能清楚听到心脏每一次跳动的的声音，还伴随着心绞痛。想着时间快快过去吧，快点跳到早上，好出去买药。可时间却走的无比缓慢，从十二点到一点，从一点到两点，从两点到三点。最后挨到五点钟的时候，起床烧了一壶水，坐在椅子上，半闭着双眼，轻瞥到 Apple Watch 上的心率依然在 100 上下。然后我大概就是那样半躺着靠着椅背，一直挨到七八点钟，出门买药。</p><p>从小到大，有过几次发烧，但都没有这次来得这么凶猛猛烈。希望之后能慢慢恢复过来，希望爸爸妈妈，身边的亲人也都身体健康。</p><p>🌻</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多时候，我都感觉像是回到了 2019 年的那个十月。我能清楚听到直升飞机在我头顶盘旋着呼啸而过。就像，历史的车轮从身边碾过一样。兵荒马乱，沧海桑田。&lt;/p&gt;
&lt;p&gt;战争，全球范围下的疫情，刺杀，游行，第三任期。所有的恐惧是来自种种的不真实感，像是真人 show，或是被人编排好了剧本，充满戏剧性，夸张，难以言说的巧合，阳谋。顺着这样一条线索最终走向宇宙洪荒，或是世界末日。&lt;/p&gt;
&lt;p&gt;我想起上高中的时候，忘记是高一还是高二，也忘记是临近暑假还是寒假，总之是临近假期的期末考试，自己在宿舍里头晕脑胀，量了体温以后发现烧到了 38 摄氏度，身边的室友都劝我下午不要去考试了。我想了想，不行，不能弃考。下午考试还是过去了，那是一场物理考试，那次的物理试题出的又比较偏，题目难度也很大。我不知道是不是因为我发烧的缘故，总之那次考试过程，自己的思路竟然异常清晰。最后的考试结果，我是那次物理考试中唯一一个上了 80 分的人，我自己都有点难以相信。&lt;/p&gt;
&lt;p&gt;这是关于发烧，最神奇的一次经历。&lt;/p&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
      <category term="电影" scheme="http://reyshawn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Fly Me to the Moon</title>
    <link href="http://reyshawn.com/2021/12/31/Fly-Me-to-the-Moon/"/>
    <id>http://reyshawn.com/2021/12/31/Fly-Me-to-the-Moon/</id>
    <published>2021-12-31T01:47:59.000Z</published>
    <updated>2022-01-01T02:11:23.405Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/zelda-botw.jpg" alt="zelda-botw"></p><p>6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。</p><p>但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，</p><blockquote><p>哎，又到了此刻。</p></blockquote><span id="more"></span><h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><ul><li><a href="https://www.playstation.com/zh-hans-hk/games/persona-5-royal/">女神异闻录5 皇家版</a> | PlayStation 5</li><li><a href="https://www.nintendo.com/games/detail/metroid-dread-switch/">Metroid™ Dread</a> | Nintendo Switch</li><li><a href="http://asia.sega.com/megaten5/cht/">真・女神轉生V</a> | Nintendo Switch</li></ul><p><em>以上列表按照喜好顺序排名。</em></p><p>七夕节的那天收到 PS5，第一时间便入手了 P5R，从 8 月份到 9 月中旬，把自己所有的空闲时间都投入了进去。现代背景，荣格心理学，东京涩谷。日式 rpg 的框架下，种种设定让代入感过于强烈，以至于某些时刻，我仿佛真的回到了学生时代。挤地铁，上课，考试，看书，和一帮小伙伴嬉笑打闹。</p><p>因为以前的学生时代，和现在真的有很大不同。经常一帮人一起玩某个游戏，一起打篮球。所以那天 p5r 一周目通关，想了一下，是时候约好友出来见一面聊聊天了。大家平日工作都很忙，虽然在同一个城市，但好久都没见面了。</p><blockquote><p>『女神异闻录』攻略到「回忆」部分结束，剧情的反转设计，和游戏交互上给人带来的沉浸感简直太棒了。几处伏笔并没有意识到，剧情上带来的合理性也让我没有太多思考，只是感到奇怪。使用的手法完全想不出来，太绝妙了。太久没有过这种「啊，竟然是这样，被骗了」这种感觉了。</p><p>完全没有想过黑衣人会是「认识的人」。倒叙的故事结构，因为药物而部分记忆丢失，通过只言片语的提示，让玩家和主角一起绞尽脑汁去回忆究竟是哪里出了问题，这样的设计，沉浸感和代入感太棒了。</p></blockquote><p><img src="/images/p5r-ending.png" alt="p5r-ending"></p><p>Metroidvania，一种游戏类型，中文翻译为「类银河战士恶魔城」，分别来自两款游戏，其一便是任天堂旗下的『密特罗德』，另一款是科樂美的『恶魔城』系列。之前玩过同类型的『奥日 1&amp;2』，非常喜欢。对这一部也是期待了很久，也最终没有让我失望。20 多小时一周目通关，几个印象深刻的点是</p><ul><li>精巧的地图设计；</li><li>超级复杂的按键；</li><li>非常爽快的动作体验；</li><li>破序玩法</li></ul><p>自己通关会去看了相关的速通视频，才知道原来这系列一直有着「破序玩法」的传统。</p><p><img src="/images/metroid.png" alt="metroid"></p><p>因为玩过了 P5R，对于 ATLUS 这套神魔体系有所了解。比如「吉祥天」「爱丽丝」等等这些经典的形象。当本家新一作「真女神转生」发布的时候，很自然就第一时间入手了。初期的时候还是有很多不适应，直到我去买了 dlc，整个的游戏体验就好很多了。和外传不一样，本传的气质挺像『恶魔人Crybaby』的。大地图迷宫，战斗设计都非常精彩。唯一缺憾的可能还是 Switch 的机能。不时的卡顿，掉帧，和流畅，绚烂，不羁的 P5R 比起来，似乎还是差了一个时代。</p><p><img src="/images/shin-megami-tensei-v.png" alt="shin-megami-tensei-v"></p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><ul><li>Can’t Take My Eyes Off You - Joytastic Sarah</li><li>Another Day of Sun - La La Land Cast</li><li>Fly Me to the Moon - The Macarons Project</li><li>Happy Birthday ( Single Version Remix ) - Kyoko</li><li>On the Nature of Daylight - Max Richter</li></ul><p><a href="https://music.apple.com/us/playlist/replay-2021/pl.rp-6xxXTlPZDQL">Replay 2021 - Apple Music for Reyshawn</a></p><p>Joytastic Sarah 算是一个惊喜，在 YouTube 上有她的<a href="https://www.youtube.com/c/JoytasticSarahCovers">频道</a>，她的一些翻唱和混音真的非常好听。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>豆瓣记录里，今年总共看了 33 部电影。相比于去年的 13 部，提高了不少。有一些是周末的时候去到一个线下小众观影俱乐部看的。年初那会儿，有段时间每周末都过去。</p><ul><li>『金都』</li><li>『无间道』三部曲</li><li>『城市之光』</li><li>『偶然与想象』</li><li>『鱿鱼游戏』</li><li>『新·福音战士剧场版：终』</li><li>『弥留之国的爱丽丝』</li></ul><p>大部分的观影记录集中在了上半年。现在回想起来，看剧的时刻真的非常美妙。花上一下午或一个晚上，binge-watching 的去看整部剧。六七点钟时叫一家附近的披萨和冷饮。</p><p>因为『鱿鱼游戏』，之后又去看了『弥留之国的爱丽丝』。</p><p>16 年那会儿开始看 EVA，那个时候毕业，放假在家，一边学习德语，一边看剧，看电影。那段时间把 EVA 所有的 TV 剧集，旧剧场版，新剧场版的前三部都看完了。我至今都清楚得记得我当时看新剧场版『Q』的时刻，自己一个人坐在大大客厅沙发上，面对红的一片的屏幕。绫波丽缓缓的走来，明日香开始骂碇真嗣。镜头拉远，三个人就这样慢慢在空无一人红色大地上缓慢走着。</p><p><img src="/images/eva-1.png" alt="eva-1"></p><p><img src="/images/eva-2.png" alt="eva-2"></p><p><img src="/images/eva-3.png" alt="eva-3"></p><p><img src="/images/eva-4.png" alt="eva-4"></p><p>即便是在等待了 5 年之后，看完了『新剧场版：终』。对于其他 EVA 粉丝，这个等待时间更久。在我心里，给我最大震撼和感动的还是来自『新剧场版：破』。在 16 年补完 EVA 的许多作品后，之后的很多时间，我都在循环听里面的音乐。很喜欢 EVA 的音乐。</p><blockquote><p>年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。年度最期待的电影，因为沉迷 p5，拖到了今天才看完。看到一个小时时发现云里雾里，暂停又去回顾了下前三部剧场版。我发现，这么多年，eva 给我留下的是很深刻的情绪，感动，好听的音乐。我发现，在看这部『终』时，我不太能想起tv动画，旧剧场版，新剧场版的种种故事细节。总之，ありがどう、皆さん。</p></blockquote><h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><p>无论是技术类还是非技术类书籍，今年都没能很完整的去看完一本书。想了一下。非技术类书籍终究是被其他的一些娱乐方式占用或代替了。技术类书籍，则是被大部分看文档，看源码，看 YouTube 视频给代替了。从去年开始陆续看了很多 iOS 相关的技术内容。今年也算小有成效吧，在 iOS 项目的整体架构上有所认识和实践了。</p><h1 id="时刻"><a href="#时刻" class="headerlink" title="时刻"></a>时刻</h1><h3 id="离灯"><a href="#离灯" class="headerlink" title="离灯"></a>离灯</h3><p>3 月份的时候，关注到了「离灯_冬眠mode关闭失败」，她发了一篇微博，那篇微博的内容开头是</p><blockquote><p>首先，对不起大家，刷到我这么一条让人不开心的微博，还要看我絮絮叨叨。</p></blockquote><p>看了她写的内容，心里很难过。有可能是某些状态我是能和她感同身受来着。</p><h2 id="Clubhouse"><a href="#Clubhouse" class="headerlink" title="Clubhouse"></a>Clubhouse</h2><p>年初大火的 clubhouse，费了好大一番功夫才搞来了邀请码。年初的时候听了一阵子。当再次下载下来听，就是六七月份了，那个时候中文社区已经变得大不一样。我像是以前听播客那样，有段时间里很高频度的收听它。尽管我清楚有 80% 的内容是像「水茧房」一样，但仍然有一些，可能是只有通过 clubhouse 的这种形式才能够被表达出来。现在想想，自己也不过是在某个时间点希望听些东西，这个媒介，无论是播客，还是 clubhouse，似乎都不重要。因为我听 clubhouse，也是大部分时间在听，很少去发言。</p><h2 id="灰犀牛事件"><a href="#灰犀牛事件" class="headerlink" title="灰犀牛事件"></a>灰犀牛事件</h2><p>有关这些事情，端传媒最近的<a href="https://theinitium.com/article/20211229-mainland-comprehensive-supervision/">一篇文章</a>梳理的更加全面。这么多如此密集的，大规模的事情，一桩接着一桩。也让 2021 年保持了一个很高的区分度。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>每次在这样的时间点，大家都会说「明年会更好」啊，「新年新气象」啊，这些内容。然而这些年，无论是大的氛围的变化，还是周遭的我的个人感知。都让我认为，过去的那一年，才是更好的一年。哪怕现在站在这里，回想这一年发生的许多事情，似乎是称不上好。但真要我用力迈过去，心中依然相信的是，过去的那一年，才是更好的一年。</p><p>这一年告别了挺多人的。从年初到年尾。</p><p>按照惯例，一些期许，希望新的 Zelda 续作，希望『弥留之国的爱丽丝』第二季内容，希望『巫师』『Red Dead Redemption』『GTA V』能够推出 PS5 版本。</p><p>技术上还有很多未实现的愿景，需要一点一点提上日程了。</p><p>🌻</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/zelda-botw.jpg&quot; alt=&quot;zelda-botw&quot;&gt;&lt;/p&gt;
&lt;p&gt;6 月中旬的 E3 发布会，看到了久违的林克从高空纵身一跃的场景，那时的我心中想的都是，这个 2021 年再也待不下去了，好希望快点到 2022，这样就能玩到 Zelda 续作了。&lt;/p&gt;
&lt;p&gt;但真的跟随时间来到这里，心里还是会有许多的感慨，不舍，恐惧。这几天，这个月发生了很多事情。晚上回去也是早早躺下。心想，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哎，又到了此刻。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
      <category term="电影" scheme="http://reyshawn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>「可我会永远喜欢你的，这和时间没关系，我想」</title>
    <link href="http://reyshawn.com/2020/12/31/%E3%80%8C%E5%8F%AF%E6%88%91%E4%BC%9A%E6%B0%B8%E8%BF%9C%E5%96%9C%E6%AC%A2%E4%BD%A0%E7%9A%84%EF%BC%8C%E8%BF%99%E5%92%8C%E6%97%B6%E9%97%B4%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%88%91%E6%83%B3%E3%80%8D/"/>
    <id>http://reyshawn.com/2020/12/31/「可我会永远喜欢你的，这和时间没关系，我想」/</id>
    <published>2020-12-31T02:15:28.000Z</published>
    <updated>2020-12-31T04:20:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。</p><blockquote><p>“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” </p><p>“可我会永远喜欢你的，这和时间没有关系，我想。”</p><p>– 「舞！舞！舞！」</p></blockquote><span id="more"></span><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p><img src="/images/switch_2020.png" alt="switch 2020"></p><ul><li>The Legend of Zelda: Breath of the Wild</li><li>Hades</li><li>Animal Crossing: New Horizons</li><li>火焰纹章：风花雪月</li><li>Ori and the Will of the Wisps</li></ul><p>在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。</p><p>2021 年最期待塞尔达的续作。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks</li><li>「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ</li><li>Zelda &amp; Chill by Mikel &amp; GameChops</li><li>Zelda &amp; Chill 2 by Mikel &amp; GameChops</li><li>如果你爱我 by Tanya Chua</li></ul><p><a href="https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW">Replay 2020 - Apple Music for Reyshawn</a></p><p>(上面的链接，国内用户需要挂代理才可以打开。)</p><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><ul><li>「舞！舞！舞！」</li></ul><p>非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。</p><p><img src="/images/%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81.png" alt="舞！舞！舞！"></p><p>技术类书籍看了一些：</p><ul><li>Combine Asynchronous Programming with Swift</li><li>Node.js Design Patterns</li><li>iOS Development with Swift</li><li>Programming iOS 13</li><li>Python Parallel Programming Cookbook</li></ul><p>闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。</p><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><p><img src="/images/movies_2020.PNG" alt="movies 2020"></p><p>看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。</p><h3 id="时刻"><a href="#时刻" class="headerlink" title="时刻"></a>时刻</h3><p>今年一些值得纪念的时刻：</p><blockquote><p><em>2020.06.23</em></p><p>凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。</p></blockquote><p>背景音乐是 vox freak 版本的 <em>Ur So F**kInG cOoL</em>，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。</p><blockquote><p><em>2020.11.12</em></p><p>今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.</p><p><a href="https://browser.geekbench.com/v5/cpu/4652635">https://browser.geekbench.com/v5/cpu/4652635</a><br><a href="https://browser.geekbench.com/v5/cpu/4648107">https://browser.geekbench.com/v5/cpu/4648107</a></p></blockquote><p>M1 芯片的发布相当震撼。期待明年的 16寸 MBP。</p><blockquote><p><em>2020.11.19</em></p><p>看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。</p></blockquote><p>这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。</p><h3 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h3><p>来讲一讲明年的期待吧：</p><ul><li>塞尔达续作</li><li>搭载 Apple Silicon 芯片的 16 寸 MacBook Pro</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” &lt;/p&gt;
&lt;p&gt;“可我会永远喜欢你的，这和时间没有关系，我想。”&lt;/p&gt;
&lt;p&gt;– 「舞！舞！舞！」&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
      <category term="电影" scheme="http://reyshawn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>十年回顾</title>
    <link href="http://reyshawn.com/2020/01/01/%E5%8D%81%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <id>http://reyshawn.com/2020/01/01/十年回顾/</id>
    <published>2020-01-01T05:50:15.000Z</published>
    <updated>2020-12-31T02:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在两个月前的某<a href="https://www.apesk.com/mbti/">测评网站</a>上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是<a href="https://movie.douban.com/subject/1851857/">「蝙蝠侠：黑暗骑士」</a>，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。</p><p>从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。</p><span id="more"></span><h3 id="「骑着白马入地狱，叼着纸烟进天堂」"><a href="#「骑着白马入地狱，叼着纸烟进天堂」" class="headerlink" title="「骑着白马入地狱，叼着纸烟进天堂」"></a>「骑着白马入地狱，叼着纸烟进天堂」</h3><p><strong>2017 - 2019</strong></p><p>这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。</p><p>2017.9.10，自己的文章标题<a href="%5Bhttps://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/%5D(https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/)">「骑着白马入地狱，叼着纸烟进天堂」</a>，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。</p><p>到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。</p><p>在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：</p><blockquote><p>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。</p></blockquote><p>处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：</p><ul><li>Movies 🎬</li><li>Coding 💻</li><li>Basketball 🏀</li><li>Books 📚</li><li>Porn 🔞</li></ul><p>2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。</p><p>2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。</p><p>看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。</p><p>2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。</p><p>后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。</p><blockquote><p>世上无难事，只要肯放弃。</p></blockquote><p>我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。</p><blockquote><p>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。</p></blockquote><p>这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。</p><h3 id="「间奏曲，怀抱既然不能逗留」"><a href="#「间奏曲，怀抱既然不能逗留」" class="headerlink" title="「间奏曲，怀抱既然不能逗留」"></a>「间奏曲，怀抱既然不能逗留」</h3><p><strong>2012 - 2016</strong></p><p>2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。</p><blockquote><p>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。</p></blockquote><p>2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。</p><p>2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。</p><p>我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。</p><p>2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：</p><ul><li>IT 公论</li><li>反派影评</li><li>观影风向标</li><li>内核恐慌</li><li>得意忘形</li><li>游戏领航员</li><li>味之道</li><li>流行通信</li></ul><p>从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。</p><h3 id="「美丽生活」"><a href="#「美丽生活」" class="headerlink" title="「美丽生活」"></a>「美丽生活」</h3><p>2010 - 2012</p><p>更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。</p><p>每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。</p><p>现在还保存的三张电影光盘：</p><ul><li>裂缝</li><li>时间的灰烬</li><li>惧乳：伤心的奶水</li></ul><p><img src="/images/IMG_1578.JPG" alt="IMG_1578"></p><p>后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。</p><p>尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><strong>2020 - 未知</strong></p><p>生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在两个月前的某&lt;a href=&quot;https://www.apesk.com/mbti/&quot;&gt;测评网站&lt;/a&gt;上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是&lt;a href=&quot;https://movie.douban.com/subject/1851857/&quot;&gt;「蝙蝠侠：黑暗骑士」&lt;/a&gt;，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。&lt;/p&gt;
&lt;p&gt;从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
  </entry>
  
  <entry>
    <title>多个项目共享 Webpack</title>
    <link href="http://reyshawn.com/2019/08/29/%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB-Webpack/"/>
    <id>http://reyshawn.com/2019/08/29/多个项目共享-Webpack/</id>
    <published>2019-08-29T13:00:03.000Z</published>
    <updated>2019-08-29T13:48:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href="">@keyframer</a> 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。</p><p>因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  <code>package.json</code> 里预先定义好 </p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack-dev-server&quot;,    &quot;build&quot;: &quot;webpack&quot;&#125;</code></pre><p>然后 <code>npm run dev</code>。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。</p><span id="more"></span><p>项目的结构是这样的：</p><pre><code class="shell">.├── Project1│   ├── dist│   ├── package.json│   ├── src│   └── webpack.config.js├── Project2│   ├── dist│   ├── package-lock.json│   ├── package.json│   ├── src│   └── webpack.config.js├── Project3│   ├── dist│   ├── package-lock.json│   ├── package.json│   ├── src│   └── webpack.config.js├── node_modules // all webpack related node modules├── package-lock.json└── package.json</code></pre><p>需要一个parent directory，在 parent directory 里首先 <code>npn init -y</code>，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 <code>package.json</code> 中的  <code>script</code> 修改成：</p><pre><code class="json">&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;../node_modules/.bin/webpack-dev-server&quot;,    &quot;build&quot;: &quot;../node_modules/.bin/webpack&quot; &#125;</code></pre><p>这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 <code>webpack.config.js</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 &lt;a href=&quot;&quot;&gt;@keyframer&lt;/a&gt; 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。&lt;/p&gt;
&lt;p&gt;因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  &lt;code&gt;package.json&lt;/code&gt; 里预先定义好 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&amp;quot;scripts&amp;quot;: &amp;#123;
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后 &lt;code&gt;npm run dev&lt;/code&gt;。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issue #3</title>
    <link href="http://reyshawn.com/2019/07/12/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issue-3/"/>
    <id>http://reyshawn.com/2019/07/12/阅读摘要-issue-3/</id>
    <published>2019-07-12T09:33:53.000Z</published>
    <updated>2019-07-12T09:53:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Program-analysis"><a href="#Program-analysis" class="headerlink" title="Program analysis"></a><a href="https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases">Program analysis</a></h2><p>GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？</p><p>程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：</p><ol><li>程序运行时所需要多少内存；</li><li>得到所有的 dependencies 并生成相应的 graph；</li><li>call graph，所有的函数调用关系；</li><li>control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；</li></ol><h2 id="The-Designer’s-Growth-Model"><a href="#The-Designer’s-Growth-Model" class="headerlink" title="The Designer’s Growth Model"></a><a href="https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137">The Designer’s Growth Model</a></h2><p><a href="https://css-tricks.com/the-developers-growth-model/">https://css-tricks.com/the-developers-growth-model/</a></p><p>模仿 <a href="https://wiki.mbalib.com/wiki/%E8%91%9B%E9%9B%B7%E7%BA%B3%E7%9A%84%E4%BC%81%E4%B8%9A%E6%88%90%E9%95%BF%E6%A8%A1%E5%9E%8B">Grenier</a> groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：</p><ol><li>第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；</li><li>第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；</li><li>第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；</li><li>第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；</li><li>第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；</li></ol><span id="more"></span><h2 id="CSS-Architecture-—-Folders-amp-Files-Structure"><a href="#CSS-Architecture-—-Folders-amp-Files-Structure" class="headerlink" title="CSS Architecture — Folders &amp; Files Structure"></a><a href="https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b">CSS Architecture — Folders &amp; Files Structure</a></h2><p>Elad Shechter 介绍了他的 CSS 文件结构。</p><h2 id="How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue"><a href="#How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue" class="headerlink" title="How to Increase Your Page Size by 1,500% with webpack and Vue"></a><a href="https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/">How to Increase Your Page Size by 1,500% with webpack and Vue</a></h2><p>Burke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 <code>main.js</code> 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。</p><h2 id="Blendle"><a href="#Blendle" class="headerlink" title="Blendle"></a><a href="https://launch.blendle.com/">Blendle</a></h2><p>今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。</p><p>它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。</p><h2 id="Matrix-org"><a href="#Matrix-org" class="headerlink" title="Matrix.org"></a><a href="https://matrix.org/">Matrix.org</a></h2><p>一个开源的，e2e 加密，去中心化的 message 项目</p><blockquote><p>The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I’m currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I’m working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there’s no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.<br>— <a href="https://news.ycombinator.com/item?id=20157809">comments from Hacker News</a></p></blockquote><h2 id="Discoveries"><a href="#Discoveries" class="headerlink" title="Discoveries"></a>Discoveries</h2><p><a href="https://bennettfeely.com/clippy/">Clippy - CSS clip-path maker</a></p><p><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">Which programming language is fastest? | Computer Language Benchmarks Game</a></p><p><em>Toy-program performance measurements for ~24 language implementations.</em></p><p><a href="https://observablehq.com/">Observable</a> </p><p><em>JavaScript 版本的 Juypter</em></p><p><a href="https://every-layout.dev/">Relearn CSS layout</a> </p><p><em>CSS layout</em></p><p><a href="https://jsperf.com/">jsPerf: JavaScript performance playground</a> </p><p><em>比较不同 js 写法的性能</em></p><p><a href="https://flutter.dev/">Flutter - Beautiful native apps in record time</a> </p><p><em>Google 推出的跨平台 UI 框架</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Program-analysis&quot;&gt;&lt;a href=&quot;#Program-analysis&quot; class=&quot;headerlink&quot; title=&quot;Program analysis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases&quot;&gt;Program analysis&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？&lt;/p&gt;
&lt;p&gt;程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序运行时所需要多少内存；&lt;/li&gt;
&lt;li&gt;得到所有的 dependencies 并生成相应的 graph；&lt;/li&gt;
&lt;li&gt;call graph，所有的函数调用关系；&lt;/li&gt;
&lt;li&gt;control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;The-Designer’s-Growth-Model&quot;&gt;&lt;a href=&quot;#The-Designer’s-Growth-Model&quot; class=&quot;headerlink&quot; title=&quot;The Designer’s Growth Model&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137&quot;&gt;The Designer’s Growth Model&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/the-developers-growth-model/&quot;&gt;https://css-tricks.com/the-developers-growth-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模仿 &lt;a href=&quot;https://wiki.mbalib.com/wiki/%E8%91%9B%E9%9B%B7%E7%BA%B3%E7%9A%84%E4%BC%81%E4%B8%9A%E6%88%90%E9%95%BF%E6%A8%A1%E5%9E%8B&quot;&gt;Grenier&lt;/a&gt; groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；&lt;/li&gt;
&lt;li&gt;第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；&lt;/li&gt;
&lt;li&gt;第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；&lt;/li&gt;
&lt;li&gt;第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；&lt;/li&gt;
&lt;li&gt;第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lazy Evaluation, foldr | 5kyu</title>
    <link href="http://reyshawn.com/2019/07/06/Lazy-Evaluation/"/>
    <id>http://reyshawn.com/2019/07/06/Lazy-Evaluation/</id>
    <published>2019-07-06T04:42:24.000Z</published>
    <updated>2019-07-06T05:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：</p><pre><code class="javascript">// Evaluates with call-by-name strategy1 function callByName (a, b) &#123;2  if (a === 1) &#123;3    return 104  &#125;5  return a + b6 &#125;// Evaluates with call-by-value strategy1 function callByValue (a, b) &#123;2  if (a === 1) &#123;3    return 104  &#125;5  return a + b6 &#125;</code></pre><p>两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；</p><pre><code class="shell">&gt; callByName (1, 2 + 3)&gt; a === 1&gt; return 10&gt; callByValue(1, 2 + 3)&gt; callByValue(1, 5)&gt; a === 1&gt; return 10</code></pre><p>使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。</p><p>实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：</p><span id="more"></span><pre><code class="javascript">// Not lazyvar value = 1 + 1  // immediately evaluates to 2// Lazyvar lazyValue = () =&gt; 1 + 1  // Evaluates to 2 when lazyValue is *invoked*// Not lazyvar add = (x, y) =&gt; x + yvar result = add(1, 2)  // Immediately evaluates to 3// Lazyvar addLazy = (x, y) =&gt; () =&gt; x + y;var result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.</code></pre><p>理解了这一概念，就明白 codewars 上这道题目的用意了。</p><p><a href="https://www.codewars.com/kata/foldr/javascript">https://www.codewars.com/kata/foldr/javascript</a></p><p>题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 <code>reduceRight()</code> 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 <code>indexOf</code> 函数为例：</p><pre><code class="javascript">const indexOf = y =&gt; function (x, z) &#123;  if (x === y) &#123;    return 0  &#125; else &#123;    return z + 1 || -1  &#125;&#125;;</code></pre><p><code>indexOf</code> 返回的是一个函数，比如 <code>indexOf(1)</code> 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：</p><pre><code class="javascript">const indexOf = y =&gt; function (x, () =&gt; someFunction()) &#123;  if (x === y) &#123;    return 0  &#125; else &#123;    return z() + 1 || -1  &#125;&#125;;</code></pre><p>这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，<code>indexOf</code> 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 <code>return z + 1 || -1</code>  改成 <code>return z() + 1 || -1</code>。</p><p>所以，问题最终就变成了，如何将一个变量，比如 <code>z</code>，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 <code>Object.prototype.valueOf()</code>。</p><blockquote><p>JavaScript calls the <code>valueOf</code> method to convert an object to a primitive value. You rarely need to invoke the <code>valueOf</code> method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</p></blockquote><p>使用 <code>valueOf()</code> ，可以</p><pre><code class="javascript">&gt; a = &#123;&#125;&#123;&#125;&gt; a.valueOf = () =&gt; 3[Function]&gt; a &#123; valueOf: [Function] &#125;&gt; a + 14&gt; a.valueOf = () =&gt; true[Function]&gt; !a false&gt; a &amp;&amp; false false&gt; </code></pre><p>定义了 <code>valueOf</code> 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，<code>valueOf</code> 函数才会被调用。因此，我们只需要在调用 <code>indexOf</code> 函数时这样调用：</p><pre><code class="javascript">indexOf(1)(1, &#123;valueOf: () =&gt; someFunction()&#125;)</code></pre><p>即可。依照这样的思路，这道 codewars 问题也就迎刃而解。</p><p>参考链接：</p><ul><li><a href="https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7">Lazy Evaluation in Javascript</a></li><li><a href="https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript">Meaning of Lazy Evaluation in Javascript</a></li><li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf">Object.prototype.valueOf()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Evaluates with call-by-name strategy
1 function callByName (a, b) &amp;#123;
2  if (a === 1) &amp;#123;
3    return 10
4  &amp;#125;
5  return a + b
6 &amp;#125;
// Evaluates with call-by-value strategy
1 function callByValue (a, b) &amp;#123;
2  if (a === 1) &amp;#123;
3    return 10
4  &amp;#125;
5  return a + b
6 &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;&amp;gt; callByName (1, 2 + 3)
&amp;gt; a === 1
&amp;gt; return 10

&amp;gt; callByValue(1, 2 + 3)
&amp;gt; callByValue(1, 5)
&amp;gt; a === 1
&amp;gt; return 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。&lt;/p&gt;
&lt;p&gt;实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：&lt;/p&gt;
    
    </summary>
    
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript: Semicolon 二三事</title>
    <link href="http://reyshawn.com/2019/06/29/JavaScript-Semicolon%20%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://reyshawn.com/2019/06/29/JavaScript-Semicolon 二三事/</id>
    <published>2019-06-29T15:02:41.000Z</published>
    <updated>2019-06-29T17:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于 JavaScript 拥有 <em>Automatic Semicolon Insertion</em> 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：</p><pre><code class="javascript">let i = 0(function test () &#123;  console.log(&#39;hello&#39;)&#125;)()</code></pre><p>这里会提示报错：</p><pre><code>TypeError: 0 is not a function</code></pre><p>观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。</p><pre><code class="javascript">let i = 0;(function test () &#123;  console.log(&#39;hello&#39;)&#125;)()</code></pre><p>关于 JavaScript 的 <em>Automatic Semicolon Insertion</em>，规则是这样的：</p><span id="more"></span><ol><li>当下一行开头的代码和本行末尾的代码连不上；</li><li>当下一行是以 <code>&#125;</code> 开头；</li><li>在整个文件末尾会加分号；</li><li>在 <code>return</code> 所在行末尾会加分号；</li><li>在 <code>break</code> 所在行末尾会加分号；</li><li>在 <code>throw</code> 所在行末尾会加分号；</li><li>在 <code>continue</code> 所在行末尾会加分号；</li></ol><p>上面这个例子，就是如果不在第一行加分号，则下一行以 <code>(</code> 开头，则会被当作函数调用。相似的情况还有：</p><pre><code class="javascript">const hey = &#39;hey&#39;const you = &#39;hey&#39;const heyYou = hey + &#39; &#39; + you[&#39;h&#39;, &#39;e&#39;, &#39;y&#39;].forEach((letter) =&gt; console.log(letter))// Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined</code></pre><p>以及关于 return </p><pre><code class="javascript">(() =&gt; &#123;  return  &#123;    color: &#39;white&#39;  &#125;&#125;)()// Instead, it’s undefined, because JavaScript inserts a semicolon after return.</code></pre><p>以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。</p><p>Dr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：</p><blockquote><ul><li>Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons <em>increase</em> the readability of code, because I’m so used to them.</li><li>Don’t put postfix <code>++</code> (or postfix <code>--</code>) and its operand in separate lines.</li><li>If the following statements have an argument, don’t put it in a separate line: <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>.</li><li>For consistency (with <code>return</code>), if an opening brace or bracket is part of a statement, don’t put it in a separate line.</li></ul></blockquote><p>参考文章：</p><ul><li><a href="https://flaviocopes.com/javascript-automatic-semicolon-insertion/">Semicolons in JavaScript</a></li><li><a href="https://2ality.com/2011/05/semicolon-insertion.html">Automatic semicolon insertion in JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 JavaScript 拥有 &lt;em&gt;Automatic Semicolon Insertion&lt;/em&gt; 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let i = 0

(function test () &amp;#123;
  console.log(&amp;#39;hello&amp;#39;)
&amp;#125;)()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会提示报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeError: 0 is not a function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let i = 0;

(function test () &amp;#123;
  console.log(&amp;#39;hello&amp;#39;)
&amp;#125;)()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 JavaScript 的 &lt;em&gt;Automatic Semicolon Insertion&lt;/em&gt;，规则是这样的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issue #2</title>
    <link href="http://reyshawn.com/2019/06/12/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issue-2/"/>
    <id>http://reyshawn.com/2019/06/12/阅读摘要-issue-2/</id>
    <published>2019-06-12T12:45:12.000Z</published>
    <updated>2019-07-12T09:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand"><a href="#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand" class="headerlink" title="The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)"></a><a href="https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html">The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)</a></h2><p>在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 <a href="http://foundationmedicine.com/">foundationmedicine.com</a> 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：</p><ul><li>Logo</li><li>空白处的填充，space filling；</li><li>字体，GT Sectra，本身就具有六边形结构；</li><li>分割线；</li><li>诸如 qutation marks 这些小的 文字元素</li></ul><p>同样的视觉设计，分析也可用在 <a href="https://theintercept.com/">The Intercept</a> ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 <a href="https://css-tricks.com/">CSS Tricks</a>，则是把「橙黄渐变」作为一种 motif。</p><h2 id="Level-up-your-sort-game"><a href="#Level-up-your-sort-game" class="headerlink" title="Level up your .sort game"></a><a href="https://css-tricks.com/level-up-your-sort-game/">Level up your .sort game</a></h2><p>关于 JavaScript 中 <code>.sort()</code> 方法的使用。其中提到的几点关键：</p><ul><li>While many of the ES5 array methods such as <code>.filter</code>, <code>.map</code>, and <code>.reduce</code> will return a new array and leave the original untouched, <code>.sort</code> will sort the array in place.</li><li>要想不让 original variable 发生改变，使用 <code>...</code> ；</li><li>Running functions before comparing values，这里存在一个小的 design pattern；</li><li>如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 <code>reduce</code> 方法。</li><li>如何写一个随机排序；</li></ul><span id="more"></span><h2 id="如何反抗"><a href="#如何反抗" class="headerlink" title="如何反抗"></a><a href="https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/">如何反抗</a></h2><blockquote><ul><li>终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；</li><li>关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；</li><li>认真听音乐，在不幹别的的情况下。多人一起更佳； </li><li>…</li><li>意识到「所有人都是残疾人」这个事实；</li><li>一定要屌犬儒者的老母。</li></ul></blockquote><h2 id="macOS-10-15-Beta-Release-Notes"><a href="#macOS-10-15-Beta-Release-Notes" class="headerlink" title="macOS 10.15 Beta Release Notes"></a><a href="https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257">macOS 10.15 Beta Release Notes</a></h2><p>苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。</p><h2 id="六月里发生了一些事"><a href="#六月里发生了一些事" class="headerlink" title="六月里发生了一些事"></a>六月里发生了一些事</h2><blockquote><p>走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — <a href="https://twitter.com/hengdm/status/1135737325323866113">DM.</a> </p><p>那是，毕竟吃药的第一步是承认自己有病。 — <a href="https://twitter.com/ichimaru0223/status/1135737755487498240">妖術</a></p></blockquote><h2 id="INTJ-amp-INTP"><a href="#INTJ-amp-INTP" class="headerlink" title="INTJ &amp; INTP"></a><a href="https://en.wikipedia.org/wiki/INTJ">INTJ</a> &amp; <a href="https://en.wikipedia.org/wiki/INTP">INTP</a></h2><ul><li>INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.</li><li>INTP: Introversion, Intuition, Thinking, Perceiving</li></ul><p><a href="https://personalityhacker.com/intp-vs-intj/">这篇文章</a>举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在<a href="https://www.douban.com/group/INT/?ref=sidebar">某豆瓣小组</a>的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。</p><p>看了上面的解释，认为自己可能属于 INTP 多一些。</p><h2 id="Discoveries"><a href="#Discoveries" class="headerlink" title="Discoveries"></a>Discoveries</h2><p><a href="https://cssgrid-generator.netlify.com/">CSS Grid Generator</a></p><p><em>自从生成 css grid 代码。</em></p><p><a href="https://www.animatedknots.com/complete-knot-list">Animated Knots</a></p><p><em>一个教你如何打结的网站，每种方法都配有动画。</em></p><p><a href="https://www.npmtrends.com/">Compare package download counts over time</a></p><p><em>用于对比 npm package 的下载量。</em></p><p><a href="https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup">Pod Hunters: all of the cool podcasts that we recommend</a></p><p><em>the verge 专栏 pod hunters，推荐好听的播客节目。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand&quot;&gt;&lt;a href=&quot;#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand&quot; class=&quot;headerlink&quot; title=&quot;The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html&quot;&gt;The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 &lt;a href=&quot;http://foundationmedicine.com/&quot;&gt;foundationmedicine.com&lt;/a&gt; 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logo&lt;/li&gt;
&lt;li&gt;空白处的填充，space filling；&lt;/li&gt;
&lt;li&gt;字体，GT Sectra，本身就具有六边形结构；&lt;/li&gt;
&lt;li&gt;分割线；&lt;/li&gt;
&lt;li&gt;诸如 qutation marks 这些小的 文字元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样的视觉设计，分析也可用在 &lt;a href=&quot;https://theintercept.com/&quot;&gt;The Intercept&lt;/a&gt; ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 &lt;a href=&quot;https://css-tricks.com/&quot;&gt;CSS Tricks&lt;/a&gt;，则是把「橙黄渐变」作为一种 motif。&lt;/p&gt;
&lt;h2 id=&quot;Level-up-your-sort-game&quot;&gt;&lt;a href=&quot;#Level-up-your-sort-game&quot; class=&quot;headerlink&quot; title=&quot;Level up your .sort game&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://css-tricks.com/level-up-your-sort-game/&quot;&gt;Level up your .sort game&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关于 JavaScript 中 &lt;code&gt;.sort()&lt;/code&gt; 方法的使用。其中提到的几点关键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;While many of the ES5 array methods such as &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.map&lt;/code&gt;, and &lt;code&gt;.reduce&lt;/code&gt; will return a new array and leave the original untouched, &lt;code&gt;.sort&lt;/code&gt; will sort the array in place.&lt;/li&gt;
&lt;li&gt;要想不让 original variable 发生改变，使用 &lt;code&gt;...&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;Running functions before comparing values，这里存在一个小的 design pattern；&lt;/li&gt;
&lt;li&gt;如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 &lt;code&gt;reduce&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;如何写一个随机排序；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSON Web Token 的产生和认证</title>
    <link href="http://reyshawn.com/2019/06/12/JSON-Web-Token-%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%AE%A4%E8%AF%81/"/>
    <id>http://reyshawn.com/2019/06/12/JSON-Web-Token-的产生和认证/</id>
    <published>2019-06-12T05:49:07.000Z</published>
    <updated>2019-06-12T08:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie-based-vs-Token-based"><a href="#Cookie-based-vs-Token-based" class="headerlink" title="Cookie-based vs Token-based"></a>Cookie-based vs Token-based</h2><p>有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：</p><p>cookie-based authentication 的认证流程是:</p><ol><li>用户填写 credentials，包括用户名，邮箱，密码这些内容；</li><li>Server 服务器验证这些 credentials 是否正确，如果正确，则<strong>认证成功</strong>，创建一个 session 存储在数据库中；</li><li>将这个 session 的 session id 存储在浏览器端的 cookie 里；</li><li>接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；</li><li>一旦用户登出，client 端和 server 端的 session 均被摧毁；</li></ol><p>token-based authentication:</p><ol><li>用户填写 credentials，包括用户名，邮箱，密码；</li><li>Server 服务器验证这些 credentials 是否正确，如果<strong>认证成功</strong>，则返回一个 signed token；</li><li>这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；</li><li>接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。</li><li>Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；</li></ol><p><img src="/images/auto01.png" alt="auto01"></p><p>为什么会说 token-based 更好：</p><ol><li>stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；</li><li>cookie 对跨域 CORS 操作不友好，token 则没有这个问题；</li></ol><span id="more"></span><h2 id="JWT-如何产生的"><a href="#JWT-如何产生的" class="headerlink" title="JWT 如何产生的"></a>JWT 如何产生的</h2><p>一条完整的 JWT 格式是这样的：<code>header.payload.signature</code>。</p><p>第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：</p><pre><code class="javascript">const header = &#123;    typ: &quot;JWT&quot;,    alg: &quot;HS256&quot;&#125;</code></pre><p><code>&quot;typ&quot;</code> 声明这是一个 JWT，<code>&quot;alg&quot;</code> 声明所有是用的 hash 算法；</p><p>第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，</p><pre><code class="javascript">const payload = &#123;    userId: &quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;&#125;</code></pre><p>对于 JWT 的 payload，会有一些标准，比如 <code>iss</code> 代表 issuer，<code>sub</code> 代表 subject，<code>exp</code> 代表 expiration time。</p><p>第三步，创建 signature 签名。</p><pre><code class="javascript">const encodedHeader = Buffer.from(JSON.stringify(header)).toString(&#39;base64&#39;)const encodedPayload = Buffer.from(JSON.stringify(payload)).toString(&#39;base64&#39;)</code></pre><p>将 header 和 payload 都使用 base64 编码。</p><pre><code class="javascript">const crypto = require(&#39;crypto&#39;)const jwtSecret = &#39;secretKey&#39;const signature = crypto.createHmac(&#39;sha256&#39;, jwtSecret).update(encodedHeader + &#39;.&#39; + encodedPayload).digest(&#39;base64&#39;)</code></pre><p>base64 编码后的文本使用 <code>.</code> 连接，再进行 hash，hash 后的文本再进行 base64 编码。</p><p>最终 JWT 为：</p><pre><code class="javascript">const jwt = `$&#123;encodedHeader&#125;.$&#123;encodedPayload&#125;.$&#123;signature&#125;`</code></pre><h2 id="JWT-的认证"><a href="#JWT-的认证" class="headerlink" title="JWT 的认证"></a>JWT 的认证</h2><blockquote><p>The <strong>very</strong> important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is <strong>not</strong> encrypted. If I go to <a href="https://jwt.io/">jwt.io</a>, paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.</p><p>— <a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide">Cookies vs. Tokens: The Definitive Guide</a></p></blockquote><p>一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 <code>HttpOnly Cookie</code>，不同于传统 cookie，标有 <code>HttpOnly</code> 的 cookie 只能由 Server 端获取。</p><p>登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 <code>Authorization</code> 里，以 Bearer 作为开头：</p><pre><code class="yaml">Authorization: Bearer &lt;token&gt;</code></pre><p>服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：</p><ol><li>验证 JWT 的格式是否正确；</li><li>验证 signature 签名；</li><li>验证在 payload 里的 standard claims；</li><li>验证许可权限范围；</li></ol><p>在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。</p><blockquote><p>The API needs to check if the algorithm, as specified by the JWT header (property <code>alg</code>), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.</p><p>To check if the signature matches the API’s expectations, you have to decode the JWT and retrieve the <code>alg</code> property of the JWT header.</p><p>Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:</p><p>— <a href="https://auth0.com/docs/api-auth/tutorials/verify-access-token">Verify Access Tokens for Custom APIs</a></p></blockquote><h2 id="在-express-里实际应用"><a href="#在-express-里实际应用" class="headerlink" title="在 express 里实际应用"></a>在 express 里实际应用</h2><p><a href="https://www.youtube.com/watch?v=7nafaH9SddU">Node.js API Authentication With JWT</a></p><p>这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：</p><pre><code class="javascript">const express = require(&#39;express&#39;);const jwt = require(&#39;jsonwebtoken&#39;);const app = express();app.get(&#39;/api&#39;, (req, res) =&gt; &#123;  res.json(&#123;    messgae: &#39;welcome to the api&#39;  &#125;)&#125;);app.post(&#39;/api/posts&#39;, verifyToken, (req, res) =&gt; &#123;  jwt.verify(req.token, &#39;secretkey&#39;, (err, authData) =&gt; &#123;    if (err) &#123;      res.sendStatus(403);    &#125; else &#123;      res.json(&#123;        message: &#39;post created ...&#39;,        authData      &#125;)    &#125;  &#125;)  &#125;)app.post(&#39;/api/login&#39;, (req, res) =&gt; &#123;  // Mock user  const user = &#123;    id: 1,    usernmae: &#39;brad&#39;,    email: &#39;brad@gamil.com&#39;  &#125;  jwt.sign(&#123;user&#125;, &#39;secretkey&#39;, (err, token) =&gt; &#123;    res.json(&#123;      token    &#125;)  &#125;);&#125;);// Format of Token// Authorization: Bearer &lt;access_token&gt;// Verify Tokenfunction verifyToken(req, res, next) &#123;  // Get auth header value;  const bearerHeader = req.headers[&#39;authorization&#39;];  // Check if bearer is undefined  if (typeof bearerHeader !== &#39;undefined&#39;) &#123;    // Split at the space    const bearer = bearerHeader.split(&#39; &#39;);    // Get token from array    const bearerToken = bearer[1];    // Set the token    req.token = bearerToken;    // Next middleware    next();  &#125; else &#123;    // Forbidden    res.sendStatus(403);  &#125;&#125;app.listen(5000, () =&gt; console.log(&#39;server started on 5000&#39;))</code></pre><p>通过 <code>jwt.sign()</code> 进行签名。</p><p>函数 <code>verifyToken</code>  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 <code>req.token</code>  里，具体的认证是通过 <code>jwt.verify()</code> 实现的。</p><h2 id="HS256-vs-RS256"><a href="#HS256-vs-RS256" class="headerlink" title="HS256 vs RS256"></a>HS256 vs RS256</h2><p>前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。</p><blockquote><p>For <code>RS256</code>, the tenant’s <a href="https://auth0.com/docs/jwks">JSON Web Key Set (JWKS)</a> is used. Your tenant’s JWKS is <code>https://YOUR_DOMAIN/.well-known/jwks.json</code>.</p></blockquote><p>通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。</p><p><img src="/images/auth02.png" alt="auth02"> </p><p>参考：</p><ul><li><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a></li><li><a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide">Cookies vs. Tokens: The Definitive Guide</a></li><li><a href="https://flaviocopes.com/jwt/">JSON Web Token (JWT) explained</a></li><li><a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li><li><a href="https://auth0.com/docs/api-auth/tutorials/verify-access-token">Verify Access Tokens for Custom APIs</a></li><li><a href="https://auth0.com/docs/jwks">JSON Web Key Set</a></li><li><a href="https://tools.ietf.org/html/rfc7519#section-7.2">JSON Web Token (JWT)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cookie-based-vs-Token-based&quot;&gt;&lt;a href=&quot;#Cookie-based-vs-Token-based&quot; class=&quot;headerlink&quot; title=&quot;Cookie-based vs Token-based&quot;&gt;&lt;/a&gt;Cookie-based vs Token-based&lt;/h2&gt;&lt;p&gt;有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：&lt;/p&gt;
&lt;p&gt;cookie-based authentication 的认证流程是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户填写 credentials，包括用户名，邮箱，密码这些内容；&lt;/li&gt;
&lt;li&gt;Server 服务器验证这些 credentials 是否正确，如果正确，则&lt;strong&gt;认证成功&lt;/strong&gt;，创建一个 session 存储在数据库中；&lt;/li&gt;
&lt;li&gt;将这个 session 的 session id 存储在浏览器端的 cookie 里；&lt;/li&gt;
&lt;li&gt;接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；&lt;/li&gt;
&lt;li&gt;一旦用户登出，client 端和 server 端的 session 均被摧毁；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;token-based authentication:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户填写 credentials，包括用户名，邮箱，密码；&lt;/li&gt;
&lt;li&gt;Server 服务器验证这些 credentials 是否正确，如果&lt;strong&gt;认证成功&lt;/strong&gt;，则返回一个 signed token；&lt;/li&gt;
&lt;li&gt;这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；&lt;/li&gt;
&lt;li&gt;接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。&lt;/li&gt;
&lt;li&gt;Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/auto01.png&quot; alt=&quot;auto01&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么会说 token-based 更好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；&lt;/li&gt;
&lt;li&gt;cookie 对跨域 CORS 操作不友好，token 则没有这个问题；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>iPadOS 使用体验</title>
    <link href="http://reyshawn.com/2019/06/05/iPadOS-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>http://reyshawn.com/2019/06/05/iPadOS-使用体验/</id>
    <published>2019-06-05T03:25:19.000Z</published>
    <updated>2019-06-05T04:09:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 <a href="https://developer.apple.com/support/beta-software/install-beta/">Installing Apple Beta Software</a> 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在<a href="https://www.udid.in/install-beta">这里</a>下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。</p><p>具体的安装教程也可以参考这个 <a href="https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl,wn">YouTube 视频</a>。</p><p>下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。</p><span id="more"></span><h2 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h2><h3 id="Always-Request-Desktop-Page"><a href="#Always-Request-Desktop-Page" class="headerlink" title="Always Request Desktop Page"></a>Always Request Desktop Page</h3><p>永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：</p><ul><li>在 bilibili.com 可以调整更高清的分辨率；</li><li>可以在 repl.it 上在线 coding 了；</li></ul><p><img src="/images/repl.png" alt="repl"></p><p>bilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。</p><p>理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。</p><p>可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Safari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。</p><h2 id="手势交互"><a href="#手势交互" class="headerlink" title="手势交互"></a>手势交互</h2><p>手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。</p><h3 id="截图-长截图"><a href="#截图-长截图" class="headerlink" title="截图 / 长截图"></a>截图 / 长截图</h3><p>两种截图方式：</p><ol><li>power button + volume button；</li><li>使用 Apple Pencil 在屏幕左下角或右下角向上拉；</li></ol><p>第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。</p><h3 id="文字选取高亮-光标移动"><a href="#文字选取高亮-光标移动" class="headerlink" title="文字选取高亮 / 光标移动"></a>文字选取高亮 / 光标移动</h3><p>在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。</p><h3 id="copy-paste"><a href="#copy-paste" class="headerlink" title="copy / paste"></a>copy / paste</h3><p>我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。</p><p>通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。</p><h2 id="外接存储"><a href="#外接存储" class="headerlink" title="外接存储"></a>外接存储</h2><p>是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。</p><p>不清楚各位有没有连接 APFS 格式机械硬盘成功的。</p><p>![ipad files bug](/images/ipad files bug.png)</p><h2 id="UI-变化"><a href="#UI-变化" class="headerlink" title="UI 变化"></a>UI 变化</h2><p>苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡</p><p>![iOS13 tab 1](/images/iOS13 tab 1.png)</p><p>![iOS13 tab 2](/images/iOS13 tab 2.png)</p><p>![iOS13 tab 3](/images/iOS13 tab 3.png)</p><h2 id="关于-iPad-的未来"><a href="#关于-iPad-的未来" class="headerlink" title="关于 iPad 的未来"></a>关于 iPad 的未来</h2><ol><li>Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。</li><li>会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。</li><li>内存会更多，将来可以后台多任务运行的数量会增多。</li></ol><p>最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 &lt;a href=&quot;https://developer.apple.com/support/beta-software/install-beta/&quot;&gt;Installing Apple Beta Software&lt;/a&gt; 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在&lt;a href=&quot;https://www.udid.in/install-beta&quot;&gt;这里&lt;/a&gt;下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。&lt;/p&gt;
&lt;p&gt;具体的安装教程也可以参考这个 &lt;a href=&quot;https://www.youtube.com/watch?v=iPZ6eNc8BvU&amp;frags=pl,wn&quot;&gt;YouTube 视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issues #1</title>
    <link href="http://reyshawn.com/2019/05/31/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issues-1/"/>
    <id>http://reyshawn.com/2019/05/31/阅读摘要-issues-1/</id>
    <published>2019-05-31T11:44:37.000Z</published>
    <updated>2019-06-12T12:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi"><a href="#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi" class="headerlink" title="Complex life may only exist because of millions of years of groundwork by ancient fungi"></a><a href="https://news.ycombinator.com/item?id=20039980">Complex life may only exist because of millions of years of groundwork by ancient fungi</a></h2><p>在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。</p><h2 id="Why-specialization-can-be-a-downside-in-our-ever-changing-world"><a href="#Why-specialization-can-be-a-downside-in-our-ever-changing-world" class="headerlink" title="Why specialization can be a downside in our ever-changing world"></a><a href="https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview">Why specialization can be a downside in our ever-changing world</a></h2><p>作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。</p><span id="more"></span><h2 id="https-t-me-yifenshijie-2973"><a href="#https-t-me-yifenshijie-2973" class="headerlink" title="https://t.me/yifenshijie/2973"></a><a href="https://t.me/yifenshijie/2973">https://t.me/yifenshijie/2973</a></h2><p><a href="https://twitter.com/Scholars_Stage/status/1099238789363294208">T. Greer</a> 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：</p><ul><li>blog 更专注内容，后者只期望于把用户留在自己的平台里；</li><li>blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；</li><li>blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；</li></ul><p>李如一看到这条 thread 后，<a href="https://t.me/s/yifenshijie/2973">停止更新了他在 telegram 平台的「一分世界」</a>，认为要知行合一。</p><h2 id="霍洛维兹的欺骗"><a href="#霍洛维兹的欺骗" class="headerlink" title="霍洛维兹的欺骗"></a><a href="https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/">霍洛维兹的欺骗</a></h2><p>Horowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。</p><blockquote><p>Apple Music 上，<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029">在这里</a>可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362">这里</a>可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。</p></blockquote><p>以及这里给出网易云音乐的链接，方便收听。<a href="https://music.163.com/#/song?id=405318766">edited</a> &amp; <a href="https://music.163.com/#/song?id=1298480910">unedited</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot;&gt;&lt;a href=&quot;#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot; class=&quot;headerlink&quot; title=&quot;Complex life may only exist because of millions of years of groundwork by ancient fungi&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=20039980&quot;&gt;Complex life may only exist because of millions of years of groundwork by ancient fungi&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。&lt;/p&gt;
&lt;h2 id=&quot;Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot;&gt;&lt;a href=&quot;#Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot; class=&quot;headerlink&quot; title=&quot;Why specialization can be a downside in our ever-changing world&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview&quot;&gt;Why specialization can be a downside in our ever-changing world&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript async and Promise</title>
    <link href="http://reyshawn.com/2019/05/18/JavaScript-async-and-Promise/"/>
    <id>http://reyshawn.com/2019/05/18/JavaScript-async-and-Promise/</id>
    <published>2019-05-18T13:47:39.000Z</published>
    <updated>2019-05-18T13:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p><pre><code class="javascript">$.get(&#39;http://twitter.com&#39;)$.get(&#39;http://youtube.com&#39;)$.get(&#39;http://google.com&#39;)</code></pre><p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p><pre><code class="Javascript">console.log(&#39;hi&#39;)setTimeout(() =&gt; console.log(&#39;there&#39;), 0)console.log(&#39;Welcome!&#39;)// output:// hi// Welcome// there</code></pre><p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p><p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p><span id="more"></span><p><img src="/images/eventLoop.png" alt="Event Loop"></p><h2 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h2><p>Promise 和   <code>setTimeout()</code> 的区别是，<code>setTimeout()</code> 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 <code>.then()</code> 的方法执行下一个任务。</p><blockquote><p>Timeouts and Promises serve different purposes.</p><p>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.</p><p>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your <code>then()</code> call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.</p><p>The reason the promise is executing before your timeout is that the promise isn’t actually waiting for anything so it resolved right away.</p></blockquote><p>以下是来自 <a href="https://www.promisejs.org/implementing/">Implementing</a>，对于 Promise object 的实现：</p><p>最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 <code>console.log()</code>。</p><pre><code class="javascript">let PENDING = 0;let FULFILLED = 1;let REJECTED = 2;function Promise(fn) &#123;  // store state which can be PENDING, FULFILLED or REJECTED  let state = PENDING;  // store value or error once FULFILLED or REJECTED  let value = null;  // store sucess &amp; failure handlers attached by calling .then or .done  let handlers = [];  function fulfill(result) &#123;    state = FULFILLED;    value = result;    handlers.forEach(handle);    handlers = null;  &#125;  function reject(error) &#123;    state = REJECTED;    value = error;    handlers.forEach(handle);    handlers = null;  &#125;  function resolve(result) &#123;    try &#123;      let then = getThen(result);      if (then) &#123;        doResolve(then.bind(result), resolve, reject);        return ;      &#125;      fulfill(result)    &#125; catch (e) &#123;      reject(e);    &#125;  &#125;  function handle(handler) &#123;    if (state === PENDING) &#123;      handlers.push(handler);    &#125; else &#123;      if (state === FULFILLED &amp;&amp;        typeof handler.onFulfilled === &#39;function&#39;) &#123;        handler.onFulfilled(value);      &#125;      if (state === REJECTED &amp;&amp;        typeof handler.onRejected === &#39;function&#39;) &#123;        handler.onRejected(value);      &#125;    &#125;  &#125;  this.done = function (onFulfilled, onRejected) &#123;    // ensure we are always asynchronous    setTimeout(function () &#123;      console.log(&#39;instantly implemented ⚠️&#39;)      handle(&#123;        onFulfilled: onFulfilled,        onRejected: onRejected      &#125;);    &#125;, 0);  &#125;    doResolve(fn, resolve, reject)  this.then = function (onFulfilled, onRejected) &#123;    var self = this;    return new Promise(function (resolve, reject) &#123;      return self.done(function (result) &#123;        if (typeof onFulfilled === &#39;function&#39;) &#123;          try &#123;            return resolve(onFulfilled(result));          &#125; catch (ex) &#123;            return reject(ex);          &#125;        &#125; else &#123;          return resolve(result);        &#125;      &#125;, function (error) &#123;        if (typeof onRejected === &#39;function&#39;) &#123;          try &#123;            return resolve(onRejected(error));          &#125; catch (ex) &#123;            return reject(ex);          &#125;        &#125; else &#123;          return reject(error);        &#125;      &#125;);    &#125;);  &#125;&#125;function getThen(value) &#123;  var t = typeof value;  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) &#123;    var then = value.then;    if (typeof then === &#39;function&#39;) &#123;      return then;    &#125;  &#125;  return null;&#125;function doResolve(fn, onFulfilled, onRejected) &#123;  var done = false;  try &#123;    fn(function (value) &#123;      if (done) return      done = true      onFulfilled(value)    &#125;, function (reason) &#123;      if (done) return      done = true      onRejected(reason)    &#125;)  &#125; catch (ex) &#123;    if (done) return    done = true    onRejected(ex)  &#125;&#125;var promise1 = new Promise(function(resolve, reject) &#123;  setTimeout(function() &#123;    resolve(&#39;foo&#39;);  &#125;, 3000);&#125;);promise1.then(function(value) &#123;  console.log(value)  // expected output: &quot;foo&quot;&#125;);console.log(promise1);</code></pre><p><img src="/images/Promise.png" alt="Promise"></p><p>一些帮助理解这段代码的小 tips：</p><ol><li><code>doResolve()</code> ，第一，会直接执行 <code>fn</code> 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 <code>resolve</code> 或是 <code>reject</code> function 仅执行一次。</li><li>每次声明 Promise object，都会先执行一次 <code>doResolve()</code> 函数；</li><li><code>.then()</code> 返回一个新的 Promise object，这个 Promise 会执行 <code>doResolve()</code>  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 <code>self.done()</code> 函数的执行结果；</li><li><code>.done()</code> 方法会 check state 的值，确定是否将 <code>resolve</code> 添加进 <code>handlers</code> 中；</li><li><code>resolve</code> 函数执行完毕后，将 <code>state</code> 从 <code>PENDING</code> 改为了 <code>FULFILLED</code>，同时 <code>handlers.forEach(handle)</code> 依次执行 <code>.then</code> 方法中添加进去的函数。</li><li><code>resolve</code> 和 <code>reject</code> 都会将值赋给 <code>value</code> 变量；</li><li><code>setTimeout(cb, 0)</code> 使用了上述提到的 event loop，此时 <code>cb</code> 会在几乎 0ms 的间隔时间后，进入 task queue。</li></ol><p>参考链接：</p><ul><li><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></p></li><li><p><a href="https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s">Async JS Crash Course - Callbacks, Promises, Async Await</a></p></li><li><p><a href="https://www.promisejs.org/implementing/">Implementing</a></p></li><li><p><a href="https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt">Basic Javascript promise implementation attempt</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。&lt;/p&gt;
&lt;h2 id=&quot;Event-loop&quot;&gt;&lt;a href=&quot;#Event-loop&quot; class=&quot;headerlink&quot; title=&quot;Event loop&quot;&gt;&lt;/a&gt;Event loop&lt;/h2&gt;&lt;p&gt;JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;$.get(&amp;#39;http://twitter.com&amp;#39;)
$.get(&amp;#39;http://youtube.com&amp;#39;)
$.get(&amp;#39;http://google.com&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，程序似乎不会出现 blocking。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Javascript&quot;&gt;console.log(&amp;#39;hi&amp;#39;)
setTimeout(() =&amp;gt; console.log(&amp;#39;there&amp;#39;), 0)
console.log(&amp;#39;Welcome!&amp;#39;)

// output:
// hi
// Welcome
// there
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里哪怕是设置 delay 为 0s， &lt;code&gt;setTimeout()&lt;/code&gt; 里的函数也是在最后才执行，是怎么回事呢？&lt;/p&gt;
&lt;p&gt;在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 &lt;code&gt;setTimeout()&lt;/code&gt; 函数就来自这些提供的 API 中。当我们 declare and call  一个  &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  &lt;code&gt;setTimeout()&lt;/code&gt;  里定义的 callback 函数会进入到一个叫 &lt;code&gt;task queue&lt;/code&gt; 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  &lt;code&gt;setTimeout()&lt;/code&gt; 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>赤烛 - 『还愿』</title>
    <link href="http://reyshawn.com/2019/02/23/%E8%B5%A4%E7%83%9B%20-%20%E3%80%8E%E8%BF%98%E6%84%BF%E3%80%8F/"/>
    <id>http://reyshawn.com/2019/02/23/赤烛 - 『还愿』/</id>
    <published>2019-02-23T03:18:14.000Z</published>
    <updated>2019-02-23T03:18:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。</p><blockquote><p>奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。</p><p>–<a href="https://hardimage.pro/32">『奇异的……』 Episode 32 - 硬影像</a></p></blockquote><p>『还愿』同样是具有「奇情片」内核的恐怖游戏。</p><p>以下内容涉及剧透。</p><p>『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。</p><span id="more"></span><blockquote><p>以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。</p><p>…</p><p>此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。</p><p>–wikipedia 美麗島事件</p></blockquote><p>「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。</p><p>最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际<del>游玩</del>（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。</p><p><img src="/images/Game/devotion.png" alt="devotion"></p><p>1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。</p><blockquote><p>台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。</p><p>电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。</p><p>–『我们台湾这些年』</p></blockquote><p>也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。</p><blockquote><p>民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。</p><p>–wikipedia 大家樂 (賭博) </p></blockquote><p>就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。</p><p>父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。</p><p>故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。</p><p>母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。</p><p>整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。</p><p>参考</p><ul><li><a href="https://hardimage.pro/32">『奇异的……』 Episode 32 - 硬影像</a></li><li>『我们台湾这些年』</li><li><a href="https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl,wn">還願Devotion | 玩之前必知的七大民俗文化知識AdamDD</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。&lt;/p&gt;
&lt;p&gt;–&lt;a href=&quot;https://hardimage.pro/32&quot;&gt;『奇异的……』 Episode 32 - 硬影像&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;『还愿』同样是具有「奇情片」内核的恐怖游戏。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
&lt;p&gt;『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="http://reyshawn.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>棋盘上的「古墓丽影」</title>
    <link href="http://reyshawn.com/2019/02/07/%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E3%80%8C%E5%8F%A4%E5%A2%93%E4%B8%BD%E5%BD%B1%E3%80%8D/"/>
    <id>http://reyshawn.com/2019/02/07/棋盘上的「古墓丽影」/</id>
    <published>2019-02-07T13:39:29.000Z</published>
    <updated>2019-02-07T13:39:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。</p><p>![Lara Go 1](/images/Game/Lara Go 1.jpg)</p><p>游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。</p><p>以下内容涉及剧透。</p><span id="more"></span><p><img src="/images/Game/Go-Trilogy.png" alt="Go-Trilogy"></p><p>Lara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。</p><p>最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。</p><p>![Lara Go ](/images/Game/Lara Go .jpg)</p><p>![Lara Go 3](/images/Game/Lara Go 3.jpg)</p><p>说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。</p><p>![Lara Go 2](/images/Game/Lara Go 2.jpg)</p><p>这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。</p><blockquote><p>Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new <em>Go</em> games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the <em>Go</em> games are each $4.99), saying that it’s “such a big barrier for mobile users.”</p></blockquote><p>在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。</p><p>参考：</p><ul><li><a href="https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play">Square Enix Montreal is no longer making Go games - The Verge</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。&lt;/p&gt;
&lt;p&gt;![Lara Go 1](/images/Game/Lara Go 1.jpg)&lt;/p&gt;
&lt;p&gt;游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="http://reyshawn.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>「User Authentication with Passport and Koa 」Summary</title>
    <link href="http://reyshawn.com/2019/02/02/%E3%80%8CUser%20Authentication%20with%20Passport%20and%20Koa%20%E3%80%8DSummary/"/>
    <id>http://reyshawn.com/2019/02/02/「User Authentication with Passport and Koa 」Summary/</id>
    <published>2019-02-02T14:15:36.000Z</published>
    <updated>2019-02-02T14:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href="https://mherman.org/blog/user-authentication-with-passport-and-koa/">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p><p>需要通过 brew 安装：</p><ul><li>postgresql</li><li>redis</li></ul><p>使用 npm 全局安装：</p><ul><li>knex</li></ul><span id="more"></span><h2 id="文件结构，逻辑"><a href="#文件结构，逻辑" class="headerlink" title="文件结构，逻辑"></a>文件结构，逻辑</h2><p>文件最后的结构：</p><pre><code class="shell">.├── LICENSE├── README.md├── knexfile.js├── package-lock.json├── package.json├── src│   └── server│       ├── auth.js│       ├── db│       │   ├── connection.js│       │   ├── migrations│       │   │   ├── 20170817152841_movies.js│       │   │   └── 20190127152820_users.js│       │   ├── queries│       │   │   ├── movies.js│       │   │   └── users.js│       │   └── seeds│       │       ├── movies_seed.js│       │       └── users.js│       ├── index.js│       ├── routes│       │   ├── auth.js│       │   ├── index.js│       │   └── movies.js│       └── views│           ├── login.html│           ├── register.html│           └── status.html└── test    ├── routes.auth.test.js    ├── routes.index.test.js    ├── routes.movies.test.js    └── sample.test.js</code></pre><p>有一些文件夹，文件属于自动生成的 boilerplate，比如 <code>package.json</code>，<code>knexfile.js</code>，<code>db</code> 文件夹里的一些内容。项目的结构清晰明朗。<code>test</code> 为测试文件夹。测试文件的标题统一加上 <code>test</code> 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 <code>server</code> 文件夹下，<code>db</code> 几乎都是数据库，knex 相关的。另外有路由 <code>routes</code> 文件夹和 <code>views</code> 视图文件夹。</p><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 <code>service start</code> 的命令。这里是手动开启的办法：</p><pre><code class="shell">$ pg_ctl -D /usr/local/var/postgres start  </code></pre><p>和 Mysql 一样，把 <code>start</code> 可以换成 <code>stop</code>，<code>restart</code>。</p><p>数据库初始化：</p><pre><code class="shell">$ initdb /usr/local/var/postgres  </code></pre><p>在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：</p><pre><code class="shell">$ createdb koa_api    $ createdb koa_api_test</code></pre><p><code>psql</code> + Database，进入 database 的命令行。</p><p><code>\dt</code> 显示所有 tables</p><blockquote><p>Please note the following commands:</p><ul><li><code>\list</code> or <code>\l</code>: list all databases</li><li><code>\dt</code>: list all tables in the current database</li></ul><p>You will never see tables in other databases, these tables aren’t visible. You have to connect to the correct database to see its tables (and other objects).</p><p>To switch databases:</p><pre><code>\connect database_name` or `\c database_name</code></pre><p>See the manual about <a href="http://www.postgresql.org/docs/current/interactive/app-psql.html">psql</a>.</p><p>– <a href="https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql">How do I list all databases and tables using psql?</a></p></blockquote><p>除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。</p><h2 id="knex"><a href="#knex" class="headerlink" title="knex"></a>knex</h2><blockquote><p><strong>Knex.js</strong> is a “batteries included” SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. </p><p>– <a href="https://knexjs.org/">Knex.js</a></p></blockquote><p>Knex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。</p><p><img src="/images/knex.png" alt="knex"></p><p>因为要频繁在 Terminal 里用到 <code>knex</code> 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：</p><pre><code class="shell">$ knex migrate:latest --env development$ knex seed:run --env development</code></pre><hr><p><em>Tips：</em></p><p><em>如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 <code>node_modules</code> 文件夹下会有个隐藏文件夹 <code>.bin</code>，里面包含了全部我们可以直接运行的 package。所以直接：</em></p><pre><code class="shell">$ node_modules/.bin/knex init</code></pre><hr><p><code>init</code> 之后，本地会自动生成一个 <code>knexfile.js</code> 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，    <code>knexfile.js</code> 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。</p><blockquote><p>Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using <code>knex</code>command line tool.</p></blockquote><p>例如，通过 knex 创建 table：</p><pre><code class="shell">$ knex migrate:make users</code></pre><p>这里会自动生成一个 <code>users.js</code> 文件，文件名前面还会有 time stamp。存储路径在 <code>./server/db/migration/</code>。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：</p><pre><code class="javascript">exports.up = (knex, Promise) =&gt; &#123;  return knex.schema.createTable(&#39;users&#39;, (table) =&gt; &#123;    table.increments();    table.string(&#39;username&#39;).unique().notNullable();    table.string(&#39;password&#39;).notNullable();  &#125;);&#125;;exports.down = (knex, Promise) =&gt; &#123;  return knex.schema.dropTable(&#39;users&#39;);&#125;;</code></pre><p>通过下面这条命令来应用我们定义的属性：</p><pre><code class="shell">knex migrate:latest --env development</code></pre><blockquote><p>To run the migration, use the command:</p><pre><code>knex migrate:latest</code></pre><p>The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the <em>env</em> flag in the migration command like:</p><pre><code>knex migrate:latest --env test</code></pre></blockquote><p><code>development</code> 是我们事先在 <code>knexfile.js</code> 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 <code>username</code> 和 <code>password</code>。以及每个 field 的属性都通过 chain function 的形式来表达。</p><blockquote><p>Similar to migrations, the <code>knex</code> module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding <strong>must be in a specific order</strong> to so that we can rely on data that might already be in the database. </p></blockquote><p>seed 是用来初始化数据的。同 migrate 一样：</p><pre><code class="shell">$ knex seed:make users$ knex seed:run --env development</code></pre><p>line 1 会自动创建一个 <code>user.js</code> 在路径 <code>./server/db/seeds/</code> 里。line 2 运行这个 seeds，对 table 里数据进行初始化。</p><h2 id="Mocha-js-Chai-js"><a href="#Mocha-js-Chai-js" class="headerlink" title="Mocha.js ,  Chai.js"></a>Mocha.js ,  Chai.js</h2><p>一个测试 module 被称为 specification，简称 spec，结构如下图所示：</p><p><img src="/images/Mocha_test.png" alt="Mocha_test"></p><p>在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。</p><blockquote><ul><li><a href="http://mochajs.org/">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li><li><a href="http://chaijs.com/">Chai</a> – the library with many assertions. It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li></ul></blockquote><p>使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。</p><blockquote><p>Mocha automatically looks for tests inside the <code>**test**</code> directory of your project. Hence, you should go ahead and create this directory in your project root.</p></blockquote><p>以下是写的一个很简单的小例子：</p><pre><code class="javascript">const assert = require(&#39;assert&#39;);describe(&quot;sample&quot;, ()=&gt;&#123;    it(&quot;it&#39;s just a test&quot;, ()=&gt;&#123;        let x = 5;        let result = x;        assert.equal(Math.pow(x, 1), result);    &#125;);&#125;);</code></pre><p>在 Terminal 里运行：</p><pre><code class="shell">$ node_modules/.bin/_mocha  sample    ✓ it&#39;s just a test  1 passing (6ms)</code></pre><p>Chai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：</p><pre><code class="javascript">describe(&#39;GET /auth/register&#39;, () =&gt; &#123;  it(&#39;should render the register view&#39;, (done) =&gt; &#123;    chai.request(server)    .get(&#39;/auth/register&#39;)    .end((err, res) =&gt; &#123;      should.not.exist(err);      res.redirects.length.should.eql(0);      res.status.should.eql(200);      res.type.should.eql(&#39;text/html&#39;);      res.text.should.contain(&#39;&lt;h1&gt;Register&lt;/h1&gt;&#39;);      res.text.should.contain(        &#39;&lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;&lt;/p&gt;&#39;);      done();    &#125;);  &#125;);&#125;);</code></pre><p>其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。</p><h2 id="Redis-Session"><a href="#Redis-Session" class="headerlink" title="Redis, Session"></a>Redis, Session</h2><p>这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。</p><blockquote><p>It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.</p></blockquote><p>Redis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。</p><p>关于 session 和 cookie 的区别。</p><p>cookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。</p><blockquote><p>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)</p><p>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may “steal” another uses’s session)</p></blockquote><p>这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。</p><p>把 session 存储在 redis 的优势：</p><blockquote><p>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. </p><p>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <a href="http://redis.io/topics/persistence">http://redis.io/topics/persistence</a> to learn more, but at a high level, here are your options …</p></blockquote><p>依旧是通过 brew 安装 redis。</p><p>redis 启动：</p><pre><code class="shell">$ redis-server /usr/local/etc/redis.conf</code></pre><p>redis 关闭，直接 <code>ctrl</code> + <code>C</code> 或是：</p><pre><code class="shell">$ redis-cli shutdown</code></pre><p>参考：</p><ul><li><a href="https://knexjs.org/">Knex.js</a></li><li><a href="https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc">Seed Knex PostgreSQL Database with JSON Data</a></li><li><a href="https://github.com/l4nk332/stuff/tree/master/node/Knex">l4nk332/stuff - Github</a></li><li><a href="https://www.zhihu.com/question/24710451">「batteries-included」该怎么翻译比较好？ - 知乎</a></li><li><a href="https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261">Migrations &amp; Seeding</a></li><li><a href="https://javascript.info/testing-mocha">Automated testing with mocha</a></li><li><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment">Run mocha tests in test environment? - StackOverflow</a></li><li><a href="https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d">A quick and complete guide to Mocha testing</a></li><li><a href="https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie">What is the difference between a Session and a Cookie? - StackOverflow</a></li><li><a href="https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis">How safe is it to store sessions with Redis?</a></li><li><a href="https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298">Install and config Redis on Mac OS X via Homebrew</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周在阅读 &lt;em&gt;Express.js Blueprints&lt;/em&gt; 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 &lt;a href=&quot;https://mherman.org/blog/user-authentication-with-passport-and-koa/&quot;&gt;User Authentication with Passport and Koa&lt;/a&gt; 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。&lt;/p&gt;
&lt;p&gt;需要通过 brew 安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postgresql&lt;/li&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 npm 全局安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knex&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>初见 Koa.js</title>
    <link href="http://reyshawn.com/2019/01/26/%E5%88%9D%E8%A7%81%20Koa/"/>
    <id>http://reyshawn.com/2019/01/26/初见 Koa/</id>
    <published>2019-01-26T11:41:00.000Z</published>
    <updated>2019-01-26T11:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p><ul><li>Node.js 的异步特性及异步是如何实现的</li><li>异步实现的几种方式，callback 到 Promise 到 async/await</li><li>什么是 middleware？</li><li>ejs template engine</li></ul><p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p><span id="more"></span><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>app.use()</code> 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 <code>app.use()</code> 来实现的。</p><p><code>ctx</code> 内封装了 request 和 response  object。</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async function(ctx) &#123;    ctx.body = &quot;hello world ssss&quot;;&#125;)app.listen(3000, function() &#123;    console.log(&#39;listen port: 3000...&#39;)&#125;)</code></pre><h2 id="渲染-ejs-模版"><a href="#渲染-ejs-模版" class="headerlink" title="渲染 ejs 模版"></a>渲染 ejs 模版</h2><p>这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。</p><p>使用 npm 安装：</p><pre><code class="shell">$ npm install koa-views --save$ npm install ejs --save</code></pre><p>server.js 内容是</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();const views = require(&#39;koa-views&#39;);app.use(views(__dirname + &#39;/views&#39;, &#123;    map: &#123;        html: &#39;ejs&#39;    &#125;&#125;));app.use(async function(ctx) &#123;    await ctx.render(&#39;layout.ejs&#39;);&#125;)app.listen(3000, function() &#123;    console.log(&#39;listen port: 3000...&#39;)&#125;)</code></pre><p><code>./views/layout.ejs</code> 内容是</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello Koa, This is from ejs&lt;/h1&gt;&lt;/body&gt;</code></pre><p>上面这个例子是不包含传值的，当需要向 template 传递值时，通过 <code>ctx.state</code> 来设置，将上面 render 部分修改成：</p><pre><code class="javascript">app.use(async function(ctx) &#123;    ctx.state = &#123;        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    &#125;;    await ctx.render(&#39;layout.ejs&#39;);&#125;)</code></pre><p>或者写成 <code>render</code> 的参数，二者是等价的：</p><pre><code class="javascript">app.use(async function(ctx) &#123;    await ctx.render(&#39;layout.ejs&#39;, &#123;        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    &#125;);&#125;)</code></pre><p>此时 template 修改成：</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><p>通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？</p><p>这里直接在 ejs 里使用 <code>include</code> 进行引用。</p><p>header.ejs</p><pre><code class="html">&lt;header&gt;    &lt;p&gt;This is a header&lt;/p&gt;&lt;/header&gt;</code></pre><p>layout.ejs</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h2 id="Router-路由功能"><a href="#Router-路由功能" class="headerlink" title="Router 路由功能"></a>Router 路由功能</h2><p>对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。</p><p><img src="/images/koa_routing.png" alt="koa_routing"></p><pre><code class="shell">$ npm install koa-router --save</code></pre><p>server.js 中修改为：</p><pre><code class="javascript">const Router = require(&#39;koa-router&#39;);const router = new Router()router.get(&#39;/&#39;, async function(ctx) &#123;    await ctx.render(&#39;layout.ejs&#39;, &#123;        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    &#125;);&#125;)app.use(router.routes());</code></pre><p>我们看到，各个页面的渲染完全由 router 进行了接管。</p><p>上面是最简单的 “Get” 请求，下面是给出一个”Post” 请求的例子，来自 <a href="https://chenshenhai.github.io/koa2-note/note/request/post.html">koa2 进阶学习笔记</a>，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 <code>koa-router</code> 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。</p><pre><code class="javascript">// receive the posting datafunction parsePostData(ctx) &#123;    return new Promise((resolve, reject) =&gt; &#123;        try &#123;            let postData = &quot;&quot;;            ctx.req.addListener(&#39;data&#39;, (data) =&gt; &#123;                postData += data;            &#125;);            ctx.req.addListener(&#39;end&#39;, () =&gt; &#123;                let parseData = parseQueryStr(postData);                resolve(parseData);            &#125;);        &#125; catch(err) &#123;            reject(err);        &#125;    &#125;)&#125;// convert the posting data to Objectfunction parseQueryStr(data) &#123;    let queryData = &#123;&#125;;    let queryStrList = data.split(&#39;&amp;&#39;);    for (let queryStr of queryStrList) &#123;        let itemList = queryStr.split(&#39;=&#39;);        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);    &#125;    return queryData;&#125;app.use(views(__dirname + &#39;/views&#39;, &#123;    map: &#123;        html: &#39;ejs&#39;    &#125;&#125;));router.get(&#39;/&#39;, async function(ctx) &#123;    await ctx.render(&#39;layout.ejs&#39;, &#123;        data: &#39;no data posted&#39;    &#125;);&#125;)router.post(&#39;/&#39;, async function(ctx) &#123;    let postData = await parsePostData(ctx);    await ctx.render(&#39;layout.ejs&#39;, &#123;        data: JSON.stringify(postData)    &#125;)&#125;)app.use(router.routes());</code></pre><p>layout.ejs 添加一个可以提交的表格，注意表格的 <code>method</code> 是 <code>POST</code>，<code>action</code> 是根目录页面 <code>&quot;/&quot;</code>。 </p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;koa2 request post demo&lt;/h1&gt;      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;            &lt;p&gt;userName&lt;/p&gt;            &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;nickName&lt;/p&gt;            &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;email&lt;/p&gt;            &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;      &lt;/form&gt;      &lt;p&gt;&lt;%- data %&gt;&lt;p&gt;&lt;/body&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 的异步特性及异步是如何实现的&lt;/li&gt;
&lt;li&gt;异步实现的几种方式，callback 到 Promise 到 async/await&lt;/li&gt;
&lt;li&gt;什么是 middleware？&lt;/li&gt;
&lt;li&gt;ejs template engine&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>异步 &amp; callback</title>
    <link href="http://reyshawn.com/2019/01/25/%E5%BC%82%E6%AD%A5%20&amp;%20callback/"/>
    <id>http://reyshawn.com/2019/01/25/异步 &amp; callback/</id>
    <published>2019-01-25T08:52:18.000Z</published>
    <updated>2019-01-25T08:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href="https://search.packtpub.com/">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p><p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p><span id="more"></span><h2 id="callback，递归，libuv"><a href="#callback，递归，libuv" class="headerlink" title="callback，递归，libuv"></a>callback，递归，libuv</h2><blockquote><p>Callbacks are to be used when we don’t know <strong>when</strong> something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  <a href="http://www.wikiwand.com/en/Call_stack">Call stack</a>。那么为什么可以通过 callback 来实现异步？</p><pre><code class="javascript">// This is synchronous.function processData() &#123;       let data = fetchData();       data += 1;       return data; &#125;// This is asynchronous... function processData(callback) &#123;       fetchData(function (err, data) &#123;             if (err) &#123;           return callback(err);        &#125;             data += 1;             callback(null, data);       &#125;); &#125;</code></pre><p>在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 <code>fetchData()</code> 多了一个 callback 参数，后续的数据处理，<code>data += 1 </code> 写在了这个 callback 里。也就意味着，当调用 <code>fetchData()</code> 后，整个程序不会停下来等待，而是接着进行下面的操作。当 <code>fetchData()</code> 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。</p><blockquote><p>Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 <code>libuv</code> 来实现。<code>libuv</code> 让 Node.js 有了 non-blocking I/O 特性。</p><blockquote><p>For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p><p>– p17 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.</p><p>–p71 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 </p><p>–<a href="https://zhuanlan.zhihu.com/p/50480439">libuv — 知乎专栏</a></p></blockquote><p>这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 <code>libuv</code>，会让有着 callback 的函数会进行「异步」操作。</p><blockquote><p>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p><p>–<a href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced">JavaScript: What the heck is a Callback?</a></p></blockquote><p>关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。</p><blockquote><p>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. </p><p>– <a href="https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure">understanding node.js callback structure</a></p></blockquote><h2 id="Web-Spider-的-callback-实现"><a href="#Web-Spider-的-callback-实现" class="headerlink" title="Web Spider 的 callback 实现"></a>Web Spider 的 callback 实现</h2><p>在 <em>Node.js Design Patterns</em> 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 <code>fs.stat(path, callback)</code> 和 <code>request(url, callback)</code>[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。</p><pre><code class="javascript">function download(url, filename, callback) &#123;  console.log(`Downloading $&#123;url&#125;`);  request(url, (err, response, body) =&gt; &#123;    if(err) &#123;      return callback(err);    &#125;    saveFile(filename, body, err =&gt; &#123;      if(err) &#123;        return callback(err);      &#125;      console.log(`Downloaded and saved: $&#123;url&#125;`);      callback(null, body);    &#125;);  &#125;);&#125;function spider(url, callback) &#123;  const filename = utilities.urlToFilename(url);  fs.stat(filename, err =&gt; &#123;    if(!err) &#123;      return callback(null, filename, false);    &#125;    download(url, filename, err =&gt; &#123;      if(err) &#123;        return callback(err);      &#125;      callback(null, filename, true);    &#125;)  &#125;);&#125;</code></pre><h3 id="fs-stat"><a href="#fs-stat" class="headerlink" title="fs.stat()"></a>fs.stat()</h3><p>首先进入 <code>fs.stat()</code> 函数：</p><pre><code class="javascript">function stat(path, options, callback) &#123;  if (typeof options === &#39;function&#39;) &#123;    callback = options;    options = &#123;&#125;;  &#125;  callback = makeStatsCallback(callback);  path = toPathIfFileURL(path);  validatePath(path);  const req = new FSReqCallback(options.bigint);  req.oncomplete = callback;  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);&#125;</code></pre><p>line 2 到 line 5 是参数判断和转换。line 6 <code>makeStatsCallback(callback)</code>，调用：</p><pre><code class="Javascript">// Special case of `makeCallback()` that is specific to async `*stat()` calls as// an optimization, since the data passed back to the callback needs to be// transformed anyway.function makeStatsCallback(cb) &#123;  if (typeof cb !== &#39;function&#39;) &#123;    throw new ERR_INVALID_CALLBACK();  &#125;  return (err, stats) =&gt; &#123;    if (err) return cb(err);    cb(err, getStatsFromBinding(stats));  &#125;;&#125;</code></pre><p>按照注释说明，是 <code>makeCallback()</code> 的特殊情况，那我们就去看看 <code>makeCallback()</code> 是什么。</p><pre><code class="javascript">// Ensure that callbacks run in the global context. Only use this function// for callbacks that are passed to the binding layer, callbacks that are// invoked from JS already run in the proper scope.function makeCallback(cb) &#123;  if (typeof cb !== &#39;function&#39;) &#123;    throw new ERR_INVALID_CALLBACK();  &#125;  return (...args) =&gt; &#123;    return Reflect.apply(cb, undefined, args);  &#125;;&#125;</code></pre><p>这段 code  的关键是 <code>Reflect.apply(cb, undefined, args);</code>。按照 MDN 的叙述，<code>Reflect</code> 是：</p><blockquote><p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p><p>Unlike most global objects, <code>Reflect</code> is not a constructor. You cannot use it with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code>operator</a> or invoke the <code>Reflect</code> object as a function. All properties and methods of <code>Reflect</code>are static (just like the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math"><code>Math</code></a> object).</p></blockquote><p>Reflect 是一个 global object。那么当调用 <code>Reflect.apply()</code>，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。</p><p><code>makeStatsCallback(callback)</code>之后关键的三步是：</p><pre><code class="javascript">const req = new FSReqCallback(options.bigint);req.oncomplete = callback;binding.stat(pathModule.toNamespacedPath(path), </code></pre><p><code>FSReqCallback</code> 和 <code>binding</code> 都是对更底层的 C library 调用。</p><pre><code class="javascript">const binding = process.binding(&#39;fs&#39;);const &#123; FSReqCallback, statValues &#125; = binding;</code></pre><p>从这里开始，就逐渐进入 <code>libuv</code> ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 <code>req.oncomplete = callback;</code> 字面含义所写的那样。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>request 是一个简单的 Http client。这是它们的 <a href="https://github.com/request/request">Git repo</a>。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 <code>fs.stat()</code> 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 <code>body</code> 内容。这些操作，都是通过 <code>request</code> 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 <code>request.Request(params)</code> 来实现的。</p><pre><code class="javascript">function request (uri, options, callback) &#123;  if (typeof uri === &#39;undefined&#39;) &#123;    throw new Error(&#39;undefined is not a valid uri or options object.&#39;)  &#125;  var params = initParams(uri, options, callback)  if (params.method === &#39;HEAD&#39; &amp;&amp; paramsHaveRequestBody(params)) &#123;    throw new Error(&#39;HTTP HEAD requests MUST NOT include a request body.&#39;)  &#125;  return new request.Request(params)&#125;</code></pre><p>line 6 对参数进行初始化：</p><pre><code class="javascript">// organize params for patch, post, put, head, delfunction initParams (uri, options, callback) &#123;  if (typeof options === &#39;function&#39;) &#123;    callback = options  &#125;  var params = &#123;&#125;  if (typeof options === &#39;object&#39;) &#123;    extend(params, options, &#123;uri: uri&#125;)  &#125; else if (typeof uri === &#39;string&#39;) &#123;    extend(params, &#123;uri: uri&#125;)  &#125; else &#123;    extend(params, uri)  &#125;  params.callback = callback || params.callback  return params&#125;</code></pre><p><code>request()</code> 函数返回的  <code>request.Request(params)</code>  如下：</p><pre><code class="javascript">function Request (options) &#123;  // if given the method property in options, set property explicitMethod to true  // extend the Request instance with any non-reserved properties  // remove any reserved functions from the options object  // set Request instance to be readable and writable  // call init  var self = this  // start with HAR, then override with additional options  if (options.har) &#123;    self._har = new Har(self)    options = self._har.options(options)  &#125;  stream.Stream.call(self)  var reserved = Object.keys(Request.prototype)  var nonReserved = filterForNonReserved(reserved, options)  extend(self, nonReserved)  options = filterOutReservedFunctions(reserved, options)  self.readable = true  self.writable = true  if (options.method) &#123;    self.explicitMethod = true  &#125;  self._qs = new Querystring(self)  self._auth = new Auth(self)  self._oauth = new OAuth(self)  self._multipart = new Multipart(self)  self._redirect = new Redirect(self)  self._tunnel = new Tunnel(self)  self.init(options)&#125;</code></pre><p>注意一下 line 17，<code>stream.Stream.call(self)</code>，在进入这个函数内部后，来到：</p><pre><code class="javascript">// legacy.jsconst EE = require(&#39;events&#39;);const util = require(&#39;util&#39;);function Stream() &#123;  EE.call(this);&#125;</code></pre><p>因为 EE 是来自 events 导出的 EventEmitter，<code>EE.call(this)</code> 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：</p><p><code>EventEmitter</code> &lt;- <code>stream.Stream</code> &lt;- <code>Request</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章最初是想弄清楚 <code>fs</code> 和 <code>request</code> 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 <code>libuv</code> ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。</p><p>[^1]: 原文判断文件存在用的是 <code>fs.exists()</code>，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。</p><hr><p>参考：</p><ul><li><a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca">Callbacks in Node.js: Why, When, How?</a></li><li><a href="https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean">Nodejs: What does <code>process.binding</code> mean?</a></li><li><a href="https://zhuanlan.zhihu.com/p/40977678">深入出不来nodejs源码-从fs.stat看node架构</a></li><li><a href="https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code">Node.js_Design Patterns Second Edition Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习 Node.js。主要看两本书：&lt;em&gt;Node.js in Practice&lt;/em&gt; 和 &lt;em&gt;Node.js Design Patterns&lt;/em&gt;。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;amp;solution 实现的。后者就是 &lt;a href=&quot;https://search.packtpub.com/&quot;&gt;Packt Publishing&lt;/a&gt; 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。&lt;/p&gt;
&lt;p&gt;这篇文章以 &lt;em&gt;Node.js Design Patterns&lt;/em&gt; 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>1/n- Cycle | 6kyu</title>
    <link href="http://reyshawn.com/2019/01/23/1n-%20Cycle%20%7C%206kyu/"/>
    <id>http://reyshawn.com/2019/01/23/1n- Cycle | 6kyu/</id>
    <published>2019-01-23T01:31:08.000Z</published>
    <updated>2019-01-23T01:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Let be <code>n</code> an integer prime with <code>10</code> e.g. <code>7</code>. </p><p><code>1/7 = 0.142857 142857 142857 ...</code>.</p><p>We see that the decimal part has a cycle: <code>142857</code>. The length of this cycle is <code>6</code>. In the same way:</p><p><code>1/11 = 0.09 09 09 ...</code>. Cycle length is <code>2</code>.</p><p><strong>Task</strong></p><p>Given an integer n (n &gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.</p><p><strong>Exemples:</strong></p><pre><code class="python">cycle(5) = -1cycle(13) = 6 -&gt; 0.076923 076923 0769cycle(21) = 6 -&gt; 0.047619 047619 0476cycle(27) = 3 -&gt; 0.037 037 037 037 0370cycle(33) = 2 -&gt; 0.03 03 03 03 03 03 03 03cycle(37) = 3 -&gt; 0.027 027 027 027 027 0cycle(94) = -1 cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...</code></pre><p>Note</p><ul><li>Translators are welcome for all languages.</li></ul><span id="more"></span><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">import mathimport fractionsdef cycle(n) :    if n==2 or n==5 :        return -1    t = phi(n)    p = primes(t)    divisor = []    for i in p:        x = i        while t % i == 0:            divisor.append(i)            t //= i        if isprime(t):            divisor.append(t)            break    divisor.sort()    print(divisor)    for i in divisor:        if 10**i % n == 1:            break    return idef phi(n):    &#39;&#39;&#39;compute Euler&#39;s totient function values.&#39;&#39;&#39;    amount = 0    for k in range(1, n + 1):        if math.gcd(n, k) == 1:            amount += 1    return amountdef isprime(n):    &quot;&quot;&quot;Returns True if n is prime.&quot;&quot;&quot;    if n == 2:        return True    if n == 3:        return True    if n % 2 == 0:        return False    if n % 3 == 0:        return False    i = 5    w = 2    while i * i &lt;= n:        if n % i == 0:            return False        i += w        w = 6 - w    return Truedef primes(limit):    D = &#123;&#125;    q = 2    while q &lt;= limit:        if q not in D:            yield q            D[q * q] = [q]        else:            for p in D[q]:                D.setdefault(p + q, []).append(p)            del D[q]        q += 1print(cycle(219199))</code></pre><p>这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：</p><pre><code class="python">10**p % n == 1</code></pre><p>其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。</p><p>但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 <code>219199</code>，它的循环位数是 <code>36180</code>。暴力写循环根本就行不通！</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/lechevalier">lechevalier</a></p><pre><code class="python">def cycle(n):    if not n % 2 or not n % 5:        return -1    x, mods = 1, set()    while x not in mods:        mods.add(x)        x = 10 * x % n    return len(mods)</code></pre><p>lechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，<code>mods</code> 长度刚好是循环的位数？</p><p>方法类似这里给出的答案：<a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits">How to Calculate Recurring Digits?</a></p><blockquote><p>You can calculate the decimal representation of <code>a / b</code> using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by <code>b</code>, and find the next dividend as the remainder multiplied by 10 (“bringing down a 0”). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.</p></blockquote><p>明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。</p><p>![long division](/images/long division.png)</p><p>那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 </p><p>参考文章：</p><ul><li><a href="https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values">Calculating Euler’s totient function values.</a></li><li><a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits">How to Calculate Recurring Digits?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Let be &lt;code&gt;n&lt;/code&gt; an integer prime with &lt;code&gt;10&lt;/code&gt; e.g. &lt;code&gt;7&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/7 = 0.142857 142857 142857 ...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We see that the decimal part has a cycle: &lt;code&gt;142857&lt;/code&gt;. The length of this cycle is &lt;code&gt;6&lt;/code&gt;. In the same way:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/11 = 0.09 09 09 ...&lt;/code&gt;. Cycle length is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n (n &amp;gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;cycle(5) = -1
cycle(13) = 6 -&amp;gt; 0.076923 076923 0769
cycle(21) = 6 -&amp;gt; 0.047619 047619 0476
cycle(27) = 3 -&amp;gt; 0.037 037 037 037 0370
cycle(33) = 2 -&amp;gt; 0.03 03 03 03 03 03 03 03
cycle(37) = 3 -&amp;gt; 0.027 027 027 027 027 0
cycle(94) = -1 

cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Translators are welcome for all languages.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="http://reyshawn.com/tags/Algorithm/"/>
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="Python" scheme="http://reyshawn.com/tags/Python/"/>
    
  </entry>
  
</feed>
