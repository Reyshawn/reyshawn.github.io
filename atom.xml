<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>reyshawn.C</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reyshawn.com/"/>
  <updated>2020-12-31T04:20:16.958Z</updated>
  <id>http://reyshawn.com/</id>
  
  <author>
    <name>Reyshawn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「可我会永远喜欢你的，这和时间没关系，我想」</title>
    <link href="http://reyshawn.com/2020/12/31/%E3%80%8C%E5%8F%AF%E6%88%91%E4%BC%9A%E6%B0%B8%E8%BF%9C%E5%96%9C%E6%AC%A2%E4%BD%A0%E7%9A%84%EF%BC%8C%E8%BF%99%E5%92%8C%E6%97%B6%E9%97%B4%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%88%91%E6%83%B3%E3%80%8D/"/>
    <id>http://reyshawn.com/2020/12/31/「可我会永远喜欢你的，这和时间没关系，我想」/</id>
    <published>2020-12-31T02:15:28.000Z</published>
    <updated>2020-12-31T04:20:16.958Z</updated>
    
    <content type="html"><![CDATA[<p>每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。</p><blockquote><p>“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” </p><p>“可我会永远喜欢你的，这和时间没有关系，我想。”</p><p>– 「舞！舞！舞！」</p></blockquote><a id="more"></a><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p><img src="/images/switch_2020.png" alt="switch 2020"></p><ul><li>The Legend of Zelda: Breath of the Wild</li><li>Hades</li><li>Animal Crossing: New Horizons</li><li>火焰纹章：风花雪月</li><li>Ori and the Will of the Wisps</li></ul><p>在年初疫情肆虐的日子，每个人都出不了门的时候。我每天大量的时间，除了吃饭之外，就是坐在电视机前玩塞尔达。塞尔达这个游戏，在 17 年刚发售时候我就被惊艳到了，也是因为塞尔达认识到了女流的直播，甚至有过整晚不睡觉看塞尔达的录播视频的场景。所以在我真正玩到塞尔达的时候，我对它的剧情已经是比较了解的。但尽管这样，它依然让我异常沉迷。印象最深刻的是，生日当天终于打通「剑之试炼」，前后经历数个小时，打完后关掉电视，躺在床上休憩，内心仍然砰砰直跳心有余悸。</p><p>2021 年最期待塞尔达的续作。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul><li>Stuck With U (Originally Performed by Ariana Grande and Justin Bieber) by Vox Freaks</li><li>「ラブ・ストーリーは突然に」 by 極東ラヴァーズオーケストラ</li><li>Zelda &amp; Chill by Mikel &amp; GameChops</li><li>Zelda &amp; Chill 2 by Mikel &amp; GameChops</li><li>如果你爱我 by Tanya Chua</li></ul><p><a href="https://music.apple.com/us/playlist/replay-2020/pl.rp-1kk4hg2wldW" target="_blank" rel="noopener">Replay 2020 - Apple Music for Reyshawn</a></p><p>(上面的链接，国内用户需要挂代理才可以打开。)</p><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><ul><li>「舞！舞！舞！」</li></ul><p>非技术类书籍，今年只看了「舞！舞！舞！」，是在去往九江以及回来的列车上看的。偶然一天发现亚马逊上有了村上书的电子版，于是买了很多，但一直搁置着还没有去看。</p><p><img src="/images/%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81%E8%88%9E%EF%BC%81.png" alt="舞！舞！舞！"></p><p>技术类书籍看了一些：</p><ul><li>Combine Asynchronous Programming with Swift</li><li>Node.js Design Patterns</li><li>iOS Development with Swift</li><li>Programming iOS 13</li><li>Python Parallel Programming Cookbook</li></ul><p>闲暇时间看了许多 iOS 开发相关的书籍，也学了 swift, swiftUI, UIKit 这些内容。</p><h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><p><img src="/images/movies_2020.PNG" alt="movies 2020"></p><p>看了极少的电影，比之上一年数量锐减。一个原因是空闲时间减少，还有今年空闲时间也花了大量时间去玩游戏。</p><h3 id="时刻"><a href="#时刻" class="headerlink" title="时刻"></a>时刻</h3><p>今年一些值得纪念的时刻：</p><blockquote><p><em>2020.06.23</em></p><p>凌晨两点半看到 Alan Dye 介绍新的 Big Sur 系统，是 2020 年难得 的特别感动的时刻。</p></blockquote><p>背景音乐是 vox freak 版本的 <em>Ur So F**kInG cOoL</em>，节奏感很好，后来的那段视频被我反复播放。感动在于，这些呈现出来的视觉、听觉和交互，背后是严谨的 coding 和 design，也正是我一生所去追求的东西。</p><blockquote><p><em>2020.11.12</em></p><p>今年最震撼的事情，New M1 chip has beaten all intel-based MacBooks.</p><p><a href="https://browser.geekbench.com/v5/cpu/4652635" target="_blank" rel="noopener">https://browser.geekbench.com/v5/cpu/4652635</a><br><a href="https://browser.geekbench.com/v5/cpu/4648107" target="_blank" rel="noopener">https://browser.geekbench.com/v5/cpu/4648107</a></p></blockquote><p>M1 芯片的发布相当震撼。期待明年的 16寸 MBP。</p><blockquote><p><em>2020.11.19</em></p><p>看 The Queen‘s Gambit S01E03 的最后一幕，Beth 上车后，握住养母的手，背景音乐 the End of World 响起，那个场景，节奏真的是被击中了！上次有这种感觉是看是枝裕和的「比海更深」。</p></blockquote><p>这种「突然被戳中」感觉，看电影的时候会时有发生，我会很珍惜这样的时刻。</p><h3 id="期待"><a href="#期待" class="headerlink" title="期待"></a>期待</h3><p>来讲一讲明年的期待吧：</p><ul><li>塞尔达续作</li><li>搭载 Apple Silicon 芯片的 16 寸 MacBook Pro</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>然而事实是，我们只能往前走，往回看。哪怕在往回看的当口，时间也在往前走。2020 年倏地一下过去，我依然会在每周，每月，甚至是当下的每年，告诉自己未来仍旧有一些值得期待的美好事物。这些期待，在我面对无比凶险的明天的时候，让我还保有一些动力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每每到年末，大部分时候都是一个人度过。通常的仪式是看一部电影，有几次是用手机录音，对自己说一些想说的话，存储起来，借以日后怀念。一年三百六十六天，发生了许多事情，大大小小。目前的状态是，我会花很多的时间回忆过去，回忆过去的许多事情，玩过的游戏，看过的动漫，拍过的照片。好像未来只会越来越糟，经过大脑滤镜美化后的回忆，无限向往。真的无比想要回到过去，无比想要回去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“是的。他一直对将有什么消失这点耿耿于怀，其实何必那样呢？任何东西迟早都要消失。我们每个人都在移动当中生存，我们周围的东西都随着我们的移动而终究归于消失，这是我们所无法左右的。该消失的时候自然消失，不到消失的时候自然不消失。比如你将长大成人，再过两年，这身漂亮的连衣裙就要变得不合尺寸，对Talking Heads你也可能感到陈腐不堪，而且再也不想和我一起兜什么风了。这是没有办法的事情，只能随波逐流，想也无济于事。” &lt;/p&gt;
&lt;p&gt;“可我会永远喜欢你的，这和时间没有关系，我想。”&lt;/p&gt;
&lt;p&gt;– 「舞！舞！舞！」&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
      <category term="电影" scheme="http://reyshawn.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>十年回顾</title>
    <link href="http://reyshawn.com/2020/01/01/%E5%8D%81%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <id>http://reyshawn.com/2020/01/01/十年回顾/</id>
    <published>2020-01-01T05:50:15.000Z</published>
    <updated>2020-12-31T02:27:22.292Z</updated>
    
    <content type="html"><![CDATA[<p>我在两个月前的某<a href="https://www.apesk.com/mbti/" target="_blank" rel="noopener">测评网站</a>上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是<a href="https://movie.douban.com/subject/1851857/" target="_blank" rel="noopener">「蝙蝠侠：黑暗骑士」</a>，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。</p><p>从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。</p><a id="more"></a><h3 id="「骑着白马入地狱，叼着纸烟进天堂」"><a href="#「骑着白马入地狱，叼着纸烟进天堂」" class="headerlink" title="「骑着白马入地狱，叼着纸烟进天堂」"></a>「骑着白马入地狱，叼着纸烟进天堂」</h3><p><strong>2017 - 2019</strong></p><p>这句话是此前文章的一个标题。三年的时间，生活经历了巨大的反复。</p><p>2017.9.10，自己的文章标题<a href="[https://reyshawn.com/2017/09/10/I-O-23-%E3%80%8C%E9%AA%91%E7%9D%80%E7%99%BD%E9%A9%AC%E5%85%A5%E5%9C%B0%E7%8B%B1%EF%BC%8C%E5%8F%BC%E7%9D%80%E7%BA%B8%E7%83%9F%E8%BF%9B%E5%A4%A9%E5%A0%82%E3%80%8D/](https://reyshawn.com/2017/09/10/I-O-23-「骑着白马入地狱，叼着纸烟进天堂」/)">「骑着白马入地狱，叼着纸烟进天堂」</a>，那是我那一年德国生活的回顾，也是最后一次的 DSH 考试前夜。一个月后，我从德国回国，俄罗斯航空，莫斯科转机，到达雾霾的北京，刚好碰上十月国庆的人潮，一个人拖着两个箱子，和过去作别。</p><p>到达家乡火车站的时候，看到接我的父母，脸上满是焦虑不安。</p><p>在之后的很长的一段时间，我都处于一种很强的抑郁情绪中，当时的自己以为是抑郁，现在想来，应该是还没有达到病理的程度，只是，我当时有把这件事讲给好友听：</p><blockquote><p>这样情绪就是，在高楼看到窗子，会感觉有种奇怪的魔力，有什么东西在窗子上吸引着你，希望你从那里跳下去。</p></blockquote><p>处于一种强烈的抑郁情绪中，并且时刻有可能恶化，对周遭的事物开始麻木，并且和所有的人际关系脱节。所以这里很想提及在那段时间，短期或长期给我带来一些帮助的事情：</p><ul><li>Movies 🎬</li><li>Coding 💻</li><li>Basketball 🏀</li><li>Books 📚</li><li>Porn 🔞</li></ul><p>2018 年伊始，自己计划每天看一部电影，这样的事情持续了三个月，那一年一共看了 98 部电影。每天晚上 9 点钟，关掉所有的灯，一个人坐在沙发上，电影通过一台旧式的 Windows 笔记本连接电视机播放，观影的时间持续 2 到 3 个小时，结束后耐心写下「电影短评」。</p><p>2018 年入夏的时候，开始频繁的打篮球，家附近坐落一座体育馆，有不少篮球场，下午 5 点熙熙攘攘打球的人，自己时常抱着篮球，一个人去那里练习投篮，一个人在一个半场，捡球是一件特别费功夫的事情。</p><p>看电影，打篮球，coding，看书，甚至看 porn video，这些能够让我短暂的从现实抽离出来，获得一段时间的沉浸感，恢复学习的效率。但这样的沉浸感一旦消失，当每个夜晚降临，自己躺在床上看着天花板，闭着眼睛睡不着想着所有自己经历的事情的时候，发现自己面前依旧是一堵墙，过不去的墙，自己心中的问题并没有得到解答。以上的那些活动，并没有对我解答这个问题有太多帮助。</p><p>2019 年初，饶有兴趣的关注到一款 MC 评分很高的平台跳跃游戏「Celeste」，除夕购买，花了 7 天时间，在正月初七这一天，登上了「山顶」。那一天晚上，妈妈给我买了蛋糕，插了蜡烛，很多年没有吃蛋糕了。</p><p>后来的我，因为好友的一句话，去到了另一个城市，期间做了两次心理咨询，但对我的疑问并没有帮助。然后唯一让我突然走出来的，是和胡小姐的重新联系，以及听到的某期播客节目，持续不断的 coding，创造，产出。</p><blockquote><p>世上无难事，只要肯放弃。</p></blockquote><p>我开始逐渐认同这句话，也开始明白几年前自己巨大成本的「放弃」意味着什么。我脑中有许多有趣的想法，项目，2019 年的一段时间，自己完全进入一种 mind flow 状态时，每天会 coding 到很晚，完全进入一种 mind flow 的 development 模式，会忘记时间。到最后发现，自己完全有能力把自己的想法变为现实，也终于明白自己的热爱是什么。</p><blockquote><p>我希望以后的工作，首先不能是纯粹的重复性劳动，最好是需要理科缜密的逻辑思维，还有文科艺术上的审美要求，要有创造性。</p></blockquote><p>这是刚上大学的时候，当被问及自己将来想做什么工作时，给出的答案。几年的兜兜转转，这句话在我心中逐渐变得具象起来。</p><h3 id="「间奏曲，怀抱既然不能逗留」"><a href="#「间奏曲，怀抱既然不能逗留」" class="headerlink" title="「间奏曲，怀抱既然不能逗留」"></a>「间奏曲，怀抱既然不能逗留」</h3><p><strong>2012 - 2016</strong></p><p>2016 年的端口，每个人都开始怀念过去的四年生活。我在临别的前一晚，和室友吃过晚饭，将近凌晨的时候开始写些文字，写到凌晨两点，第二天上午的火车，从此以后，再也没有回去过。</p><blockquote><p>嗯，大学想要一些新的尝试，想要全方面的锻炼自己，不想再像过去那样只是呆板的读书了。</p></blockquote><p>2012 年，从高中进入大学的我，是这样对自己规划的。于是我尝试许多和自己性格很不相符的事情，又好像在这个时期，自己的 mbti 并非 INTJ 人格。然后发现，无论是哪一方面，无论是感情，学习都经历了严重的挫败，以及自我定位和过去也出现了巨大反差。但此时的我还不至于达到后来的那种抑郁情绪。</p><p>2012 到 2013 年，和胡小姐的重新联系，一年时间的异地恋，几次冲动的旅行，都成了那段时间里无法磨灭的注脚。</p><p>我怀念的，是夜晚坐在体育馆门口喝啤酒时场景。以及后来几次的冲动旅行，她的突然造访，和我坐在火车过道的场景。那种冲动往后可能再也不会有了，但好幸运的是，我们都拥有彼此这样冲动的经历。</p><p>2015 年开始广泛收听 podcast，这里暂且列一下自己最喜爱的 podcast 列表：</p><ul><li>IT 公论</li><li>反派影评</li><li>观影风向标</li><li>内核恐慌</li><li>得意忘形</li><li>游戏领航员</li><li>味之道</li><li>流行通信</li></ul><p>从那时起，听播客逐渐占据了生活中很大的比重，开始接受播客作为「wet wares」的存在，透过声音了解到许多有意思的事情，有趣的人，自己内心的观念也发生了巨大的变化。那段时期的我：开始认真的使用中文，中文标点，在一段时间里甚至是使用繁体作为个人的主要输入法。更加认真的选择信息源，开始阅读 economics 和 new yorker 文章，大量的消化这些文字，音频内容，每几周使用 markdown 写一些文字。开始频繁的观影，并认真的进行观影记录。尽管从这一年开始乃至往后，自己大多数时间都开始独处。在无数个独处的白天夜晚，podcast 和电影一直在陪伴我。</p><h3 id="「美丽生活」"><a href="#「美丽生活」" class="headerlink" title="「美丽生活」"></a>「美丽生活」</h3><p>2010 - 2012</p><p>更准确的这段时期，应该从 2009 年开始，但既然是十年回顾，就先略过高中的第一年吧。两年的时间过的飞快，生活也无比简单。在学习这件事上，可能是源于自己 INTJ 人格，从小到大其实父母催问的很少，现在想来，学习是一个很顺其自然的过程。</p><p>每个周末都要坐 BRT 穿越半个城市，回到空无一人的房子里，周末的傍晚，自己一个人边洗衣边看电视，这个片段在我脑海里不断被拾起。最开始学校附近还有一家音像店，回家的时候会过去买几张电影，家里没有网络，这些电影和电视是周末为数不多的娱乐活动。</p><p>现在还保存的三张电影光盘：</p><ul><li>裂缝</li><li>时间的灰烬</li><li>惧乳：伤心的奶水</li></ul><p><img src="/images/IMG_1578.JPG" alt="IMG_1578"></p><p>后来的第三年，周末很少回去，两天的时间就在宿舍度过。中午会去附近的「饺子店」吃盖浇饭，回来的时候在路边的报亭里买一本「看电影」杂志，也是这个时期开始频繁的购买「看电影」杂志，后来积攒了整整一箱，随着高中结束，那箱杂志也被遗忘在那间房子的一个角落。</p><p>尽管大部分都是学习生活，但仍旧有几个特别重要的时刻：足球赛上一记超远射门帮助我们进入决赛，决赛上点球大战输掉冠军。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><strong>2020 - 未知</strong></p><p>生活就是这样，此前也没想到会以这样的形式完成这次跨年。熬夜留下的晕眩感还在，不管怎样，第二天的太阳照常升起。不知道此生能否见到火星移民计划的实施，量子计算机量产的实现，AI 在 fidelity 上进一步趋近人的意识；希望有生之年去见证这个糟糕的世界的变化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在两个月前的某&lt;a href=&quot;https://www.apesk.com/mbti/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;测评网站&lt;/a&gt;上做了一次 mbti 测试，测试结果是 INTJ 型人格，「内向，直觉，思考，判断」。所以在大多数的跨年夜，或是某些重要的节日，都是一个人度过的。从 14 年开始每次跨年夜要一个人看一部电影，那一年看的是&lt;a href=&quot;https://movie.douban.com/subject/1851857/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「蝙蝠侠：黑暗骑士」&lt;/a&gt;，今年被好友叫去，说是那边组织的有个 party，于是过去，和一群陌生人完成了跨年，期间的大部分时间都在进行着「聚会游戏」，我极少有机会参加这样的聚会活动，但就这样，稀里糊涂的告别了 2019。&lt;/p&gt;
&lt;p&gt;从 2010 到 2019 的这个十年，自己个人经历了巨大的变化，往后不知道是否还会经历相似的十年，但在这个时间节点，我有必要通过某种形式，把我的回忆记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="I/O" scheme="http://reyshawn.com/categories/I-O/"/>
    
    
  </entry>
  
  <entry>
    <title>多个项目共享 Webpack</title>
    <link href="http://reyshawn.com/2019/08/29/%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%85%B1%E4%BA%AB-Webpack/"/>
    <id>http://reyshawn.com/2019/08/29/多个项目共享-Webpack/</id>
    <published>2019-08-29T13:00:03.000Z</published>
    <updated>2019-08-29T13:48:51.402Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 <a href>@keyframer</a> 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。</p><p>因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  <code>package.json</code> 里预先定义好 </p><pre><code class="json">&quot;scripts&quot;: {    &quot;dev&quot;: &quot;webpack-dev-server&quot;,    &quot;build&quot;: &quot;webpack&quot;}</code></pre><p>然后 <code>npm run dev</code>。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。</p><a id="more"></a><p>项目的结构是这样的：</p><pre><code class="shell">.├── Project1│   ├── dist│   ├── package.json│   ├── src│   └── webpack.config.js├── Project2│   ├── dist│   ├── package-lock.json│   ├── package.json│   ├── src│   └── webpack.config.js├── Project3│   ├── dist│   ├── package-lock.json│   ├── package.json│   ├── src│   └── webpack.config.js├── node_modules // all webpack related node modules├── package-lock.json└── package.json</code></pre><p>需要一个parent directory，在 parent directory 里首先 <code>npn init -y</code>，并安装好 webpack 和所有相关 node modules。为每一个子项目单独创建一个文件夹，把每个项目下 <code>package.json</code> 中的  <code>script</code> 修改成：</p><pre><code class="json">&quot;scripts&quot;: {    &quot;dev&quot;: &quot;../node_modules/.bin/webpack-dev-server&quot;,    &quot;build&quot;: &quot;../node_modules/.bin/webpack&quot; }</code></pre><p>这样一来，仅仅安装了一遍 webpack，每个子项目都可以 access 到 parent directory 里的 webpack。而且每个子项目都可以独立配置 webpack，配置文件为 <code>webpack.config.js</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 &lt;a href&gt;@keyframer&lt;/a&gt; 的一系列视频，需要用到 webpack 来配置 scss 环境，这就导致了每一个项目都要重复下载一遍 webpack 和相关的所有 node modules，这样很浪费空间。&lt;/p&gt;
&lt;p&gt;因此要想办法把 webpack 独立出来，让每一个项目都可以访问到 webpack，一个方法是全局安装 webpack。这里提供另一种方法，想到我们通常使用 webpack 的情景是，在  &lt;code&gt;package.json&lt;/code&gt; 里预先定义好 &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&amp;quot;scripts&amp;quot;: {
    &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后 &lt;code&gt;npm run dev&lt;/code&gt;。我们需要把这里修改一下，让每个项目都统一调用同一个 webpack。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issue #3</title>
    <link href="http://reyshawn.com/2019/07/12/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issue-3/"/>
    <id>http://reyshawn.com/2019/07/12/阅读摘要-issue-3/</id>
    <published>2019-07-12T09:33:53.000Z</published>
    <updated>2019-07-12T09:53:35.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Program-analysis"><a href="#Program-analysis" class="headerlink" title="Program analysis"></a><a href="https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases" target="_blank" rel="noopener">Program analysis</a></h2><p>GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？</p><p>程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：</p><ol><li>程序运行时所需要多少内存；</li><li>得到所有的 dependencies 并生成相应的 graph；</li><li>call graph，所有的函数调用关系；</li><li>control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；</li></ol><h2 id="The-Designer’s-Growth-Model"><a href="#The-Designer’s-Growth-Model" class="headerlink" title="The Designer’s Growth Model"></a><a href="https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137" target="_blank" rel="noopener">The Designer’s Growth Model</a></h2><p><a href="https://css-tricks.com/the-developers-growth-model/" target="_blank" rel="noopener">https://css-tricks.com/the-developers-growth-model/</a></p><p>模仿 <a href="https://wiki.mbalib.com/wiki/葛雷纳的企业成长模型" target="_blank" rel="noopener">Grenier</a> groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：</p><ol><li>第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；</li><li>第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；</li><li>第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；</li><li>第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；</li><li>第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；</li></ol><a id="more"></a><h2 id="CSS-Architecture-—-Folders-amp-Files-Structure"><a href="#CSS-Architecture-—-Folders-amp-Files-Structure" class="headerlink" title="CSS Architecture — Folders &amp; Files Structure"></a><a href="https://medium.com/@elad/css-architecture-folders-files-structure-f92b40c78d0b" target="_blank" rel="noopener">CSS Architecture — Folders &amp; Files Structure</a></h2><p>Elad Shechter 介绍了他的 CSS 文件结构。</p><h2 id="How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue"><a href="#How-to-Increase-Your-Page-Size-by-1-500-with-webpack-and-Vue" class="headerlink" title="How to Increase Your Page Size by 1,500% with webpack and Vue"></a><a href="https://css-tricks.com/how-to-increase-your-page-size-by-1500-with-webpack-and-vue/" target="_blank" rel="noopener">How to Increase Your Page Size by 1,500% with webpack and Vue</a></h2><p>Burke Holland 引入了 Bulma 来重构了它的网站，结果发现编译后 css 从原来 30kb 增加到了接近 300 kb。这里涉及到 Vue 中关于 css style 的 scoped 概念。因为 Bulma 被重复声明了十多次的缘故。解决办法就是 Bulma 首先要能够全局引入，Bulma 的变量要能够在各个 component 被调用。把 Bulma 的所有文件在 <code>main.js</code> 里导入即可，以及在 vue.config.js 增加 css.loadOptions.sass.data 的配置，让 components 能够使用预先定义的变量。</p><h2 id="Blendle"><a href="#Blendle" class="headerlink" title="Blendle"></a><a href="https://launch.blendle.com" target="_blank" rel="noopener">Blendle</a></h2><p>今天在美区 App Store 偶然看到这个。一家荷兰公司，和 New Yorker，The Economists 等报业集团合作，将内容打包统一放在他们这一个平台上，供人们选择阅读。</p><p>它的收费模式很有意思。文章按照单篇收费，大概20 - 40 美分不等，不满意可以退款。我下载下来适用了一下，免费的账户会有 0.45$。所有单篇文章价格小于这个数字的都可以打开，但更贵的文章就会提示 no enough credits。在一篇文章停留过长时间，超过 1min？就会判定为阅读，并从你的账户里扣除相应金额。但假如你不满意，可以 refund，被扣除的金额又会立即回来。</p><h2 id="Matrix-org"><a href="#Matrix-org" class="headerlink" title="Matrix.org"></a><a href="https://matrix.org" target="_blank" rel="noopener">Matrix.org</a></h2><p>一个开源的，e2e 加密，去中心化的 message 项目</p><blockquote><p>The not-so-talked-about but killer feature of Matrix is that you can bridge other services into it. I’m currently able to send and receive messages from Hangouts, iMessage, SMS, and Slack all from within Matrix. If I’m working on my laptop I can put my phone in my bag and not even touch it for 8 hours, because there’s no need. I have Riot running on my laptop with a full keyboard and access to all my communication platforms.<br>— <a href="https://news.ycombinator.com/item?id=20157809" target="_blank" rel="noopener">comments from Hacker News</a></p></blockquote><h2 id="Discoveries"><a href="#Discoveries" class="headerlink" title="Discoveries"></a>Discoveries</h2><p><a href="https://bennettfeely.com/clippy/" target="_blank" rel="noopener">Clippy - CSS clip-path maker</a></p><p><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/" target="_blank" rel="noopener">Which programming language is fastest? | Computer Language Benchmarks Game</a></p><p><em>Toy-program performance measurements for ~24 language implementations.</em></p><p><a href="https://observablehq.com" target="_blank" rel="noopener">Observable</a> </p><p><em>JavaScript 版本的 Juypter</em></p><p><a href="https://every-layout.dev" target="_blank" rel="noopener">Relearn CSS layout</a> </p><p><em>CSS layout</em></p><p><a href="https://jsperf.com" target="_blank" rel="noopener">jsPerf: JavaScript performance playground</a> </p><p><em>比较不同 js 写法的性能</em></p><p><a href="https://flutter.dev" target="_blank" rel="noopener">Flutter - Beautiful native apps in record time</a> </p><p><em>Google 推出的跨平台 UI 框架</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Program-analysis&quot;&gt;&lt;a href=&quot;#Program-analysis&quot; class=&quot;headerlink&quot; title=&quot;Program analysis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/github/semantic/blob/master/docs/program-analysis.md#potential-use-cases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Program analysis&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;GitHub 开源程序分析库 semantics，这里的一篇文章科普什么是程序分析 Program Analysis，以及它能用来做什么？&lt;/p&gt;
&lt;p&gt;程序静态分析，program static analysis，意味着在不运行程序的情况下，我们可以知道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序运行时所需要多少内存；&lt;/li&gt;
&lt;li&gt;得到所有的 dependencies 并生成相应的 graph；&lt;/li&gt;
&lt;li&gt;call graph，所有的函数调用关系；&lt;/li&gt;
&lt;li&gt;control flow graph，字面意思，程序运行时的 control flow，比如 if，for 循环这些；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;The-Designer’s-Growth-Model&quot;&gt;&lt;a href=&quot;#The-Designer’s-Growth-Model&quot; class=&quot;headerlink&quot; title=&quot;The Designer’s Growth Model&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://medium.com/design-leadership-notebook/the-designers-growth-model-8240dafb7137&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Designer’s Growth Model&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/the-developers-growth-model/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://css-tricks.com/the-developers-growth-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模仿 &lt;a href=&quot;https://wiki.mbalib.com/wiki/葛雷纳的企业成长模型&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grenier&lt;/a&gt; groth model，  Dennis Hambeukers 提出他的「设计师成长模型」，分为五个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段是 Producers，生产者，仅仅是作为个体，通过不断学习，设计创造好的 artifacts；&lt;/li&gt;
&lt;li&gt;第二阶段是 Architects，对于稍微复杂的项目，进入多人协作领域；&lt;/li&gt;
&lt;li&gt;第三阶段是 Connectors，不仅仅是多人「协」作，而能够真正做到多人「创」作；&lt;/li&gt;
&lt;li&gt;第四阶段是 Scientists，能够应对系统级别的复杂性 complexity，在更高一层级上进行思考，统筹，降低风险，指明方向；&lt;/li&gt;
&lt;li&gt;第五阶段是 Visionaries，skill, mind, toolset，所有一切集大成者，对于策略，组织，领导力又有着自己独到的见解，对于更远的未来有着自己清晰的解读，清晰的 roadmap；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lazy Evaluation, foldr | 5kyu</title>
    <link href="http://reyshawn.com/2019/07/06/Lazy-Evaluation/"/>
    <id>http://reyshawn.com/2019/07/06/Lazy-Evaluation/</id>
    <published>2019-07-06T04:42:24.000Z</published>
    <updated>2019-07-06T05:42:26.471Z</updated>
    
    <content type="html"><![CDATA[<p>关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：</p><pre><code class="javascript">// Evaluates with call-by-name strategy1 function callByName (a, b) {2  if (a === 1) {3    return 104  }5  return a + b6 }// Evaluates with call-by-value strategy1 function callByValue (a, b) {2  if (a === 1) {3    return 104  }5  return a + b6 }</code></pre><p>两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；</p><pre><code class="shell">&gt; callByName (1, 2 + 3)&gt; a === 1&gt; return 10&gt; callByValue(1, 2 + 3)&gt; callByValue(1, 5)&gt; a === 1&gt; return 10</code></pre><p>使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。</p><p>实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：</p><a id="more"></a><pre><code class="javascript">// Not lazyvar value = 1 + 1  // immediately evaluates to 2// Lazyvar lazyValue = () =&gt; 1 + 1  // Evaluates to 2 when lazyValue is *invoked*// Not lazyvar add = (x, y) =&gt; x + yvar result = add(1, 2)  // Immediately evaluates to 3// Lazyvar addLazy = (x, y) =&gt; () =&gt; x + y;var result = addLazy(1, 2)  // Returns a thunk which *when evaluated* results in 3.</code></pre><p>理解了这一概念，就明白 codewars 上这道题目的用意了。</p><p><a href="https://www.codewars.com/kata/foldr/javascript" target="_blank" rel="noopener">https://www.codewars.com/kata/foldr/javascript</a></p><p>题目很长，简单概括就是，我们需要实现一个 lazy evaluation 版本的 <code>reduceRight()</code> 函数。再把问题简化就是，如何实现上述所说的 call by need，举例来说，以 <code>indexOf</code> 函数为例：</p><pre><code class="javascript">const indexOf = y =&gt; function (x, z) {  if (x === y) {    return 0  } else {    return z + 1 || -1  }};</code></pre><p><code>indexOf</code> 返回的是一个函数，比如 <code>indexOf(1)</code> 函数有两个参数 x 和 z，在 x 值为 1 的时候是 0，其他值时为 z+1。我们需要做的是对参数 z 实现 lazy evaluation，那么按照上述 functional programming 的概念，则应该是：</p><pre><code class="javascript">const indexOf = y =&gt; function (x, () =&gt; someFunction()) {  if (x === y) {    return 0  } else {    return z() + 1 || -1  }};</code></pre><p>这样，当 x 和 y 值相等时，函数直接返回值，z，也就是 someFunction 不会被调用，z 值实现了 lazy evaluation。很完美，不是吗？但问题是，<code>indexOf</code> 函数仅仅是用来测试的一个例子，对于函数内容是不可控也是未知的，我们无法亲自修改，把 <code>return z + 1 || -1</code>  改成 <code>return z() + 1 || -1</code>。</p><p>所以，问题最终就变成了，如何将一个变量，比如 <code>z</code>，在他需要使用，参与运算，被读取时才会 evaluate 它的值。答案是 <code>Object.prototype.valueOf()</code>。</p><blockquote><p>JavaScript calls the <code>valueOf</code> method to convert an object to a primitive value. You rarely need to invoke the <code>valueOf</code> method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.</p></blockquote><p>使用 <code>valueOf()</code> ，可以</p><pre><code class="javascript">&gt; a = {}{}&gt; a.valueOf = () =&gt; 3[Function]&gt; a { valueOf: [Function] }&gt; a + 14&gt; a.valueOf = () =&gt; true[Function]&gt; !a false&gt; a &amp;&amp; false false&gt; </code></pre><p>定义了 <code>valueOf</code> 方法后，Object a 可以像普通变量，更确切是 primitive value 那样进行运算，而且就如 lazy evaluation 那样，只有它被使用时，<code>valueOf</code> 函数才会被调用。因此，我们只需要在调用 <code>indexOf</code> 函数时这样调用：</p><pre><code class="javascript">indexOf(1)(1, {valueOf: () =&gt; someFunction()})</code></pre><p>即可。依照这样的思路，这道 codewars 问题也就迎刃而解。</p><p>参考链接：</p><ul><li><a href="https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7" target="_blank" rel="noopener">Lazy Evaluation in Javascript</a></li><li><a href="https://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript" target="_blank" rel="noopener">Meaning of Lazy Evaluation in Javascript</a></li><li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener">Object.prototype.valueOf()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 lazy evaluation，首先要明白两个概念：call by name 和 call by value：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Evaluates with call-by-name strategy
1 function callByName (a, b) {
2  if (a === 1) {
3    return 10
4  }
5  return a + b
6 }
// Evaluates with call-by-value strategy
1 function callByValue (a, b) {
2  if (a === 1) {
3    return 10
4  }
5  return a + b
6 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个函数在形式上没有什么区别，只是在运行时采取了不同的策略或态度，前者是 lazy，后者是 eager；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;&amp;gt; callByName (1, 2 + 3)
&amp;gt; a === 1
&amp;gt; return 10

&amp;gt; callByValue(1, 2 + 3)
&amp;gt; callByValue(1, 5)
&amp;gt; a === 1
&amp;gt; return 10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 lazy evaluation，只用当真正需要读取这个变量或 expression 的时候，才会对其进行运算或 evaluate，也就是字面意义上的 call by need。&lt;/p&gt;
&lt;p&gt;实现 lazy evaluation 有很多方法，但其核心概念则是 functional programming。即我们把所有的 variable 写成函数的形式，这样的函数通常被称为 thunk：&lt;/p&gt;
    
    </summary>
    
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript: Semicolon 二三事</title>
    <link href="http://reyshawn.com/2019/06/29/JavaScript-Semicolon%20%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://reyshawn.com/2019/06/29/JavaScript-Semicolon 二三事/</id>
    <published>2019-06-29T15:02:41.000Z</published>
    <updated>2019-06-29T17:02:20.772Z</updated>
    
    <content type="html"><![CDATA[<p>由于 JavaScript 拥有 <em>Automatic Semicolon Insertion</em> 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：</p><pre><code class="javascript">let i = 0(function test () {  console.log(&#39;hello&#39;)})()</code></pre><p>这里会提示报错：</p><pre><code>TypeError: 0 is not a function</code></pre><p>观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。</p><pre><code class="javascript">let i = 0;(function test () {  console.log(&#39;hello&#39;)})()</code></pre><p>关于 JavaScript 的 <em>Automatic Semicolon Insertion</em>，规则是这样的：</p><a id="more"></a><ol><li>当下一行开头的代码和本行末尾的代码连不上；</li><li>当下一行是以 <code>}</code> 开头；</li><li>在整个文件末尾会加分号；</li><li>在 <code>return</code> 所在行末尾会加分号；</li><li>在 <code>break</code> 所在行末尾会加分号；</li><li>在 <code>throw</code> 所在行末尾会加分号；</li><li>在 <code>continue</code> 所在行末尾会加分号；</li></ol><p>上面这个例子，就是如果不在第一行加分号，则下一行以 <code>(</code> 开头，则会被当作函数调用。相似的情况还有：</p><pre><code class="javascript">const hey = &#39;hey&#39;const you = &#39;hey&#39;const heyYou = hey + &#39; &#39; + you[&#39;h&#39;, &#39;e&#39;, &#39;y&#39;].forEach((letter) =&gt; console.log(letter))// Uncaught TypeError: Cannot read property &#39;forEach&#39; of undefined</code></pre><p>以及关于 return </p><pre><code class="javascript">(() =&gt; {  return  {    color: &#39;white&#39;  }})()// Instead, it’s undefined, because JavaScript inserts a semicolon after return.</code></pre><p>以上都是由于不写分号，完全依赖 ASI ( Automatic Semicolon Insertion ) 可能造成的错误。</p><p>Dr. Axel Rauschmayer 在 2011 年就写了一篇 blog 来阐述这个问题，以及他对于分号的态度：</p><blockquote><ul><li>Always add semicolons and avoid the headaches of semicolon insertion, at least for your own code. Yes, you will have to type more. But for me, semicolons <em>increase</em> the readability of code, because I’m so used to them.</li><li>Don’t put postfix <code>++</code> (or postfix <code>--</code>) and its operand in separate lines.</li><li>If the following statements have an argument, don’t put it in a separate line: <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>.</li><li>For consistency (with <code>return</code>), if an opening brace or bracket is part of a statement, don’t put it in a separate line.</li></ul></blockquote><p>参考文章：</p><ul><li><a href="https://flaviocopes.com/javascript-automatic-semicolon-insertion/" target="_blank" rel="noopener">Semicolons in JavaScript</a></li><li><a href="https://2ality.com/2011/05/semicolon-insertion.html" target="_blank" rel="noopener">Automatic semicolon insertion in JavaScript</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 JavaScript 拥有 &lt;em&gt;Automatic Semicolon Insertion&lt;/em&gt; 这样的机制，我已经很长时间在写 js 的时候不加分号了。但今天碰到了这样的一个情况：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let i = 0

(function test () {
  console.log(&amp;#39;hello&amp;#39;)
})()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里会提示报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeError: 0 is not a function&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察了一会儿，才发现，JavaScript 引擎一定是把第一行和第三行看成一行代码，按道理，第一行末尾应该是要自动加一个分号的。这里如果我们手动加上分号，程序就不会报错了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let i = 0;

(function test () {
  console.log(&amp;#39;hello&amp;#39;)
})()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 JavaScript 的 &lt;em&gt;Automatic Semicolon Insertion&lt;/em&gt;，规则是这样的：&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issue #2</title>
    <link href="http://reyshawn.com/2019/06/12/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issue-2/"/>
    <id>http://reyshawn.com/2019/06/12/阅读摘要-issue-2/</id>
    <published>2019-06-12T12:45:12.000Z</published>
    <updated>2019-07-12T09:37:11.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand"><a href="#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand" class="headerlink" title="The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)"></a><a href="https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html" target="_blank" rel="noopener">The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)</a></h2><p>在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 <a href="http://foundationmedicine.com/" target="_blank" rel="noopener">foundationmedicine.com</a> 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：</p><ul><li>Logo</li><li>空白处的填充，space filling；</li><li>字体，GT Sectra，本身就具有六边形结构；</li><li>分割线；</li><li>诸如 qutation marks 这些小的 文字元素</li></ul><p>同样的视觉设计，分析也可用在 <a href="https://theintercept.com/" target="_blank" rel="noopener">The Intercept</a> ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 <a href="https://css-tricks.com" target="_blank" rel="noopener">CSS Tricks</a>，则是把「橙黄渐变」作为一种 motif。</p><h2 id="Level-up-your-sort-game"><a href="#Level-up-your-sort-game" class="headerlink" title="Level up your .sort game"></a><a href="https://css-tricks.com/level-up-your-sort-game/" target="_blank" rel="noopener">Level up your .sort game</a></h2><p>关于 JavaScript 中 <code>.sort()</code> 方法的使用。其中提到的几点关键：</p><ul><li>While many of the ES5 array methods such as <code>.filter</code>, <code>.map</code>, and <code>.reduce</code> will return a new array and leave the original untouched, <code>.sort</code> will sort the array in place.</li><li>要想不让 original variable 发生改变，使用 <code>...</code> ；</li><li>Running functions before comparing values，这里存在一个小的 design pattern；</li><li>如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 <code>reduce</code> 方法。</li><li>如何写一个随机排序；</li></ul><a id="more"></a><h2 id="如何反抗"><a href="#如何反抗" class="headerlink" title="如何反抗"></a><a href="https://blog.yitianshijie.net/2019/06/10/how-to-be-radical/" target="_blank" rel="noopener">如何反抗</a></h2><blockquote><ul><li>终身学习英文。不是以通过什么考试、和外国人深入交流、或是融入所在的英文社会为目标，而是以用英文思考和不觉得中国人以英文思考有任何奇怪为目标；</li><li>关掉一直开着的电视，或，放多一两个屏幕在电视旁边。平板、笔记本电脑都可以。全部一起开着看视频。自动播放要开，让它们都像电视台一样一直播下去。看什么都可以，但每个屏幕要不一样；</li><li>认真听音乐，在不幹别的的情况下。多人一起更佳； </li><li>…</li><li>意识到「所有人都是残疾人」这个事实；</li><li>一定要屌犬儒者的老母。</li></ul></blockquote><h2 id="macOS-10-15-Beta-Release-Notes"><a href="#macOS-10-15-Beta-Release-Notes" class="headerlink" title="macOS 10.15 Beta Release Notes"></a><a href="https://developer.apple.com/documentation/macos_release_notes/macos_10_15_beta_release_notes#3318257" target="_blank" rel="noopener">macOS 10.15 Beta Release Notes</a></h2><p>苹果在随即到来的 Catalina，不再预装 python, ruby, perl 这些脚本语言了。Python 2.7 也不会再支持了。挺好的，一直在用 python 3，python 2 快快淘汰。</p><h2 id="六月里发生了一些事"><a href="#六月里发生了一些事" class="headerlink" title="六月里发生了一些事"></a>六月里发生了一些事</h2><blockquote><p>走向怎样的未来，很大程度上取决于如何面对自己的过去，人和国家都一样。 — <a href="https://twitter.com/hengdm/status/1135737325323866113" target="_blank" rel="noopener">DM.</a> </p><p>那是，毕竟吃药的第一步是承认自己有病。 — <a href="https://twitter.com/ichimaru0223/status/1135737755487498240" target="_blank" rel="noopener">妖術</a></p></blockquote><h2 id="INTJ-amp-INTP"><a href="#INTJ-amp-INTP" class="headerlink" title="INTJ &amp; INTP"></a><a href="https://en.wikipedia.org/wiki/INTJ" target="_blank" rel="noopener">INTJ</a> &amp; <a href="https://en.wikipedia.org/wiki/INTP" target="_blank" rel="noopener">INTP</a></h2><ul><li>INTJ: Introversion, Intuition, Thinking, Judgment, Hallmarks of the INTJ include independence of thought and a desire for efficiency.</li><li>INTP: Introversion, Intuition, Thinking, Perceiving</li></ul><p><a href="https://personalityhacker.com/intp-vs-intj/" target="_blank" rel="noopener">这篇文章</a>举了一个例子来阐释二者的差别。Tesla（INTJ）和 Einstein（INTP），Tesla 研究新的技术，并思考这些技术能否得到应用，是否会有新发明？Einstein 更加注重背后的数学原理。在<a href="https://www.douban.com/group/INT/?ref=sidebar" target="_blank" rel="noopener">某豆瓣小组</a>的介绍里，对 INTJ 和 INTP 的解释更加清晰。简单来说，二者都拥有「内向，思考」的性格特征，INTJ 更加灵活，富有创造力，追求效率。INTP 极乐于追求事物因何如此，并试图探寻隐藏一切事物之后的运行逻辑。</p><p>看了上面的解释，认为自己可能属于 INTP 多一些。</p><h2 id="Discoveries"><a href="#Discoveries" class="headerlink" title="Discoveries"></a>Discoveries</h2><p><a href="https://cssgrid-generator.netlify.com" target="_blank" rel="noopener">CSS Grid Generator</a></p><p><em>自从生成 css grid 代码。</em></p><p><a href="https://www.animatedknots.com/complete-knot-list" target="_blank" rel="noopener">Animated Knots</a></p><p><em>一个教你如何打结的网站，每种方法都配有动画。</em></p><p><a href="https://www.npmtrends.com" target="_blank" rel="noopener">Compare package download counts over time</a></p><p><em>用于对比 npm package 的下载量。</em></p><p><a href="https://www.theverge.com/tldr/2018/3/4/17036804/pod-hunters-podcasts-roundup" target="_blank" rel="noopener">Pod Hunters: all of the cool podcasts that we recommend</a></p><p><em>the verge 专栏 pod hunters，推荐好听的播客节目。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand&quot;&gt;&lt;a href=&quot;#The-1-Way-to-Spice-Up-Your-Designs-And-Create-a-More-Cohesive-Brand&quot; class=&quot;headerlink&quot; title=&quot;The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://learnui.design/blog/spice-up-designs-create-cohesive-brand.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The #1 Way to Spice Up Your Designs (And Create a More Cohesive Brand)&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 UI 设计中如何更好的使用 motifs （小的视觉元素），既不喧宾夺主，又能体现 UI 设计的 consistency 一致性。在 &lt;a href=&quot;http://foundationmedicine.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;foundationmedicine.com&lt;/a&gt; 网站看到它们将 hexagon 作为它们 UI 设计的 motif，这分别体现在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logo&lt;/li&gt;
&lt;li&gt;空白处的填充，space filling；&lt;/li&gt;
&lt;li&gt;字体，GT Sectra，本身就具有六边形结构；&lt;/li&gt;
&lt;li&gt;分割线；&lt;/li&gt;
&lt;li&gt;诸如 qutation marks 这些小的 文字元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样的视觉设计，分析也可用在 &lt;a href=&quot;https://theintercept.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Intercept&lt;/a&gt; ，它们选取 command line 的下划线光标作为它们的 motif，在 Logo，字体，分割线等都有体现。同样在 &lt;a href=&quot;https://css-tricks.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS Tricks&lt;/a&gt;，则是把「橙黄渐变」作为一种 motif。&lt;/p&gt;
&lt;h2 id=&quot;Level-up-your-sort-game&quot;&gt;&lt;a href=&quot;#Level-up-your-sort-game&quot; class=&quot;headerlink&quot; title=&quot;Level up your .sort game&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://css-tricks.com/level-up-your-sort-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Level up your .sort game&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;关于 JavaScript 中 &lt;code&gt;.sort()&lt;/code&gt; 方法的使用。其中提到的几点关键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;While many of the ES5 array methods such as &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.map&lt;/code&gt;, and &lt;code&gt;.reduce&lt;/code&gt; will return a new array and leave the original untouched, &lt;code&gt;.sort&lt;/code&gt; will sort the array in place.&lt;/li&gt;
&lt;li&gt;要想不让 original variable 发生改变，使用 &lt;code&gt;...&lt;/code&gt; ；&lt;/li&gt;
&lt;li&gt;Running functions before comparing values，这里存在一个小的 design pattern；&lt;/li&gt;
&lt;li&gt;如何添加 tierbeaker，也就是当出现同样值是有没有第二比较规则，这里用到的 &lt;code&gt;reduce&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;如何写一个随机排序；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSON Web Token 的产生和认证</title>
    <link href="http://reyshawn.com/2019/06/12/JSON-Web-Token-%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%AE%A4%E8%AF%81/"/>
    <id>http://reyshawn.com/2019/06/12/JSON-Web-Token-的产生和认证/</id>
    <published>2019-06-12T05:49:07.000Z</published>
    <updated>2019-06-12T08:28:54.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie-based-vs-Token-based"><a href="#Cookie-based-vs-Token-based" class="headerlink" title="Cookie-based vs Token-based"></a>Cookie-based vs Token-based</h2><p>有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：</p><p>cookie-based authentication 的认证流程是:</p><ol><li>用户填写 credentials，包括用户名，邮箱，密码这些内容；</li><li>Server 服务器验证这些 credentials 是否正确，如果正确，则<strong>认证成功</strong>，创建一个 session 存储在数据库中；</li><li>将这个 session 的 session id 存储在浏览器端的 cookie 里；</li><li>接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；</li><li>一旦用户登出，client 端和 server 端的 session 均被摧毁；</li></ol><p>token-based authentication:</p><ol><li>用户填写 credentials，包括用户名，邮箱，密码；</li><li>Server 服务器验证这些 credentials 是否正确，如果<strong>认证成功</strong>，则返回一个 signed token；</li><li>这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；</li><li>接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。</li><li>Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；</li></ol><p><img src="/images/auto01.png" alt="auto01"></p><p>为什么会说 token-based 更好：</p><ol><li>stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；</li><li>cookie 对跨域 CORS 操作不友好，token 则没有这个问题；</li></ol><a id="more"></a><h2 id="JWT-如何产生的"><a href="#JWT-如何产生的" class="headerlink" title="JWT 如何产生的"></a>JWT 如何产生的</h2><p>一条完整的 JWT 格式是这样的：<code>header.payload.signature</code>。</p><p>第一步，创建一个 JSON 格式的 header。header 里包含的信息需要有这个 JSON 使用的 hash 算法，例如：</p><pre><code class="javascript">const header = {    typ: &quot;JWT&quot;,    alg: &quot;HS256&quot;}</code></pre><p><code>&quot;typ&quot;</code> 声明这是一个 JWT，<code>&quot;alg&quot;</code> 声明所有是用的 hash 算法；</p><p>第二步，创建 payload。这里的 payload 就是你想在 JWT 里存储的任何数据信息，但最好不要把敏感信息，比如密码放在里面，</p><pre><code class="javascript">const payload = {    userId: &quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;}</code></pre><p>对于 JWT 的 payload，会有一些标准，比如 <code>iss</code> 代表 issuer，<code>sub</code> 代表 subject，<code>exp</code> 代表 expiration time。</p><p>第三步，创建 signature 签名。</p><pre><code class="javascript">const encodedHeader = Buffer.from(JSON.stringify(header)).toString(&#39;base64&#39;)const encodedPayload = Buffer.from(JSON.stringify(payload)).toString(&#39;base64&#39;)</code></pre><p>将 header 和 payload 都使用 base64 编码。</p><pre><code class="javascript">const crypto = require(&#39;crypto&#39;)const jwtSecret = &#39;secretKey&#39;const signature = crypto.createHmac(&#39;sha256&#39;, jwtSecret).update(encodedHeader + &#39;.&#39; + encodedPayload).digest(&#39;base64&#39;)</code></pre><p>base64 编码后的文本使用 <code>.</code> 连接，再进行 hash，hash 后的文本再进行 base64 编码。</p><p>最终 JWT 为：</p><pre><code class="javascript">const jwt = `${encodedHeader}.${encodedPayload}.${signature}`</code></pre><h2 id="JWT-的认证"><a href="#JWT-的认证" class="headerlink" title="JWT 的认证"></a>JWT 的认证</h2><blockquote><p>The <strong>very</strong> important thing to note here is that this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is <strong>not</strong> encrypted. If I go to <a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a>, paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.</p><p>— <a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide" target="_blank" rel="noopener">Cookies vs. Tokens: The Definitive Guide</a></p></blockquote><p>一定要区分认证和加密，JWT 不会加密混淆数据。当用户成功登录，服务器端按照上述过程生成一条 JWT 返回给了客户端。因为 JWT 涉及到了身份认证，还是很敏感的，客户端把这个 JWT 存储在 <code>HttpOnly Cookie</code>，不同于传统 cookie，标有 <code>HttpOnly</code> 的 cookie 只能由 Server 端获取。</p><p>登录成功后，当需要请求某个需要权限的 api 或是进入某个 route 时，client 端在发送 request 请求就会把这个 JWT 稍带着，通常是在 <code>Authorization</code> 里，以 Bearer 作为开头：</p><pre><code class="yaml">Authorization: Bearer &lt;token&gt;</code></pre><p>服务器收到请求后，首先需要验证这个 token。验证 JWT 包含以下几个步骤：</p><ol><li>验证 JWT 的格式是否正确；</li><li>验证 signature 签名；</li><li>验证在 payload 里的 standard claims；</li><li>验证许可权限范围；</li></ol><p>在验证 signature 时，具体是先使用 base64 decode 整个 JWT，获得 header 和 payload  的内容。在 header 里能找到 JWT 使用的 hash 算法。使用该 hash 算法和本来就在服务器端存储的 secret key ，重复一遍上面的流程，比较结果和 JWT 中的 signature 是否匹配。</p><blockquote><p>The API needs to check if the algorithm, as specified by the JWT header (property <code>alg</code>), matches the one expected by the API. If not, the token is considered invalid and the request must be rejected.</p><p>To check if the signature matches the API’s expectations, you have to decode the JWT and retrieve the <code>alg</code> property of the JWT header.</p><p>Remember that the signature is created using the header and the payload of the JWT, a secret and the hashing algorithm being used (as specified in the header: HMAC, SHA256 or RSA). The way to verify it, depends on the hashing algorithm:</p><p>— <a href="https://auth0.com/docs/api-auth/tutorials/verify-access-token" target="_blank" rel="noopener">Verify Access Tokens for Custom APIs</a></p></blockquote><h2 id="在-express-里实际应用"><a href="#在-express-里实际应用" class="headerlink" title="在 express 里实际应用"></a>在 express 里实际应用</h2><p><a href="https://www.youtube.com/watch?v=7nafaH9SddU" target="_blank" rel="noopener">Node.js API Authentication With JWT</a></p><p>这个视频 step-by-step 讲解了如何在 express 里使用 jsonwebtoken 这个 package，以下是最终完整代码：</p><pre><code class="javascript">const express = require(&#39;express&#39;);const jwt = require(&#39;jsonwebtoken&#39;);const app = express();app.get(&#39;/api&#39;, (req, res) =&gt; {  res.json({    messgae: &#39;welcome to the api&#39;  })});app.post(&#39;/api/posts&#39;, verifyToken, (req, res) =&gt; {  jwt.verify(req.token, &#39;secretkey&#39;, (err, authData) =&gt; {    if (err) {      res.sendStatus(403);    } else {      res.json({        message: &#39;post created ...&#39;,        authData      })    }  })})app.post(&#39;/api/login&#39;, (req, res) =&gt; {  // Mock user  const user = {    id: 1,    usernmae: &#39;brad&#39;,    email: &#39;brad@gamil.com&#39;  }  jwt.sign({user}, &#39;secretkey&#39;, (err, token) =&gt; {    res.json({      token    })  });});// Format of Token// Authorization: Bearer &lt;access_token&gt;// Verify Tokenfunction verifyToken(req, res, next) {  // Get auth header value;  const bearerHeader = req.headers[&#39;authorization&#39;];  // Check if bearer is undefined  if (typeof bearerHeader !== &#39;undefined&#39;) {    // Split at the space    const bearer = bearerHeader.split(&#39; &#39;);    // Get token from array    const bearerToken = bearer[1];    // Set the token    req.token = bearerToken;    // Next middleware    next();  } else {    // Forbidden    res.sendStatus(403);  }}app.listen(5000, () =&gt; console.log(&#39;server started on 5000&#39;))</code></pre><p>通过 <code>jwt.sign()</code> 进行签名。</p><p>函数 <code>verifyToken</code>  仅仅是作为一个 middleware 去 retrieve header 里的 token，并把它保存在 <code>req.token</code>  里，具体的认证是通过 <code>jwt.verify()</code> 实现的。</p><h2 id="HS256-vs-RS256"><a href="#HS256-vs-RS256" class="headerlink" title="HS256 vs RS256"></a>HS256 vs RS256</h2><p>前者是对称加密，只有一个 key 值。后者 RS256 是非对称加密，有一个 private key 和一个 public key。上文仅仅提到了 HS256 的认证过程，但如果使用非对称加密（也更推荐这种方式）来生成 JWT，认证时需要用到 JSON Web Key Set。</p><blockquote><p>For <code>RS256</code>, the tenant’s <a href="https://auth0.com/docs/jwks" target="_blank" rel="noopener">JSON Web Key Set (JWKS)</a> is used. Your tenant’s JWKS is <code>https://YOUR_DOMAIN/.well-known/jwks.json</code>.</p></blockquote><p>通过 private key 来生成 JWT，再通过 public key 对 JWT 进行验证。在使用 RS256 非对称加密时，我们可以想象有两个 Server 端，一个是 Authentication Server，进行认证，并使用 private key 产生 JWT。另一个是 Application Server，获得来自  Authentication Server 的 public key，可以对经过Authentication Server 产生的 JWT 进行验证。</p><p><img src="/images/auth02.png" alt="auth02"> </p><p>参考：</p><ul><li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a></li><li><a href="https://dzone.com/articles/cookies-vs-tokens-the-definitive-guide" target="_blank" rel="noopener">Cookies vs. Tokens: The Definitive Guide</a></li><li><a href="https://flaviocopes.com/jwt/" target="_blank" rel="noopener">JSON Web Token (JWT) explained</a></li><li><a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec" target="_blank" rel="noopener">5 Easy Steps to Understanding JSON Web Tokens (JWT)</a></li><li><a href="https://auth0.com/docs/api-auth/tutorials/verify-access-token" target="_blank" rel="noopener">Verify Access Tokens for Custom APIs</a></li><li><a href="https://auth0.com/docs/jwks" target="_blank" rel="noopener">JSON Web Key Set</a></li><li><a href="https://tools.ietf.org/html/rfc7519#section-7.2" target="_blank" rel="noopener">JSON Web Token (JWT)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cookie-based-vs-Token-based&quot;&gt;&lt;a href=&quot;#Cookie-based-vs-Token-based&quot; class=&quot;headerlink&quot; title=&quot;Cookie-based vs Token-based&quot;&gt;&lt;/a&gt;Cookie-based vs Token-based&lt;/h2&gt;&lt;p&gt;有两种认证方式，一种是基于 cookie 的认证，另一种是基于 token 的认证。后者实现往往是通过 JSON Web Token （以下简称 JWT）实现的。首先要说明一下两种认证方式的区别：&lt;/p&gt;
&lt;p&gt;cookie-based authentication 的认证流程是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户填写 credentials，包括用户名，邮箱，密码这些内容；&lt;/li&gt;
&lt;li&gt;Server 服务器验证这些 credentials 是否正确，如果正确，则&lt;strong&gt;认证成功&lt;/strong&gt;，创建一个 session 存储在数据库中；&lt;/li&gt;
&lt;li&gt;将这个 session 的 session id 存储在浏览器端的 cookie 里；&lt;/li&gt;
&lt;li&gt;接下来的每一个请求，都会带着这个 session id，Server 在接收请求后也会验证 session id 与 session 是否匹配；&lt;/li&gt;
&lt;li&gt;一旦用户登出，client 端和 server 端的 session 均被摧毁；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;token-based authentication:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户填写 credentials，包括用户名，邮箱，密码；&lt;/li&gt;
&lt;li&gt;Server 服务器验证这些 credentials 是否正确，如果&lt;strong&gt;认证成功&lt;/strong&gt;，则返回一个 signed token；&lt;/li&gt;
&lt;li&gt;这个 token 会被存储在 client 端，大部分是在 localStorage，但也会存储在 session storage 或是 cookie 里；&lt;/li&gt;
&lt;li&gt;接下来的每一个请求，都会带着 token 作为额外的 authentication 信息。&lt;/li&gt;
&lt;li&gt;Server 收到请求后，首先 decode 这个 token 并对 token 里的 signature 进行验证；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/images/auto01.png&quot; alt=&quot;auto01&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么会说 token-based 更好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stateless，也就是不需要再在 server 端保存一份纪录，但 server 端要保存用于签名时用的「secret key」；&lt;/li&gt;
&lt;li&gt;cookie 对跨域 CORS 操作不友好，token 则没有这个问题；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>iPadOS 使用体验</title>
    <link href="http://reyshawn.com/2019/06/05/iPadOS-%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/"/>
    <id>http://reyshawn.com/2019/06/05/iPadOS-使用体验/</id>
    <published>2019-06-05T03:25:19.000Z</published>
    <updated>2019-06-05T04:09:05.847Z</updated>
    
    <content type="html"><![CDATA[<p>今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 <a href="https://developer.apple.com/support/beta-software/install-beta/" target="_blank" rel="noopener">Installing Apple Beta Software</a> 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在<a href="https://www.udid.in/install-beta" target="_blank" rel="noopener">这里</a>下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。</p><p>具体的安装教程也可以参考这个 <a href="https://www.youtube.com/watch?v=iPZ6eNc8BvU&frags=pl%2Cwn" target="_blank" rel="noopener">YouTube 视频</a>。</p><p>下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。</p><a id="more"></a><h2 id="Safari"><a href="#Safari" class="headerlink" title="Safari"></a>Safari</h2><h3 id="Always-Request-Desktop-Page"><a href="#Always-Request-Desktop-Page" class="headerlink" title="Always Request Desktop Page"></a>Always Request Desktop Page</h3><p>永远访问桌面网页，这对于使用 iPad 而言是巨大的进步。在电脑端，无论是 Safari 或是 Chrome，都已经成为了无比强大的通用客户端，general client，在浏览器里几乎可以做任何事情。而在 iPhone 上，苹果对于第三方浏览器有很多限制，因此，原生 Safari 的增强就显得无比重要。这让 iPad 变得更像是 laptop 了。不仅如此：</p><ul><li>在 bilibili.com 可以调整更高清的分辨率；</li><li>可以在 repl.it 上在线 coding 了；</li></ul><p><img src="/images/repl.png" alt="repl"></p><p>bilibili 的 iPad app 极为难用。而在以前在 iPad 上使用 Safari 浏览 bilibili，总会自动跳到移动端页面，而且可恶的是移动端仅支持 240P 的分辨率。哪怕你在 share sheet 里去 request desktop page 也不行。而在新的 iOS13 里，使用 Safari 进行浏览就和电脑端一模一样，体验非常友好。</p><p>理论上，现在的 iPadOS 可以开无数个 Safari 窗口，但由于内存限制，只能同时运行 2-3 个 Safari，多余的就会被后台 kill 掉。目前，只有 1T 容量的 iPad Pro 搭配有 6G RAM 内存，其余 iPad Pro 是只有 4G RAM。</p><p>可以预见的是，未来 iPad 产品也将逐渐加入更大的内存，以此实现后台的多任务运行。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Safari 终于有了原生的下载功能。可以在 Settings 设置里选择下载保存的文件夹，可以保存在本地 On My iPad，或者是 iCloud 里。这对于日常使用，通过 http 或 ftp 下载一些文件资源已经足够了。但如果想要使用「磁力链」或 bitTorrent，在目前或可以想象的未来的 iOS 系统中，都不太可能。</p><h2 id="手势交互"><a href="#手势交互" class="headerlink" title="手势交互"></a>手势交互</h2><p>手势交互一直是 iPad 有别于 Mac 和 iPhone 的一个最重要特征。</p><h3 id="截图-长截图"><a href="#截图-长截图" class="headerlink" title="截图 / 长截图"></a>截图 / 长截图</h3><p>两种截图方式：</p><ol><li>power button + volume button；</li><li>使用 Apple Pencil 在屏幕左下角或右下角向上拉；</li></ol><p>第一种是一直以来很传统的截图方式。第二种很有趣，很自然，截图之后直接进入编辑页面。</p><h3 id="文字选取高亮-光标移动"><a href="#文字选取高亮-光标移动" class="headerlink" title="文字选取高亮 / 光标移动"></a>文字选取高亮 / 光标移动</h3><p>在以前，要想选中某段文字，需要在想要选中的位置上 touch 两下才会出现光标。在新的 iOS 13 中，苹果把这个操作进一步简化，更加接近在桌面端的交互逻辑。而以前的双击，是选中一个词，三击是选中整个句子。</p><h3 id="copy-paste"><a href="#copy-paste" class="headerlink" title="copy / paste"></a>copy / paste</h3><p>我们在电脑端编辑文字，使用的很多的快捷键便是 cmd+c/cmd+v。现在在 iPad，复制是三指 pinch （捏合），粘贴是三指 spread。类似的手势在 mac 上很常用。需要指出的是，这里手势操作的复制粘贴并不仅仅限于文字，它可以用于所有可以进行复制粘贴的地方，比如文件。</p><p>通常如果使用键盘，cmd+c/cmd+v 是更好的方式。但如果在 files 里整理文件，首先多选，再利用手势进行操作，就非常方便了。</p><h2 id="外接存储"><a href="#外接存储" class="headerlink" title="外接存储"></a>外接存储</h2><p>是的，等了很多年了，iPad 终于可以外接闪存了。这里为什么强调是闪存，因为我在发布会上只听到了说 flash drive。而在我自己的实验里，exFAT 格式的 flash drive 可以准确读取，嗯，这点和 mac 是一致的。因为一定会有文件格式的壁垒在。但我使用我的 APFS 格式的外接机械硬盘，读取失败，甚至出现了一个 bug。这里要说明一下，我的这个机械硬盘被分成了两个区，一个用作 time machine，另一个是正常存储。但连接 iPad 后，似乎识别成了 image 什么的，而且出现的外接存储图标再也消除不掉了。</p><p>不清楚各位有没有连接 APFS 格式机械硬盘成功的。</p><p>![ipad files bug](/images/ipad files bug.png)</p><h2 id="UI-变化"><a href="#UI-变化" class="headerlink" title="UI 变化"></a>UI 变化</h2><p>苹果在每一代系统里，对 UI 设计都有一些细微的变化。最明显的是顶部选项卡</p><p>![iOS13 tab 1](/images/iOS13 tab 1.png)</p><p>![iOS13 tab 2](/images/iOS13 tab 2.png)</p><p>![iOS13 tab 3](/images/iOS13 tab 3.png)</p><h2 id="关于-iPad-的未来"><a href="#关于-iPad-的未来" class="headerlink" title="关于 iPad 的未来"></a>关于 iPad 的未来</h2><ol><li>Files 和 Safari 都会持续进化。Files 会加入更丰富的文件编辑功能，能够原生支持更多格式的文件直接在 Files 读取。</li><li>会有 iPad Terminal，并且会有一整套的 iPad 上的有关编程的 API 及 editor。</li><li>内存会更多，将来可以后台多任务运行的数量会增多。</li></ol><p>最后，从 WWDC19 结束后，就很多人在讨论 iPad 上的鼠标。我也看了别人在 iPad 上使用鼠标的演示视频。我能想到比较好的使用方式是进行 FPS 枪战游戏。但目前来看，iPad 上的鼠标还仅仅是模拟手指操作，而不是类似 Apple Pencil 那种更精细的指针，而且不支持滚轮滚动，所以整个下来体验并不好。我个人是很多年都不在用鼠标了，电脑上一直用触控板，体验很好。我也一直认为，iPad 上最好的精确输入方式是 Apple Pencil。而鼠标的作用，想一想，定位可能是和现在已经支持的 playstation controller 或 Xbox controller 那样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今早安装了 iPadOS Development Beta 版本，体验了一会儿。因为不太敢拿 mac 升级 Catalina，据说文件系统改掉了。目前 mac 不太敢升，所以 Sidecar 功能暂时还没办法体验。iPhone 变化其实没那么大，也就只有 iPad 可以尝试了。提前做好备份，在苹果的开发者官网 &lt;a href=&quot;https://developer.apple.com/support/beta-software/install-beta/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Installing Apple Beta Software&lt;/a&gt; 下载安装 Xcode beta，安装完毕要打开运行，这样做的目的是帮助 iTunes 能够识别 iOS13。下载你所使用设备的 ipsw 文件。我是在&lt;a href=&quot;https://www.udid.in/install-beta&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;下载的。然后在 iTunes 里更新就行了，注意要提前做好备份。&lt;/p&gt;
&lt;p&gt;具体的安装教程也可以参考这个 &lt;a href=&quot;https://www.youtube.com/watch?v=iPZ6eNc8BvU&amp;frags=pl%2Cwn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YouTube 视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面按照给我带来惊喜的顺序，来简单谈一下这次的 iPadOS / iOS13。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>阅读摘要 | issues #1</title>
    <link href="http://reyshawn.com/2019/05/31/%E9%98%85%E8%AF%BB%E6%91%98%E8%A6%81-issues-1/"/>
    <id>http://reyshawn.com/2019/05/31/阅读摘要-issues-1/</id>
    <published>2019-05-31T11:44:37.000Z</published>
    <updated>2019-06-12T12:57:23.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi"><a href="#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi" class="headerlink" title="Complex life may only exist because of millions of years of groundwork by ancient fungi"></a><a href="https://news.ycombinator.com/item?id=20039980" target="_blank" rel="noopener">Complex life may only exist because of millions of years of groundwork by ancient fungi</a></h2><p>在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。</p><h2 id="Why-specialization-can-be-a-downside-in-our-ever-changing-world"><a href="#Why-specialization-can-be-a-downside-in-our-ever-changing-world" class="headerlink" title="Why specialization can be a downside in our ever-changing world"></a><a href="https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview" target="_blank" rel="noopener">Why specialization can be a downside in our ever-changing world</a></h2><p>作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。</p><a id="more"></a><h2 id="https-t-me-yifenshijie-2973"><a href="#https-t-me-yifenshijie-2973" class="headerlink" title="https://t.me/yifenshijie/2973"></a><a href="https://t.me/yifenshijie/2973" target="_blank" rel="noopener">https://t.me/yifenshijie/2973</a></h2><p><a href="https://twitter.com/Scholars_Stage/status/1099238789363294208" target="_blank" rel="noopener">T. Greer</a> 用一整条 thread 来阐述，为什么旧的 blog 时代是会比现在的 twitter，reddit，tumbler 更好：</p><ul><li>blog 更专注内容，后者只期望于把用户留在自己的平台里；</li><li>blog 会形成更小到 community，后者，更大的平台，同质化的声音，观点；</li><li>blog 是属于个人的，后者属于平台，遵从商业公司利益，社会主流价值观；</li></ul><p>李如一看到这条 thread 后，<a href="https://t.me/s/yifenshijie/2973" target="_blank" rel="noopener">停止更新了他在 telegram 平台的「一分世界」</a>，认为要知行合一。</p><h2 id="霍洛维兹的欺骗"><a href="#霍洛维兹的欺骗" class="headerlink" title="霍洛维兹的欺骗"></a><a href="https://blog.yitianshijie.net/2019/05/05/horowitz-the-deceiver/" target="_blank" rel="noopener">霍洛维兹的欺骗</a></h2><p>Horowitz  1965 年在纽约卡内基音乐厅舞台演出时，在第二乐章结尾处出了些小瑕疵，后来提供给唱片公司的是编辑过的版本，把瑕疵剪掉了。直到 30 年后，才把 unedited 版本放了出来。</p><blockquote><p>Apple Music 上，<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/205999185?i=206001029" target="_blank" rel="noopener">在这里</a>可以听到音乐会后出版的唱片里的版本（修过的，从七分二秒开始），<a href="https://music.apple.com/us/album/fantasie-in-c-major-op-17-ii-m-c3-a4ssig-durchaus-energisch/328340329?i=328340362" target="_blank" rel="noopener">这里</a>可以听到日后出版的未修版本（即演出现场版本，勋伯格说的严重错误在七分十一秒）。</p></blockquote><p>以及这里给出网易云音乐的链接，方便收听。<a href="https://music.163.com/#/song?id=405318766" target="_blank" rel="noopener">edited</a> &amp; <a href="https://music.163.com/#/song?id=1298480910" target="_blank" rel="noopener">unedited</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot;&gt;&lt;a href=&quot;#Complex-life-may-only-exist-because-of-millions-of-years-of-groundwork-by-ancient-fungi&quot; class=&quot;headerlink&quot; title=&quot;Complex life may only exist because of millions of years of groundwork by ancient fungi&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=20039980&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Complex life may only exist because of millions of years of groundwork by ancient fungi&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 hacker news 看到这样一则评论：对于 Fermi paradox 费米悖论的一个解释，死去的有机物通过数百万年，在这个星球上形成了丰富的化石燃料。因为这些石油化石资源的丰富，我们才能进入工业时代，才能进入电气时代。但有人反驳，即使没有这些化石，但只要存在了生命，就会有能量源，不管那是什么，就能帮助机器运转。&lt;/p&gt;
&lt;h2 id=&quot;Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot;&gt;&lt;a href=&quot;#Why-specialization-can-be-a-downside-in-our-ever-changing-world&quot; class=&quot;headerlink&quot; title=&quot;Why specialization can be a downside in our ever-changing world&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.theverge.com/2019/5/30/18563322/david-epstein-range-psychology-performance-skills-sports-career-advice-book-interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why specialization can be a downside in our ever-changing world&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;作者认为专业化， 10000 小时理论，更倾向于在一个 kind or simple 的环境里发生。而事实大多数人所面临的环境都是极其复杂的， wicked 。重申了行动要优先于思考，并引用了 Herminia Ibarra 的话「We learn who we are in practice, not in theory」。最后，他认为让我们避免陷入自我的 cognitive biases 认知偏见的，是「science curiosity」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="音乐" scheme="http://reyshawn.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript async and Promise</title>
    <link href="http://reyshawn.com/2019/05/18/JavaScript-async-and-Promise/"/>
    <id>http://reyshawn.com/2019/05/18/JavaScript-async-and-Promise/</id>
    <published>2019-05-18T11:42:34.993Z</published>
    <updated>2019-05-18T13:47:39.158Z</updated>
    
    <content type="html"><![CDATA[<p>非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是</p><pre><code class="javascript">$.get(&#39;http://twitter.com&#39;)$.get(&#39;http://youtube.com&#39;)$.get(&#39;http://google.com&#39;)</code></pre><p>在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 <code>setTimeout()</code> 函数时，程序似乎不会出现 blocking。</p><pre><code class="Javascript">console.log(&#39;hi&#39;)setTimeout(() =&gt; console.log(&#39;there&#39;), 0)console.log(&#39;Welcome!&#39;)// output:// hi// Welcome// there</code></pre><p>这里哪怕是设置 delay 为 0s， <code>setTimeout()</code> 里的函数也是在最后才执行，是怎么回事呢？</p><p>在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 <code>setTimeout()</code> 函数就来自这些提供的 API 中。当我们 declare and call  一个  <code>setTimeout()</code> 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  <code>setTimeout()</code>  里定义的 callback 函数会进入到一个叫 <code>task queue</code> 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  <code>setTimeout()</code> 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。</p><a id="more"></a><p><img src="/images/eventLoop.png" alt="Event Loop"></p><h2 id="Promise-的实现"><a href="#Promise-的实现" class="headerlink" title="Promise 的实现"></a>Promise 的实现</h2><p>Promise 和   <code>setTimeout()</code> 的区别是，<code>setTimeout()</code> 是 delay 一个确定的时间，比如 3000ms，5000ms，然后执行 callback 函数。Promise 本身执行 callback 的时间是不确定的，只有 resolve 之后才算执行完毕，因为 resolve 后会改变 state，比如从 pending 改变成 fulfilled，通过 <code>.then()</code> 的方法执行下一个任务。</p><blockquote><p>Timeouts and Promises serve different purposes.</p><p>setTimeout delays the execution of the code block by a specific time duration. Promises are an interface to allow async execution of code.</p><p>A promise allows code to continue executing while you wait for another action to complete. Usually this is a network call. So anything in your <code>then()</code> call will be executed once the network call (or whatever the promise is waiting for) is completed. The time difference between the start of the promise and the resolution of the promise entirely depends on what the promise is executing, and can change with every execution.</p><p>The reason the promise is executing before your timeout is that the promise isn’t actually waiting for anything so it resolved right away.</p></blockquote><p>以下是来自 <a href="https://www.promisejs.org/implementing/" target="_blank" rel="noopener">Implementing</a>，对于 Promise object 的实现：</p><p>最好的方式是将下面的代码粘贴进 editor 里，调试几遍。不太明白的地方打上断点，或是 <code>console.log()</code>。</p><pre><code class="javascript">let PENDING = 0;let FULFILLED = 1;let REJECTED = 2;function Promise(fn) {  // store state which can be PENDING, FULFILLED or REJECTED  let state = PENDING;  // store value or error once FULFILLED or REJECTED  let value = null;  // store sucess &amp; failure handlers attached by calling .then or .done  let handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;    handlers.forEach(handle);    handlers = null;  }  function reject(error) {    state = REJECTED;    value = error;    handlers.forEach(handle);    handlers = null;  }  function resolve(result) {    try {      let then = getThen(result);      if (then) {        doResolve(then.bind(result), resolve, reject);        return ;      }      fulfill(result)    } catch (e) {      reject(e);    }  }  function handle(handler) {    if (state === PENDING) {      handlers.push(handler);    } else {      if (state === FULFILLED &amp;&amp;        typeof handler.onFulfilled === &#39;function&#39;) {        handler.onFulfilled(value);      }      if (state === REJECTED &amp;&amp;        typeof handler.onRejected === &#39;function&#39;) {        handler.onRejected(value);      }    }  }  this.done = function (onFulfilled, onRejected) {    // ensure we are always asynchronous    setTimeout(function () {      console.log(&#39;instantly implemented ⚠️&#39;)      handle({        onFulfilled: onFulfilled,        onRejected: onRejected      });    }, 0);  }  doResolve(fn, resolve, reject)  this.then = function (onFulfilled, onRejected) {    var self = this;    return new Promise(function (resolve, reject) {      return self.done(function (result) {        if (typeof onFulfilled === &#39;function&#39;) {          try {            return resolve(onFulfilled(result));          } catch (ex) {            return reject(ex);          }        } else {          return resolve(result);        }      }, function (error) {        if (typeof onRejected === &#39;function&#39;) {          try {            return resolve(onRejected(error));          } catch (ex) {            return reject(ex);          }        } else {          return reject(error);        }      });    });  }}function getThen(value) {  var t = typeof value;  if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) {    var then = value.then;    if (typeof then === &#39;function&#39;) {      return then;    }  }  return null;}function doResolve(fn, onFulfilled, onRejected) {  var done = false;  try {    fn(function (value) {      if (done) return      done = true      onFulfilled(value)    }, function (reason) {      if (done) return      done = true      onRejected(reason)    })  } catch (ex) {    if (done) return    done = true    onRejected(ex)  }}var promise1 = new Promise(function(resolve, reject) {  setTimeout(function() {    resolve(&#39;foo&#39;);  }, 3000);});promise1.then(function(value) {  console.log(value)  // expected output: &quot;foo&quot;});console.log(promise1);</code></pre><p><img src="/images/Promise.png" alt="Promise"></p><p>一些帮助理解这段代码的小 tips：</p><ol><li><code>doResolve()</code> ，第一，会直接执行 <code>fn</code> 函数，也就是声明 Promise 时传递的 callback 函数。第二， 保证 <code>resolve</code> 或是 <code>reject</code> function 仅执行一次。</li><li>每次声明 Promise object，都会先执行一次 <code>doResolve()</code> 函数；</li><li><code>.then()</code> 返回一个新的 Promise object，这个 Promise 会执行 <code>doResolve()</code>  函数，从而会直接执行这个新 Promise 的 callback 函数；line 73 - line 93，执行 callback 函数返回的是 <code>self.done()</code> 函数的执行结果；</li><li><code>.done()</code> 方法会 check state 的值，确定是否将 <code>resolve</code> 添加进 <code>handlers</code> 中；</li><li><code>resolve</code> 函数执行完毕后，将 <code>state</code> 从 <code>PENDING</code> 改为了 <code>FULFILLED</code>，同时 <code>handlers.forEach(handle)</code> 依次执行 <code>.then</code> 方法中添加进去的函数。</li><li><code>resolve</code> 和 <code>reject</code> 都会将值赋给 <code>value</code> 变量；</li><li><code>setTimeout(cb, 0)</code> 使用了上述提到的 event loop，此时 <code>cb</code> 会在几乎 0ms 的间隔时间后，进入 task queue。</li></ol><p>参考链接：</p><ul><li><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&list=LLhaQJ_wSNai6JEl8bBjymqA&index=3&t=0s" target="_blank" rel="noopener">What the heck is the event loop anyway? | Philip Roberts | JSConf EU</a></p></li><li><p><a href="https://www.youtube.com/watch?v=PoRJizFvM7s&list=LLhaQJ_wSNai6JEl8bBjymqA&index=2&t=0s" target="_blank" rel="noopener">Async JS Crash Course - Callbacks, Promises, Async Await</a></p></li><li><p><a href="https://www.promisejs.org/implementing/" target="_blank" rel="noopener">Implementing</a></p></li><li><p><a href="https://stackoverflow.com/questions/23772801/basic-javascript-promise-implementation-attempt" target="_blank" rel="noopener">Basic Javascript promise implementation attempt</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非常推荐先看一下参考链接里两个 youtube 视频，分别介绍了 event loop 和 setTimeout 的实现原理，这对于理解 JavaScript 里异步操作实现非常有帮助。其次是关于 Promise object 的手动实现，有一些抽象，因为包含了大量的  callback 函数。这里一定要分清楚，哪些是函数的声明，哪些是函数的调用。&lt;/p&gt;
&lt;h2 id=&quot;Event-loop&quot;&gt;&lt;a href=&quot;#Event-loop&quot; class=&quot;headerlink&quot; title=&quot;Event loop&quot;&gt;&lt;/a&gt;Event loop&lt;/h2&gt;&lt;p&gt;JavaScript 是一种 single thread 的语言。既然单一线程，那么在某个时间点，只能完成一项任务。于是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;$.get(&amp;#39;http://twitter.com&amp;#39;)
$.get(&amp;#39;http://youtube.com&amp;#39;)
$.get(&amp;#39;http://google.com&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在单线程下，如果某一行执行所需要的时间太久了，那么余下的的 command 也无法执行，程序就在那一行停滞下来了。我们把这个叫做 blocking。然而事实上，当我们在使用 &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，程序似乎不会出现 blocking。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;Javascript&quot;&gt;console.log(&amp;#39;hi&amp;#39;)
setTimeout(() =&amp;gt; console.log(&amp;#39;there&amp;#39;), 0)
console.log(&amp;#39;Welcome!&amp;#39;)

// output:
// hi
// Welcome
// there&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里哪怕是设置 delay 为 0s， &lt;code&gt;setTimeout()&lt;/code&gt; 里的函数也是在最后才执行，是怎么回事呢？&lt;/p&gt;
&lt;p&gt;在 JavaScript 的执行环境中，所有的需要运行的函数是单线程的，按照次序会出现在 call stack 里。而通常，JavaScript 要么在 Browser 里运行，要么在 Node 环境运行，在 Browser 里运行时，会有一整套来自 Browser 提供的 web API，同理在 node 环境里也有相应的 API。 &lt;code&gt;setTimeout()&lt;/code&gt; 函数就来自这些提供的 API 中。当我们 declare and call  一个  &lt;code&gt;setTimeout()&lt;/code&gt; 函数时，Browser 会生成一个 timer 计时器，计时器的时间达到时，  &lt;code&gt;setTimeout()&lt;/code&gt;  里定义的 callback 函数会进入到一个叫 &lt;code&gt;task queue&lt;/code&gt; 的容器中，此时程序会去检测 call stack 是否为空，当 call stack 为空时，会将 task queue 中最上层的函数移入 call stack 中进行执行。因此本质上来讲，由于有 web API 的加持，最终类似  &lt;code&gt;setTimeout()&lt;/code&gt; 函数还是使用了多线程。只不过对于 JavaScript 来讲，一直是执行的是 call stack 里的内容，可以认为一直是单线程操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>赤烛 - 『还愿』</title>
    <link href="http://reyshawn.com/2019/02/21/%E8%B5%A4%E7%83%9B%20-%20%E3%80%8E%E8%BF%98%E6%84%BF%E3%80%8F/"/>
    <id>http://reyshawn.com/2019/02/21/赤烛 - 『还愿』/</id>
    <published>2019-02-21T08:24:34.698Z</published>
    <updated>2019-02-23T03:18:14.548Z</updated>
    
    <content type="html"><![CDATA[<p>『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。</p><blockquote><p>奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。</p><p>–<a href="https://hardimage.pro/32" target="_blank" rel="noopener">『奇异的……』 Episode 32 - 硬影像</a></p></blockquote><p>『还愿』同样是具有「奇情片」内核的恐怖游戏。</p><p>以下内容涉及剧透。</p><p>『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。</p><a id="more"></a><blockquote><p>以美麗島雜誌社成員為核心的黨外運動人士，於12月10日組織群眾進行遊行及演講，訴求民主與自由，終結黨禁和戒嚴。</p><p>…</p><p>此事件對台灣往後的政局發展有著重要影響，台灣民眾於美麗島事件後開始關心台灣政治。之後又陸續發生林宅血案（1980）、陳文成命案（1981）、劉江南命案（1984）撼動國際社會，使國民黨政府不斷遭受國際輿論的壓力以及黨外勢力的挑戰，之後國民黨漸漸不再稱呼黨外人士為野心陰謀份子，並逐漸放棄一黨專政的路線以應時勢，乃至於解除持續38年的戒嚴、開放黨禁、報禁。伴隨著國民黨政府的路線轉向，台灣主體意識日益確立，在教育、文化、社會意識等方面都有重大轉變。</p><p>–wikipedia 美麗島事件</p></blockquote><p>「美丽岛军事大审」的同时，1980 年 2 月 28 日，发生了震惊全台湾的「林宅血案」。2017 年上映的电影『血观音』，其中的一些情节就是取材于「林宅血案」，也获得了 54 届金马最佳影片。回到游戏里，1980 年 8 月，在这个时间杜家一家人搬入游戏里的这座「凶宅」。</p><p>最开始看到『还愿』预告的时候，就联想到了电影『血观音』。因为都有着很多相似的元素，比如「凶杀」、「观音」、「巫术」等等。但实际<del>游玩</del>（看过 游戏直播）之后，其实差别还是很大的。『血观音』里有较多的政治意味，『还愿』是在各种恐怖，宗教，民俗包裹下，还是只是在讲一个家庭的奇情故事，格局更小一些。</p><p><img src="/images/Game/devotion.png" alt="devotion"></p><p>1980 年到 1985 年、1986 年这些年，台湾经历了什么？因为 1979 年台湾和美国的断交，和「美丽岛事件」的影响，台湾在政治上逐渐变得民主和开放，经济上同样也是蓬勃发展。民众有了更多的娱乐活动，看电视，虽然当时全台湾只有三个台，大家能看的东西很少，所以港剧『楚留香』引进一下子就能在台湾创下了 70% 的收视率纪录。『五灯奖』是台视制作的一档综艺选秀节目，播出时间长达 33 年，也是游戏里「七彩星舞台」的原型。除了看电视之外，赌博之风也是尤为盛行，比如所谓的「大家乐」，就是 80 年代台湾很流行的一种非法赌博方式。</p><blockquote><p>台湾的娱乐工业 ，在 20 世纪 80 年代开始有了个爆发式的成长 。可以说 ，大家有了钱 ，就开始爱听靡靡之音 。</p><p>电视台三台都有许多的综艺节目出现 ，尤其是星期六及星期天晚上 ，是综艺节目的主战场 。当时的许多主持人或跑龙套的 ，现在都已经是综艺界的大佬 。不过当时的综艺节目 ，在一阵欢乐过后 ，主持人及来宾们一定都会合唱几首 “净化歌曲 ” ——不外就是那些 “观念正确 、意识健康 ” ，鼓吹乐观向上人生观的歌曲 ，就是怕大家听太多靡靡之音导致风气败坏 。于是每当节目结束前 ，我们就会看到所有参与这次节目的艺人排排站 ，在各无线电视台大乐队的伴奏下 ，一起双手打拍子 ，随着伴奏摇摆 ，一起高声齐唱 “净化歌曲 ” 。间奏时 ，主持人还会顺便感谢一下所有来宾 ，以及由 × × ×指挥所领导的 ×视大乐队 。</p><p>–『我们台湾这些年』</p></blockquote><p>也是受赌博风气的影响，出现了「求明牌」。怀着能从赌博里中奖和大捞一笔的心态，很多人希望从一些无关的自然现象，或是求神拜佛来得到神明的暗示。「迷信」在当时成为了很普遍的现象，其实即便是现在的中国农村，逢年过节，丧葬嫁娶，其中的许多繁复的形式和说法，在外人看来，也不过就是迷信罢了。但也要承认，「迷信」是民俗里重要的组成部分，所有的「迷信」也都不是突然出现的，它都和当时的社会背景，政治环境，经济环境，民众心态氛围息息相关。游戏里有很多的台湾 80 年代符号，旧电视机，选秀节目，红龙鱼，观音像，麻将。赤烛在一个封闭空间里，透过这些符号，希望还原出一个 80 年代台湾的真实社会状态。</p><blockquote><p>民眾篤信大家樂中獎號碼會出現於各種超自然現象中，稱為「明牌」。一時間，「求明牌」之風吹遍全臺灣。民眾紛紛湧入大小廟宇、道觀、陰廟、墳墓，向神佛、鬼魂求明牌，甚至膜拜各種物體如樹木、石頭等，希望這些物體上的精怪可以有神示。</p><p>–wikipedia 大家樂 (賭博) </p></blockquote><p>就是在这样一个伴随着动荡，民主，开放的社会氛围下，小杜美心在这新家里度过了他的 5 岁到 11 岁的时光，也就是从 1980 年到 1987 年。</p><p>父亲杜丰于，是一位小有成就的编剧，拿过宝岛文艺奖最佳编剧。母亲巩莉芳本是一位电影明星，在嫁给杜丰于之后，决定息影，在家做全职太太，操持家务。夫妻俩在 1975 年生下杜美心。在此之后，父亲杜丰于的编剧事业却不那么一帆风顺。80 年代的台湾正在逐渐变得开放，因此少有人再去愿意用杜丰于那样传统的，刻板的，了无新意的剧本。剧本多次被拒。事业上的不顺利也让整个家庭的经济情况陷入泥沼。被迫抛售祖宅，也许是因为便宜，搬到了这处据说发生过命案的「凶宅」。乔迁新居，尽管家庭经济状况并不好，喜好面子的父亲仍然邀请众多亲朋好友来家里庆祝。母亲不得不早上四五点起来开始购物置办准备。无论怎样，终于是在新家里安顿下来了。女儿杜美心，父亲母亲最大的希望就是让她像母亲一样成为大明星。从小开始练琴，学唱歌。</p><p>故事是如何慢慢走向悲剧的呢？大概从一开始，从父亲的编剧事业不顺，父亲的好面子，大男子主义，封建迷信开始，故事的结局就已经确定了。毕竟「人是很难改变的」。抛开游戏中所有的恐怖元素， jump scare，恐怖谷理论这些内容。单纯去看这个故事，去看这一家人。除了美心以外的其他人物都太平面扁平了。父亲杜丰于，承担了所有的反面角色的作用，他和何老师成为一切罪行的始作俑者。游戏中有一些父亲与女儿的交互，比如最温馨的故事书那段，拍照片那一段。但是更多的桥段都在展现这个父亲的负面形象，冷漠，易怒，装神弄鬼求神拜佛。父亲的存在，行动，都是在努力地推动整个故事的戏剧冲突，但有时候这样在父亲身上的硬设定，缺乏前因后果的行为，也会缺少说服力。尤其是故事的最后，也就是这故事最大的悲剧，更是觉得这父亲愚笨的难以理喻，怎么就信了别人的胡言乱语呢，你明明还那么爱你自己的女儿。这个地方，有点儿是编剧为了制造这么一个悲剧而一定要让父亲选择这么做。情节的展现也都是何老师的电话，单方面讲述，而父亲杜丰于的内心活动是缺失的。</p><p>母亲巩莉芳，承担了游戏大部分的惊吓点，也是游戏里唯一的女鬼担当。对于母亲的信息，游戏中透漏的很少。我们只知道她是曾经的电影明星，告别影坛后勤俭持家。在 1986 年决定复出，在之后下落不明。故事里可能唯一让人喜欢的，就是小美心了，心理活动刻画的也很多。所有大人的刻画都是平面的，扁平的，就像游戏里出现的纸人一样。</p><p>整体来看，『还愿』仍旧是一步水平上乘的恐怖游戏。尽管借鉴了不少优秀的前作，『寂静岭P.T.』的时空交叉，『艾迪芬奇的记忆』（(What Remains of Edith Finch）的电影叙事。但「赤烛」毕竟是一个台湾团队，『还愿』是一个闽南文化背景的中文作品。当你能无障碍的阅读墙上张贴的小广告，电视广告，背景录音，所获的信息和体验都比你去玩一款欧美文化背景游戏多很多，共鸣也会更大。就好像我去看『牯岭街少年杀人事件』，一定总能带给我最大的震撼一样。</p><p>参考</p><ul><li><a href="https://hardimage.pro/32" target="_blank" rel="noopener">『奇异的……』 Episode 32 - 硬影像</a></li><li>『我们台湾这些年』</li><li><a href="https://www.youtube.com/watch?v=TsCok5DX8uA&frags=pl%2Cwn" target="_blank" rel="noopener">還願Devotion | 玩之前必知的七大民俗文化知識AdamDD</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;『还愿』这个游戏，从去年放出预告开始，我就有关注。去年 7 月释出先导预告，内容是几支 80 年代广告和一档童星选秀节目。随后又陆续释出一些图片，比如贴满广告的大门的照片。去看网上关于这些预告的分析，发现这里不免夹杂了凶杀、分尸、拜神、祭祀等等恐怖惊悚的「奇情」元素。这些内容会让人联想到『血观音』，会联想到 93 年的香港电影『人肉叉烧包』，或者是15 年翁子光导演执导的『踏血寻梅』。这类电影都可以归纳为「奇情片」的概念，它们往往会是一些凶杀案件，和普通的犯罪片不同，犯罪手段通常都是凶狠残忍，而且动机难以捉摸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;奇情电影的背后往往蕴含着对时局动荡、社会不稳定的一种本能性的恐惧。要么直接诉苦，要么转移视线。&lt;/p&gt;
&lt;p&gt;–&lt;a href=&quot;https://hardimage.pro/32&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;『奇异的……』 Episode 32 - 硬影像&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;『还愿』同样是具有「奇情片」内核的恐怖游戏。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
&lt;p&gt;『还愿』的故事背景设定在 80 年代的台湾。故事的叙述在 1980 年，1985 年，1986 年三个时间点互相穿梭，交叉叙事。80 年代的台湾究竟发生了什么？1979 年末发生了轰动一时的「美丽岛事件」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="http://reyshawn.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>棋盘上的「古墓丽影」</title>
    <link href="http://reyshawn.com/2019/02/07/%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E3%80%8C%E5%8F%A4%E5%A2%93%E4%B8%BD%E5%BD%B1%E3%80%8D/"/>
    <id>http://reyshawn.com/2019/02/07/棋盘上的「古墓丽影」/</id>
    <published>2019-02-07T13:15:26.950Z</published>
    <updated>2019-02-07T13:39:29.295Z</updated>
    
    <content type="html"><![CDATA[<p>又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。</p><p>![Lara Go 1](/images/Game/Lara Go 1.jpg)</p><p>游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。</p><p>以下内容涉及剧透。</p><a id="more"></a><p><img src="/images/Game/Go-Trilogy.png" alt="Go-Trilogy"></p><p>Lara Go 相比于另外两作，整个游戏特色上加入「冒险」的元素。游戏玩法上引入「攀爬」系统。这样在游戏解密的过程中，就不再只是考虑单纯的 XY 平面移动，还会有来自 Z 轴的变换。这一点体现在，比如堆叠石柱，陷坑，升降机关等等。故事的核心就像最传统，最 typical 的 Tomb Raider 的故事那样，主角 Lara 来到一片丛林，在丛林深处发现一处秘境，那里保存着一个类似「魔方」的器物，获得「魔方」需要三颗石头，获得这三颗石头，必须经历三处迷宫：The Maze of Snakes，The Maze of Stones，The Maze of Spirits。要分别经历这三处迷宫，获得三个石头，打开大门，最后才能获得「魔方」，「魔方」被拿下同时，整个秘境也变得不稳定，似乎开始坍塌陷落，于是就要尽快从秘境中逃脱。这是主线内容，除此以外，Lara Go 里还有两个支线，New Adventure，分别是 The Cave of Fire 和 The Mirror of Spirits。</p><p>最有趣的章节都是来自番外。本作也是这样，全部玩下来，后面的两个 New Adventure，是我认为这个游戏设计的最棒的两个章节。The Cave of Fire 里引入了「复活系统」，在你消灭怪物后的四个回合，怪物会自动复活。所以，不再像之前那样想着如何解决掉怪物。大多数情况需要通过引诱怪物，触发某些机关，或是利用怪物复活前的四个回合，进行一些别的操作。因此，这就让每一步限制得特别死，在若干条线路中，最优的线路可能只有一条，还要不断计算机关复原的回合数，怪物复活的回合数。这些都需要比之前章节更多的思考。The Mirror of Spirits 这个章节实在是太棒了。这个章节里第一次引入了「光」系统，通过「光」来触发机关。另外最具创意的是加入了「镜像」概念。这样的美术风格和玩法模式，相比类似的「纪念碑谷」来讲，都高出太多了。画面里，游戏的一半会出现一个镜像场景，镜像场景里会有一个镜像人物。镜像场景一开始是和真实世界相同，后来就会慢慢出现了些许不同，比如不同的机关，位置不同的出口，不同的怪物，甚至不同的地形布局。这里，镜像人物的死亡，也会导致真实人物的死亡，所以解谜过程中，不仅要注意真实世界的机关，还要兼顾镜像世界里的种种要素。必要的时候，你还要进入到镜像世界，而镜像人物会来到真实世界。这样的设定，把之前那种简单的 turn-based 解谜游戏，可能只是搬动一下开关，到这里直接上升到一个新的 level，无论是游戏玩法，还是美术风格。</p><p>![Lara Go ](/images/Game/Lara Go .jpg)</p><p>![Lara Go 3](/images/Game/Lara Go 3.jpg)</p><p>说下几处自己游玩时印象深刻的点：在获得「魔方」时候，进入下一篇章，The Escape 逃亡章节。场景变的昏暗，黑色剪影的背景是不断掉落的碎石，背景音乐也突然变得紧张急促。在这个章节的游戏解密里，也尽量设计的简单。比如，拉下机关后，需要迅速通过射箭的区域。恰到好处地营造出逃亡的氛围。第二个印象深刻的点，是在火把的第一次出现，拿到火把之后，之前那些吓人的怪物，终于不再敢靠近半步。以及，在  The Mirror of Spirits，镜像的第一次出现，第一次控制真实人物进入到镜像世界里，第一次通过机关，让镜像人物和真实人物出现「异步」行动。这些一切，心中不免会涌现冒险紧张激动和解谜成功的快感，也让我不断地赞叹设计师，赞叹这个游戏的开发者。</p><p>![Lara Go 2](/images/Game/Lara Go 2.jpg)</p><p>这部游戏发布于 2015 年，也获得了诸如 Apple Design Award，TGA Best Mobile Game 等多项大奖。但比较可惜的是， Square Enix Montreal 确定不会再制作 Go 系列游戏。</p><blockquote><p>Square Enix Montreal studio head Patrick Naud confirmed that the studio is not working on any new <em>Go</em> games, saying that “one of the challenges we have today is the premium mobile market is diminishing.” He pointed specifically to their prices (the <em>Go</em> games are each $4.99), saying that it’s “such a big barrier for mobile users.”</p></blockquote><p>在移动端平台，大多数游戏的运营模式都是免费加内购的形式。内购的内容也往往是游戏内的金币什么。而对于类似 Lara Go 这样小而美，精致的独立游戏，在浩荡的移动平台市场，并没有什么竞争力。不管是劣币驱除良币，还是说现代生活节奏加快，人们都是更加偏爱快餐类型的消费，游戏也好，电影也好。虽然很明确 Go 不会有下一部续作，但 Go 这种棋盘风格的解谜游戏，这样的游戏方式，因其独有的风格，一定会得到延续。</p><p>参考：</p><ul><li><a href="https://www.theverge.com/2018/6/3/17422724/square-enix-montreal-no-longer-making-go-games-lara-croft-hitman-deus-ex-free-to-play" target="_blank" rel="noopener">Square Enix Montreal is no longer making Go games - The Verge</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个新年过去了。在年复一年不变的习俗和渐渐消淡的年味里，我把 Lara Croft Go 打通了。在 Square Enix 的 Go 游戏三部曲里，Hitman Go 是几年前玩过的，去年尝试了 Deus Ex Go。相比之下，更喜欢这部 Lara Go。Deus 里的科幻风太过浓重，Hitman Go 很贴近现代都市，在棋盘模拟的场景里，有熟悉的游泳池，花园，房屋里的家具等等。Lara Go 的场景都是放在野外，山窟洞穴，悬崖峭壁。如果另外两作的特点都是在「潜入」，那么 Lara Go 的特点则是在「冒险」。尽管有着固定的棋盘，每次只能前进一格，但这的确是个不折不扣的 Tomb Raider 式的冒险故事。&lt;/p&gt;
&lt;p&gt;![Lara Go 1](/images/Game/Lara Go 1.jpg)&lt;/p&gt;
&lt;p&gt;游戏整体美术风格，偏向折纸，背景的黑色剪影提供沉浸感。这样的美术风格在 iOS 平台并不少见。熟悉的有「纪念碑谷」「Alto’s Odyssey」。这样偏折纸的艺术风格，也比较适合这样的游戏模式。Square Enix 在 Go 系列游戏里想做的，是希望把 Go 系列做成一种桌游类型的游戏，所以这样的折纸风格再完美不过了。几年前在玩 Hitman Go 时，每一关的地图，都是按照桌游的包装盒来设计的。&lt;/p&gt;
&lt;p&gt;以下内容涉及剧透。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏" scheme="http://reyshawn.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="故事" scheme="http://reyshawn.com/tags/%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>「User Authentication with Passport and Koa 」Summary</title>
    <link href="http://reyshawn.com/2019/01/31/%E3%80%8CUser%20Authentication%20with%20Passport%20and%20Koa%20%E3%80%8DSummary/"/>
    <id>http://reyshawn.com/2019/01/31/「User Authentication with Passport and Koa 」Summary/</id>
    <published>2019-01-31T02:11:15.356Z</published>
    <updated>2019-02-02T14:15:36.141Z</updated>
    
    <content type="html"><![CDATA[<p>上周在阅读 <em>Express.js Blueprints</em> 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 <a href="https://mherman.org/blog/user-authentication-with-passport-and-koa/" target="_blank" rel="noopener">User Authentication with Passport and Koa</a> 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。</p><p>需要通过 brew 安装：</p><ul><li>postgresql</li><li>redis</li></ul><p>使用 npm 全局安装：</p><ul><li>knex</li></ul><a id="more"></a><h2 id="文件结构，逻辑"><a href="#文件结构，逻辑" class="headerlink" title="文件结构，逻辑"></a>文件结构，逻辑</h2><p>文件最后的结构：</p><pre><code class="shell">.├── LICENSE├── README.md├── knexfile.js├── package-lock.json├── package.json├── src│   └── server│       ├── auth.js│       ├── db│       │   ├── connection.js│       │   ├── migrations│       │   │   ├── 20170817152841_movies.js│       │   │   └── 20190127152820_users.js│       │   ├── queries│       │   │   ├── movies.js│       │   │   └── users.js│       │   └── seeds│       │       ├── movies_seed.js│       │       └── users.js│       ├── index.js│       ├── routes│       │   ├── auth.js│       │   ├── index.js│       │   └── movies.js│       └── views│           ├── login.html│           ├── register.html│           └── status.html└── test    ├── routes.auth.test.js    ├── routes.index.test.js    ├── routes.movies.test.js    └── sample.test.js</code></pre><p>有一些文件夹，文件属于自动生成的 boilerplate，比如 <code>package.json</code>，<code>knexfile.js</code>，<code>db</code> 文件夹里的一些内容。项目的结构清晰明朗。<code>test</code> 为测试文件夹。测试文件的标题统一加上 <code>test</code> 标示，并用 dot 分隔。这也提醒自己，文件标题的命名可以不使用 underscore 或 dash 来分隔，也可以用 dot。在 <code>server</code> 文件夹下，<code>db</code> 几乎都是数据库，knex 相关的。另外有路由 <code>routes</code> 文件夹和 <code>views</code> 视图文件夹。</p><h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><p>在 macOS 上直接使用 Brew 安装即可。由于我个人不习惯开机自动启动数据库，那个需要用到类似 <code>service start</code> 的命令。这里是手动开启的办法：</p><pre><code class="shell">$ pg_ctl -D /usr/local/var/postgres start  </code></pre><p>和 Mysql 一样，把 <code>start</code> 可以换成 <code>stop</code>，<code>restart</code>。</p><p>数据库初始化：</p><pre><code class="shell">$ initdb /usr/local/var/postgres  </code></pre><p>在这篇教程里，需要我事先创建两个数据库，创建数据库用如下命令：</p><pre><code class="shell">$ createdb koa_api    $ createdb koa_api_test</code></pre><p><code>psql</code> + Database，进入 database 的命令行。</p><p><code>\dt</code> 显示所有 tables</p><blockquote><p>Please note the following commands:</p><ul><li><code>\list</code> or <code>\l</code>: list all databases</li><li><code>\dt</code>: list all tables in the current database</li></ul><p>You will never see tables in other databases, these tables aren’t visible. You have to connect to the correct database to see its tables (and other objects).</p><p>To switch databases:</p><pre><code>\connect database_name` or `\c database_name</code></pre><p>See the manual about <a href="http://www.postgresql.org/docs/current/interactive/app-psql.html" target="_blank" rel="noopener">psql</a>.</p><p>– <a href="https://dba.stackexchange.com/questions/1285/how-do-i-list-all-databases-and-tables-using-psql" target="_blank" rel="noopener">How do I list all databases and tables using psql?</a></p></blockquote><p>除此以外，还可以通过 Knex 来创建数据库。理论上，可以通过 Knex 来进行所有的数据库操作。</p><h2 id="knex"><a href="#knex" class="headerlink" title="knex"></a>knex</h2><blockquote><p><strong>Knex.js</strong> is a “batteries included” SQL query builder for <strong>Postgres</strong>, <strong>MSSQL</strong>, <strong>MySQL</strong>, <strong>MariaDB</strong>, <strong>SQLite3</strong>, <strong>Oracle</strong>, and <strong>Amazon Redshift</strong> designed to be flexible, portable, and fun to use. </p><p>– <a href="https://knexjs.org" target="_blank" rel="noopener">Knex.js</a></p></blockquote><p>Knex，可以看作是各种不同数据库下统一封装的一套 API。通过 Knex 来和数据库进行交互。比如创建表，更新，添加数据等等。上文引用里提到了「battery-included」一词，意思是「开箱即用」，即这个 Library 已经包含了它所需要的全部依赖 Dependency。我们装完拿来直接用即可，不需要在进行其他 Library 的安装。</p><p><img src="/images/knex.png" alt="knex"></p><p>因为要频繁在 Terminal 里用到 <code>knex</code> 命令，所以最后事先全局安装 Knex。在这篇教程里，我们在使用 Postgresql 创建完数据库以后，会看到需要我们执行这两条命令：</p><pre><code class="shell">$ knex migrate:latest --env development$ knex seed:run --env development</code></pre><hr><p><em>Tips：</em></p><p><em>如果不想要全局安装 Knex，依然想在 Terminal 运行。在生成的 <code>node_modules</code> 文件夹下会有个隐藏文件夹 <code>.bin</code>，里面包含了全部我们可以直接运行的 package。所以直接：</em></p><pre><code class="shell">$ node_modules/.bin/knex init</code></pre><hr><p><code>init</code> 之后，本地会自动生成一个 <code>knexfile.js</code> 文件。里面大致是些 boilerplates。在这篇教程给的 source code 里，    <code>knexfile.js</code> 已经针对 postgresql 配置完毕。但这里要明白 migration 和 seed 两个操作。</p><blockquote><p>Migrations are a way to make database changes or updates, like creating or dropping tables, as well as updating a table with new columns with constraints via generated scripts. We can build these scripts via the command line using <code>knex</code>command line tool.</p></blockquote><p>例如，通过 knex 创建 table：</p><pre><code class="shell">$ knex migrate:make users</code></pre><p>这里会自动生成一个 <code>users.js</code> 文件，文件名前面还会有 time stamp。存储路径在 <code>./server/db/migration/</code>。所有的文件夹都会自动生成。在新生成的文件，我们需要定义新建的这个 table 各个 field 属性。例如在这篇文章的例子里，新建了 users table，定义属性如下：</p><pre><code class="javascript">exports.up = (knex, Promise) =&gt; {  return knex.schema.createTable(&#39;users&#39;, (table) =&gt; {    table.increments();    table.string(&#39;username&#39;).unique().notNullable();    table.string(&#39;password&#39;).notNullable();  });};exports.down = (knex, Promise) =&gt; {  return knex.schema.dropTable(&#39;users&#39;);};</code></pre><p>通过下面这条命令来应用我们定义的属性：</p><pre><code class="shell">knex migrate:latest --env development</code></pre><blockquote><p>To run the migration, use the command:</p><pre><code>knex migrate:latest</code></pre><p>The default environment is development, which works for us here, but if you need to specify a different environment, such as a test environment, then you can use the <em>env</em> flag in the migration command like:</p><pre><code>knex migrate:latest --env test</code></pre></blockquote><p><code>development</code> 是我们事先在 <code>knexfile.js</code> 里定义好的。可以理解为对于 database 的映射。从上面定义的属性中，可以很轻松的知道这个 table 有两个 field，分别是 <code>username</code> 和 <code>password</code>。以及每个 field 的属性都通过 chain function 的形式来表达。</p><blockquote><p>Similar to migrations, the <code>knex</code> module allows us to create scripts to insert initial data into our tables called seed files! If we have relations on our tables, the seeding <strong>must be in a specific order</strong> to so that we can rely on data that might already be in the database. </p></blockquote><p>seed 是用来初始化数据的。同 migrate 一样：</p><pre><code class="shell">$ knex seed:make users$ knex seed:run --env development</code></pre><p>line 1 会自动创建一个 <code>user.js</code> 在路径 <code>./server/db/seeds/</code> 里。line 2 运行这个 seeds，对 table 里数据进行初始化。</p><h2 id="Mocha-js-Chai-js"><a href="#Mocha-js-Chai-js" class="headerlink" title="Mocha.js ,  Chai.js"></a>Mocha.js ,  Chai.js</h2><p>一个测试 module 被称为 specification，简称 spec，结构如下图所示：</p><p><img src="/images/Mocha_test.png" alt="Mocha_test"></p><p>在这篇教程中，用到 Mocha 和 Chai 两个测试 Library。</p><blockquote><ul><li><a href="http://mochajs.org/" target="_blank" rel="noopener">Mocha</a> – the core framework: it provides common testing functions including <code>describe</code> and <code>it</code> and the main function that runs tests.</li><li><a href="http://chaijs.com/" target="_blank" rel="noopener">Chai</a> – the library with many assertions. It allows to use a lot of different assertions, for now we need only <code>assert.equal</code>.</li></ul></blockquote><p>使用 Mocha 进行测试，运行 Mocha，它会自动找项目目录里 test 文件夹下的文件运行。</p><blockquote><p>Mocha automatically looks for tests inside the <code>**test**</code> directory of your project. Hence, you should go ahead and create this directory in your project root.</p></blockquote><p>以下是写的一个很简单的小例子：</p><pre><code class="javascript">const assert = require(&#39;assert&#39;);describe(&quot;sample&quot;, ()=&gt;{    it(&quot;it&#39;s just a test&quot;, ()=&gt;{        let x = 5;        let result = x;        assert.equal(Math.pow(x, 1), result);    });});</code></pre><p>在 Terminal 里运行：</p><pre><code class="shell">$ node_modules/.bin/_mocha  sample    ✓ it&#39;s just a test  1 passing (6ms)</code></pre><p>Chai 的作用是提供了更多测试的方法。例如教程里测试是否 render view 成功：</p><pre><code class="javascript">describe(&#39;GET /auth/register&#39;, () =&gt; {  it(&#39;should render the register view&#39;, (done) =&gt; {    chai.request(server)    .get(&#39;/auth/register&#39;)    .end((err, res) =&gt; {      should.not.exist(err);      res.redirects.length.should.eql(0);      res.status.should.eql(200);      res.type.should.eql(&#39;text/html&#39;);      res.text.should.contain(&#39;&lt;h1&gt;Register&lt;/h1&gt;&#39;);      res.text.should.contain(        &#39;&lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Register&lt;/button&gt;&lt;/p&gt;&#39;);      done();    });  });});</code></pre><p>其主要内容检测返回的 res 里有没有想的 DOM Node 。当然，前提还是去验证返回代码是否是 200， 返回文本类型这些。</p><h2 id="Redis-Session"><a href="#Redis-Session" class="headerlink" title="Redis, Session"></a>Redis, Session</h2><p>这篇教程的最后介绍了 redis，把用户的 user 信息从 memory 中拿出来存进 redis 里。这样当关闭浏览器，短时间再重新打开时，不需要重新输入用户名密码进行登录。</p><blockquote><p>It’s a good idea to move session data out of memory and into an external session store as you begin scaling your application.</p></blockquote><p>Redis 同样也是数据库 Database，但不同于之前接触的 MySql，Postgresql，Redis 属于 in-memory database。看了 Wikipedia 的解释。in-memory database 主要依赖于内存 memory，而不是通常的外存 storage。</p><p>关于 session 和 cookie 的区别。</p><p>cookie 是存储在 client 端的，通常是一些偏好设定，比如颜色啊等等，通常不会有敏感信息。session 存储在 server 端，因为 http 通信是无状态的。session 用来保存 client 和 server 之间的通信状态，以及 client 可能会访问多个不同的页面，这些页面都在这一个 server 上，通信的双方并没有变化，通过 session 在不同的页面共享数据。</p><blockquote><p>A session is a unit of maybe variables, state, settings while a certain user is accessing a server/domain in a specific time frame. All the session information is in the traditional model stored on the server (!)</p><p>Because many concurrent users can visit a server/domain at the same time the server needs to be able to distinguish many different concurrent sessions and always assign the right session to the right user. (And no user may “steal” another uses’s session)</p></blockquote><p>这里首先用到两个 middleware，koa-session 和 koa-redis。koa-session 是 koa 基础的 session 管理 middleware。通常 session 是存储在 memory 里的，通过 koa-redis 将 session 存储在 redis 里。</p><p>把 session 存储在 redis 的优势：</p><blockquote><p>Redis is perfect for storing sessions. All operations are performed in memory, and so reads and writes will be fast. </p><p>The second aspect is persistence of session state. Redis gives you a lot of flexibility in how you want to persist session state to your hard-disk. You can go through <a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">http://redis.io/topics/persistence</a> to learn more, but at a high level, here are your options …</p></blockquote><p>依旧是通过 brew 安装 redis。</p><p>redis 启动：</p><pre><code class="shell">$ redis-server /usr/local/etc/redis.conf</code></pre><p>redis 关闭，直接 <code>ctrl</code> + <code>C</code> 或是：</p><pre><code class="shell">$ redis-cli shutdown</code></pre><p>参考：</p><ul><li><a href="https://knexjs.org" target="_blank" rel="noopener">Knex.js</a></li><li><a href="https://medium.com/@jaeger.rob/seed-knex-postgresql-database-with-json-data-3677c6e7c9bc" target="_blank" rel="noopener">Seed Knex PostgreSQL Database with JSON Data</a></li><li><a href="https://github.com/l4nk332/stuff/tree/master/node/Knex" target="_blank" rel="noopener">l4nk332/stuff - Github</a></li><li><a href="https://www.zhihu.com/question/24710451" target="_blank" rel="noopener">「batteries-included」该怎么翻译比较好？ - 知乎</a></li><li><a href="https://gist.github.com/NigelEarle/70db130cc040cc2868555b29a0278261" target="_blank" rel="noopener">Migrations &amp; Seeding</a></li><li><a href="https://javascript.info/testing-mocha" target="_blank" rel="noopener">Automated testing with mocha</a></li><li><a href="https://stackoverflow.com/questions/12236890/run-mocha-tests-in-test-environment" target="_blank" rel="noopener">Run mocha tests in test environment? - StackOverflow</a></li><li><a href="https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d" target="_blank" rel="noopener">A quick and complete guide to Mocha testing</a></li><li><a href="https://stackoverflow.com/questions/623815/what-is-the-difference-between-a-session-and-a-cookie" target="_blank" rel="noopener">What is the difference between a Session and a Cookie? - StackOverflow</a></li><li><a href="https://stackoverflow.com/questions/10278683/how-safe-is-it-to-store-sessions-with-redis" target="_blank" rel="noopener">How safe is it to store sessions with Redis?</a></li><li><a href="https://medium.com/@petehouston/install-and-config-redis-on-mac-os-x-via-homebrew-eb8df9a4f298" target="_blank" rel="noopener">Install and config Redis on Mac OS X via Homebrew</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周在阅读 &lt;em&gt;Express.js Blueprints&lt;/em&gt; 时看到 Authentication 的部分，就想着使用 Koa 去复现一遍。于是在网上看到这篇文章 &lt;a href=&quot;https://mherman.org/blog/user-authentication-with-passport-and-koa/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;User Authentication with Passport and Koa&lt;/a&gt; 。文章给出了源代码和详细的步骤。其中不乏遇到自己不熟悉的知识领域，比如 knex，postgresql 和 redis 等等。写这篇文章的目的：一是熟悉下在 koa 框架下的程序结构；二是对于自己不熟悉的知识领域的一个总结。&lt;/p&gt;
&lt;p&gt;需要通过 brew 安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;postgresql&lt;/li&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 npm 全局安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;knex&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>初见 Koa.js</title>
    <link href="http://reyshawn.com/2019/01/26/%E5%88%9D%E8%A7%81%20Koa/"/>
    <id>http://reyshawn.com/2019/01/26/初见 Koa/</id>
    <published>2019-01-26T11:41:00.000Z</published>
    <updated>2019-01-26T11:48:30.956Z</updated>
    
    <content type="html"><![CDATA[<p>去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：</p><ul><li>Node.js 的异步特性及异步是如何实现的</li><li>异步实现的几种方式，callback 到 Promise 到 async/await</li><li>什么是 middleware？</li><li>ejs template engine</li></ul><p>通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。</p><a id="more"></a><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p><code>app.use()</code> 就是添加一个 middleware。我们通过 Koa 进行的许多操作，比如处理 request，处理 data，routing 都是通过 <code>app.use()</code> 来实现的。</p><p><code>ctx</code> 内封装了 request 和 response  object。</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async function(ctx) {    ctx.body = &quot;hello world ssss&quot;;})app.listen(3000, function() {    console.log(&#39;listen port: 3000...&#39;)})</code></pre><h2 id="渲染-ejs-模版"><a href="#渲染-ejs-模版" class="headerlink" title="渲染 ejs 模版"></a>渲染 ejs 模版</h2><p>这里以 ejs 为例来进行说明，其他的 template engine，使用方法都是相通的。</p><p>使用 npm 安装：</p><pre><code class="shell">$ npm install koa-views --save$ npm install ejs --save</code></pre><p>server.js 内容是</p><pre><code class="javascript">const Koa = require(&#39;koa&#39;);const app = new Koa();const views = require(&#39;koa-views&#39;);app.use(views(__dirname + &#39;/views&#39;, {    map: {        html: &#39;ejs&#39;    }}));app.use(async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;);})app.listen(3000, function() {    console.log(&#39;listen port: 3000...&#39;)})</code></pre><p><code>./views/layout.ejs</code> 内容是</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello Koa, This is from ejs&lt;/h1&gt;&lt;/body&gt;</code></pre><p>上面这个例子是不包含传值的，当需要向 template 传递值时，通过 <code>ctx.state</code> 来设置，将上面 render 部分修改成：</p><pre><code class="javascript">app.use(async function(ctx) {    ctx.state = {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    };    await ctx.render(&#39;layout.ejs&#39;);})</code></pre><p>或者写成 <code>render</code> 的参数，二者是等价的：</p><pre><code class="javascript">app.use(async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    });})</code></pre><p>此时 template 修改成：</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><p>通常我们在写一个 template 的时候，会分成好多组件，首先有一个大体的框架，layout.ejs，新建一个 partials 文件夹，里面存储我们所需的各个组件，如 head.ejs，header.ejs，footer.ejs 等等。我们在一个需要渲染的页面里引用这些组件，那么这个过程在 koa 应该如何实现呢？</p><p>这里直接在 ejs 里使用 <code>include</code> 进行引用。</p><p>header.ejs</p><pre><code class="html">&lt;header&gt;    &lt;p&gt;This is a header&lt;/p&gt;&lt;/header&gt;</code></pre><p>layout.ejs</p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;&lt;%- title %&gt;&lt;/h1&gt;    &lt;p&gt;&lt;%- body %&gt;&lt;/p&gt;&lt;/body&gt;</code></pre><h2 id="Router-路由功能"><a href="#Router-路由功能" class="headerlink" title="Router 路由功能"></a>Router 路由功能</h2><p>对于一个 web site，需要处理各种各样不同的请求，针对不同的请求 request，有着不同的反馈 response，以及可能要调用不同的资源 resource。有些需要调用一些 javascript 文件，css 文件，有些需要调用一些图片 images，有些需要访问数据库。这些不同的资源 resource 有着不同的存储路径，为了让 request 得到合适的反馈，就需要一个 router 路由功能，告诉 server，这个 request，需要去哪里找相应的 resource 去反馈。</p><p><img src="/images/koa_routing.png" alt="koa_routing"></p><pre><code class="shell">$ npm install koa-router --save</code></pre><p>server.js 中修改为：</p><pre><code class="javascript">const Router = require(&#39;koa-router&#39;);const router = new Router()router.get(&#39;/&#39;, async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        title: &#39;This is title&#39;,        body: &#39;body bla bla&#39;    });})app.use(router.routes());</code></pre><p>我们看到，各个页面的渲染完全由 router 进行了接管。</p><p>上面是最简单的 “Get” 请求，下面是给出一个”Post” 请求的例子，来自 <a href="https://chenshenhai.github.io/koa2-note/note/request/post.html" target="_blank" rel="noopener">koa2 进阶学习笔记</a>，我做了一些小改动，原文使用的是原生 koa 中的 ctx 来判断请求。我这里直接使用了 <code>koa-router</code> 实现，通过对比，也可以明白 koa-router 这个 module 是如何工作的，只不过是在原生 Koa 基础上增加了一层判断。</p><pre><code class="javascript">// receive the posting datafunction parsePostData(ctx) {    return new Promise((resolve, reject) =&gt; {        try {            let postData = &quot;&quot;;            ctx.req.addListener(&#39;data&#39;, (data) =&gt; {                postData += data;            });            ctx.req.addListener(&#39;end&#39;, () =&gt; {                let parseData = parseQueryStr(postData);                resolve(parseData);            });        } catch(err) {            reject(err);        }    })}// convert the posting data to Objectfunction parseQueryStr(data) {    let queryData = {};    let queryStrList = data.split(&#39;&amp;&#39;);    for (let queryStr of queryStrList) {        let itemList = queryStr.split(&#39;=&#39;);        queryData[ itemList[0] ] = decodeURIComponent(itemList[1]);    }    return queryData;}app.use(views(__dirname + &#39;/views&#39;, {    map: {        html: &#39;ejs&#39;    }}));router.get(&#39;/&#39;, async function(ctx) {    await ctx.render(&#39;layout.ejs&#39;, {        data: &#39;no data posted&#39;    });})router.post(&#39;/&#39;, async function(ctx) {    let postData = await parsePostData(ctx);    await ctx.render(&#39;layout.ejs&#39;, {        data: JSON.stringify(postData)    })})app.use(router.routes());</code></pre><p>layout.ejs 添加一个可以提交的表格，注意表格的 <code>method</code> 是 <code>POST</code>，<code>action</code> 是根目录页面 <code>&quot;/&quot;</code>。 </p><pre><code class="ejs">&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;%- include ./header %&gt;    &lt;h1&gt;koa2 request post demo&lt;/h1&gt;      &lt;form method=&quot;POST&quot; action=&quot;/&quot;&gt;            &lt;p&gt;userName&lt;/p&gt;            &lt;input name=&quot;userName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;nickName&lt;/p&gt;            &lt;input name=&quot;nickName&quot; /&gt;&lt;br/&gt;            &lt;p&gt;email&lt;/p&gt;            &lt;input name=&quot;email&quot; /&gt;&lt;br/&gt;            &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;      &lt;/form&gt;      &lt;p&gt;&lt;%- data %&gt;&lt;p&gt;&lt;/body&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去网上检索 Koa，往往会看到诸多 Koa 和 Express 文章。Koa 的确是比 Express 更新的框架，因此也使用到了 ES6 更新的特性，比如 async/await。Koa 的核心 module 仅仅是 middleware kernel，Express 则提供了一套完整的解决方案，功能，routing，template 这些。Koa 要使用这些需要安装额外的 module。这样的对比，容易让人联想到 editor 和 IDE 的区别，前者注重轻量，可定制，后者追求大而全的设计。两种不同的设计哲学，我是偏爱前者，相信 less is more 的力量。当然，毕竟 Koa 和 Express 都是来自于同一个开发团队，很多基础概念是相通的。阅读本文，你需要提前了解以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 的异步特性及异步是如何实现的&lt;/li&gt;
&lt;li&gt;异步实现的几种方式，callback 到 Promise 到 async/await&lt;/li&gt;
&lt;li&gt;什么是 middleware？&lt;/li&gt;
&lt;li&gt;ejs template engine&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过本文，你能了解到。Koa 最基础的 HelloWorld，它 如何渲染一个 template 页面，传递数据。什么是「Routing 路由」，路由在 Koa 中如何实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>异步 &amp; callback</title>
    <link href="http://reyshawn.com/2019/01/25/%E5%BC%82%E6%AD%A5%20&amp;%20callback/"/>
    <id>http://reyshawn.com/2019/01/25/异步 &amp; callback/</id>
    <published>2019-01-25T03:27:39.896Z</published>
    <updated>2019-01-25T08:52:18.896Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习 Node.js。主要看两本书：<em>Node.js in Practice</em> 和 <em>Node.js Design Patterns</em>。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;solution 实现的。后者就是 <a href="https://search.packtpub.com/" target="_blank" rel="noopener">Packt Publishing</a> 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。</p><p>这篇文章以 <em>Node.js Design Patterns</em> 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。</p><a id="more"></a><h2 id="callback，递归，libuv"><a href="#callback，递归，libuv" class="headerlink" title="callback，递归，libuv"></a>callback，递归，libuv</h2><blockquote><p>Callbacks are to be used when we don’t know <strong>when</strong> something will be done. Again, think of something like an API call, fetching data from a database or I/O with the hard drive.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>在解决一些算法题目时，经常会用到「递归」。「递归」是函数不断调用自身的过程。callback 和「递归」有些相似，区别是，「递归」是重复的调用自身，而 callback 是去调用另一个不同的函数。本质来讲，都会形成一个  <a href="http://www.wikiwand.com/en/Call_stack" target="_blank" rel="noopener">Call stack</a>。那么为什么可以通过 callback 来实现异步？</p><pre><code class="javascript">// This is synchronous.function processData() {       let data = fetchData();       data += 1;       return data; }// This is asynchronous... function processData(callback) {       fetchData(function (err, data) {             if (err) {           return callback(err);        }             data += 1;             callback(null, data);       }); }</code></pre><p>在  synchronous 中，line 3 获得数据，存储在 data 中，line 4 对数据进行处理。这是一个线性的，单线程的，需要等待的 synchronous 操作。在 async 中，函数 <code>fetchData()</code> 多了一个 callback 参数，后续的数据处理，<code>data += 1</code> 写在了这个 callback 里。也就意味着，当调用 <code>fetchData()</code> 后，整个程序不会停下来等待，而是接着进行下面的操作。当 <code>fetchData()</code> 中获得了数据，更抽象点，是达成了某个条件，则调用 callback 函数。</p><blockquote><p>Callbacks are functions. You pass them to other functions so they can be executed when the time is right, i.e. when the event needed by the callback has happened.</p><p>–<a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></p></blockquote><p>看似在 async 中出现了第二条线程，实际上，在 Node.js 中依旧是单线程。通过单线程，来模拟多线程下的 concurrency，借助底层库 <code>libuv</code> 来实现。<code>libuv</code> 让 Node.js 有了 non-blocking I/O 特性。</p><blockquote><p>For example, in Unix, regular filesystem files do not support non-blocking operations, so, in order to simulate a non-blocking behavior, it is necessary to use a separate thread outside the Event Loop. All these inconsistencies across and within the different operating systems required a higher-level abstraction to be built for the Event Demultiplexer. This is exactly why the Node.js core team created a C library called libuv, with the objective to make Node.js compatible with all the major platforms and normalize the non-blocking behavior of the different types of resource; libuv today represents the low-level I/O engine of Node.js.</p><p>– p17 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>This may sound strange if we consider that Node.js is single threaded, but if we remember what we discussed in Chapter 1, Node.js Design Fundamentals, we realize that even though we have just one thread, we can still achieve concurrency, thanks to the nonblocking nature of Node.js.</p><p>–p71 <em>Node.js Design Patterns</em></p></blockquote><blockquote><p>每个我们常见的操作系统都为我们封装了类似的高并发异步模型，那libuv其实就是对各个操作系统进行封装，最后暴露出统一的api供开发者调用，开发者不需要关系底层是什么操作系统，什么API了。 </p><p>–<a href="https://zhuanlan.zhihu.com/p/50480439" target="_blank" rel="noopener">libuv — 知乎专栏</a></p></blockquote><p>这里单线程模拟多线程的原理，和计算机中实现的 concurrency 差不多。因为在计算机中，如果从单个时钟来看，计算机只能完成一条命令。而借助诸如 time shared 分时系统等等，在一段时间内可以认为计算机同时「并发」地在进行多个任务。因此，在 Node.js 由于有了 <code>libuv</code>，会让有着 callback 的函数会进行「异步」操作。</p><blockquote><p>So why show you this? Because you can’t just call one function after another and hope they execute in the right order. Callbacks are a way to make sure certain code doesn’t execute until other code has already finished execution.</p><p>–<a href="https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced" target="_blank" rel="noopener">JavaScript: What the heck is a Callback?</a></p></blockquote><p>关于 callback 的使用，是有一些 conventions 的。比如 callback 的第一个参数是 error。callback 本身作为函数参数，通常放在最后一个。</p><blockquote><p>Nearly everything in node.js is asynchronous. So, nearly every method that is called, you must specify a callback method to handle the result of the method call. Normally, the callback function takes two parameters: error, result. So it is up to you to check for the error and then handle the result. </p><p>– <a href="https://stackoverflow.com/questions/13789095/understanding-node-js-callback-structure" target="_blank" rel="noopener">understanding node.js callback structure</a></p></blockquote><h2 id="Web-Spider-的-callback-实现"><a href="#Web-Spider-的-callback-实现" class="headerlink" title="Web Spider 的 callback 实现"></a>Web Spider 的 callback 实现</h2><p>在 <em>Node.js Design Patterns</em> 这本书的第二章节，作者通过 web spider 这个例子，介绍了 async 在 node 里的各种实现方案。有最原生的 callback hell，改良后的 callback，也有 async，Promise，generator 等等更加简单的写法。无论使用哪种方式，会用到 <code>fs.stat(path, callback)</code> 和 <code>request(url, callback)</code>[^1]。前者是 Node.js 自身的关于文件操作的一系列 api，后者是一个第三方 module。因为这两个函数都用到了 callback，所以在 debug 模式下，就去更深一层看看是如何运作的。Web Spider 的函数源码已附在了参考链接里。</p><pre><code class="javascript">function download(url, filename, callback) {  console.log(`Downloading ${url}`);  request(url, (err, response, body) =&gt; {    if(err) {      return callback(err);    }    saveFile(filename, body, err =&gt; {      if(err) {        return callback(err);      }      console.log(`Downloaded and saved: ${url}`);      callback(null, body);    });  });}function spider(url, callback) {  const filename = utilities.urlToFilename(url);  fs.stat(filename, err =&gt; {    if(!err) {      return callback(null, filename, false);    }    download(url, filename, err =&gt; {      if(err) {        return callback(err);      }      callback(null, filename, true);    })  });}</code></pre><h3 id="fs-stat"><a href="#fs-stat" class="headerlink" title="fs.stat()"></a>fs.stat()</h3><p>首先进入 <code>fs.stat()</code> 函数：</p><pre><code class="javascript">function stat(path, options, callback) {  if (typeof options === &#39;function&#39;) {    callback = options;    options = {};  }  callback = makeStatsCallback(callback);  path = toPathIfFileURL(path);  validatePath(path);  const req = new FSReqCallback(options.bigint);  req.oncomplete = callback;  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);}</code></pre><p>line 2 到 line 5 是参数判断和转换。line 6 <code>makeStatsCallback(callback)</code>，调用：</p><pre><code class="Javascript">// Special case of `makeCallback()` that is specific to async `*stat()` calls as// an optimization, since the data passed back to the callback needs to be// transformed anyway.function makeStatsCallback(cb) {  if (typeof cb !== &#39;function&#39;) {    throw new ERR_INVALID_CALLBACK();  }  return (err, stats) =&gt; {    if (err) return cb(err);    cb(err, getStatsFromBinding(stats));  };}</code></pre><p>按照注释说明，是 <code>makeCallback()</code> 的特殊情况，那我们就去看看 <code>makeCallback()</code> 是什么。</p><pre><code class="javascript">// Ensure that callbacks run in the global context. Only use this function// for callbacks that are passed to the binding layer, callbacks that are// invoked from JS already run in the proper scope.function makeCallback(cb) {  if (typeof cb !== &#39;function&#39;) {    throw new ERR_INVALID_CALLBACK();  }  return (...args) =&gt; {    return Reflect.apply(cb, undefined, args);  };}</code></pre><p>这段 code  的关键是 <code>Reflect.apply(cb, undefined, args);</code>。按照 MDN 的叙述，<code>Reflect</code> 是：</p><blockquote><p><strong>Reflect</strong> is a built-in object that provides methods for interceptable JavaScript operations. The methods are the same as those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler" target="_blank" rel="noopener">proxy handlers</a>. <code>Reflect</code> is not a function object, so it’s not constructible.</p><p>Unlike most global objects, <code>Reflect</code> is not a constructor. You cannot use it with a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code>operator</a> or invoke the <code>Reflect</code> object as a function. All properties and methods of <code>Reflect</code>are static (just like the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener"><code>Math</code></a> object).</p></blockquote><p>Reflect 是一个 global object。那么当调用 <code>Reflect.apply()</code>，就是在 global context 下进行的。为什么需要 global context 呢？首先想什么时候会去调用 callback，往往是 error handling，出错的时候，或者是进行最后一步工作的时候。两种情况，无论是哪一种，程序都要从不管多深的 call stack 出来，回到地面，回到 global context，去 handle error，或是进行所有前提工作结束后的下一步工作。</p><p><code>makeStatsCallback(callback)</code>之后关键的三步是：</p><pre><code class="javascript">const req = new FSReqCallback(options.bigint);req.oncomplete = callback;binding.stat(pathModule.toNamespacedPath(path), </code></pre><p><code>FSReqCallback</code> 和 <code>binding</code> 都是对更底层的 C library 调用。</p><pre><code class="javascript">const binding = process.binding(&#39;fs&#39;);const { FSReqCallback, statValues } = binding;</code></pre><p>从这里开始，就逐渐进入 <code>libuv</code> ，C library 的领域了。在这些 C library 中做了什么事情，以我目前的知识结构就很难理解了。只是大体上，应该是设置异步操作，规定在函数结束后去执行 callback 等等，就如这句 <code>req.oncomplete = callback;</code> 字面含义所写的那样。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>request 是一个简单的 Http client。这是它们的 <a href="https://github.com/request/request" target="_blank" rel="noopener">Git repo</a>。web spider 的目标就是要下载目标 url 的内容。在上一小节，我们通过 <code>fs.stat()</code> 来检测文件是否存在。当检测到文件不存在的时候，则对目标 url 进行下载。下载这个动作，展开来讲，首要工作就是创建一个 http clinet，来向 server 发送请求，然后接收来自 server 返回的数据。即 <code>body</code> 内容。这些操作，都是通过 <code>request</code> 这个 module 来实现的。创建的 http client 就可类比浏览器，当它发送 request 请求时，需要按照 TCP/IP 协议，加入 head，设置 tunnel，redirect 等等内容。这些是通过 <code>request.Request(params)</code> 来实现的。</p><pre><code class="javascript">function request (uri, options, callback) {  if (typeof uri === &#39;undefined&#39;) {    throw new Error(&#39;undefined is not a valid uri or options object.&#39;)  }  var params = initParams(uri, options, callback)  if (params.method === &#39;HEAD&#39; &amp;&amp; paramsHaveRequestBody(params)) {    throw new Error(&#39;HTTP HEAD requests MUST NOT include a request body.&#39;)  }  return new request.Request(params)}</code></pre><p>line 6 对参数进行初始化：</p><pre><code class="javascript">// organize params for patch, post, put, head, delfunction initParams (uri, options, callback) {  if (typeof options === &#39;function&#39;) {    callback = options  }  var params = {}  if (typeof options === &#39;object&#39;) {    extend(params, options, {uri: uri})  } else if (typeof uri === &#39;string&#39;) {    extend(params, {uri: uri})  } else {    extend(params, uri)  }  params.callback = callback || params.callback  return params}</code></pre><p><code>request()</code> 函数返回的  <code>request.Request(params)</code>  如下：</p><pre><code class="javascript">function Request (options) {  // if given the method property in options, set property explicitMethod to true  // extend the Request instance with any non-reserved properties  // remove any reserved functions from the options object  // set Request instance to be readable and writable  // call init  var self = this  // start with HAR, then override with additional options  if (options.har) {    self._har = new Har(self)    options = self._har.options(options)  }  stream.Stream.call(self)  var reserved = Object.keys(Request.prototype)  var nonReserved = filterForNonReserved(reserved, options)  extend(self, nonReserved)  options = filterOutReservedFunctions(reserved, options)  self.readable = true  self.writable = true  if (options.method) {    self.explicitMethod = true  }  self._qs = new Querystring(self)  self._auth = new Auth(self)  self._oauth = new OAuth(self)  self._multipart = new Multipart(self)  self._redirect = new Redirect(self)  self._tunnel = new Tunnel(self)  self.init(options)}</code></pre><p>注意一下 line 17，<code>stream.Stream.call(self)</code>，在进入这个函数内部后，来到：</p><pre><code class="javascript">// legacy.jsconst EE = require(&#39;events&#39;);const util = require(&#39;util&#39;);function Stream() {  EE.call(this);}</code></pre><p>因为 EE 是来自 events 导出的 EventEmitter，<code>EE.call(this)</code> 实际上是对 EventEmitter 的初始化。到这里会发现，request 处理 callback 所使用的方式，是和 EventEmitter 相关的。具体的继承关系是：</p><p><code>EventEmitter</code> &lt;- <code>stream.Stream</code> &lt;- <code>Request</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章最初是想弄清楚 <code>fs</code> 和 <code>request</code> 是怎么处理 callback 函数，是如何去调用的，一路 debug 下去，终归绕不开 <code>libuv</code> ，计算机底层关于 thread 的内容以及网络方面的 TCP/IP 协议。这两方面都是我的知识弱项，因此也就在合适的地方浅尝辄止了。当然，写这篇文章也让我对于 callback 有了更深的理解之外，同时，我想必要抽时间再去好好读读 CSAPP 和 TCP/IP 那两本书了。</p><p>[^1]: 原文判断文件存在用的是 <code>fs.exists()</code>，但这个函数，在我查阅 Node.js Documentation 时发现已经 deprecated，所以稍微修改了一下。</p><hr><p>参考：</p><ul><li><a href="https://medium.com/javascript-in-plain-english/callbacks-in-node-js-how-why-when-ac293f0403ca" target="_blank" rel="noopener">Callbacks in Node.js: Why, When, How?</a></li><li><a href="https://stackoverflow.com/questions/24042861/nodejs-what-does-process-binding-mean" target="_blank" rel="noopener">Nodejs: What does <code>process.binding</code> mean?</a></li><li><a href="https://zhuanlan.zhihu.com/p/40977678" target="_blank" rel="noopener">深入出不来nodejs源码-从fs.stat看node架构</a></li><li><a href="https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code" target="_blank" rel="noopener">Node.js_Design Patterns Second Edition Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习 Node.js。主要看两本书：&lt;em&gt;Node.js in Practice&lt;/em&gt; 和 &lt;em&gt;Node.js Design Patterns&lt;/em&gt;。前者类似于 o’reilly 的 cookbook 系列，整本书的编排是通过一个个 recipe，一个个具体的 problem&amp;amp;solution 实现的。后者就是 &lt;a href=&quot;https://search.packtpub.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Packt Publishing&lt;/a&gt; 出品的一系列 Design Patterns 书籍。包括这两本书在内的许多讲解 Node.js 的书籍，都会不断强调两个关键词， asynchronous 和 non-blocking I/O。在最初开始学习编程的时候，无论是写一些算法题目，或是做一些本地测试，它都是同步的，即时响应的，单线程的，blocking I/O。但如果进入的网络领域，「异步」则会被不断提起。相比 synchronous，「异步」更加接近我们相处的真实世界。&lt;/p&gt;
&lt;p&gt;这篇文章以 &lt;em&gt;Node.js Design Patterns&lt;/em&gt; 第二章的 Web Spider 例子，探究思考在 Node.js 中是如何通过 callback 来实现异步操作的。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="http://reyshawn.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Theme 开发不完全记录</title>
    <link href="http://reyshawn.com/2019/01/20/Hexo%20Theme%20%E5%BC%80%E5%8F%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://reyshawn.com/2019/01/20/Hexo Theme 开发不完全记录/</id>
    <published>2019-01-20T00:22:36.357Z</published>
    <updated>2019-01-22T14:28:53.628Z</updated>
    
    <content type="html"><![CDATA[<p>决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 <a href="https://github.com/getpelican/pelican" target="_blank" rel="noopener">Pelican</a> 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：</p><blockquote><p>两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。</p></blockquote><p>那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。</p><p>目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">Themes | Hexo</a> 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。</p><a id="more"></a><h2 id="template-engine-的比较，swig，ejs-or-pug"><a href="#template-engine-的比较，swig，ejs-or-pug" class="headerlink" title="template engine 的比较，swig，ejs or pug"></a>template engine 的比较，swig，ejs or pug</h2><p>Hexo 本身是基于 Nodejs ，它首先通过模版的 render engine，渲染 markdown 和写好的 template 文件，生成相应的 html 。这些生成的 html 文件存储在 <code>public</code> 文件夹中。再通过 git 将这个文件夹的内容发布到 github 上。整个 Hexo 大体的工作逻辑是这样的。工作的第一步是选择合适的 template engine。</p><p>目前可用的 template engine 有多种选择，在 <a href="https://js.libhunt.com/categories/13-templating-engines" target="_blank" rel="noopener">Awesome JS</a> 上会给出各个 template engine 的比较。我最终选择使用 ejs。因为， ejs 本身学习成本很低。ejs 全称 Embedded JavaScript Template，类似于 jsx，直接就是在 html 里写 js 代码就行了。而 Next 主题是用 swig 写的，不选择 swig 的一个很重要原因是它不再维护了，最后一次 commit 是两年前。pug 也是个备受推崇的选择，它的前身是 jade，jade 的 logo 很漂亮，现在更名为 pug，icon 是一个哈巴狗，个人不是太喜欢。pug 的格式和 html 区别也很大，是类似 python 那种缩进形式，如果选择 pug 是需要一段时间去适应的。</p><p>ejs 常用 pattern：</p><ul><li><code>&lt;% %&gt;</code>: 不输出任何内容，用于嵌套 if 或 for 控制语句；</li><li><code>&lt;%- %&gt;</code>: 输出 raw html 文本；</li><li><code>&lt;%= %&gt;</code>:  输出文本，html 中的 tag 如 <code>&lt;div&gt;</code> 会 escape 成 <code>&amp;lt;div&amp;gt;</code></li></ul><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>这是我目前整个主题的文件结构。</p><pre><code class="shell">.├── _config.yml├── languages├── layout│   ├── _partials│   │   ├── footer.ejs│   │   ├── head.ejs│   │   ├── header.ejs│   │   ├── pagination.ejs│   │   └── sidebar.ejs│   ├── archive.ejs│   ├── category.ejs│   ├── index.ejs│   ├── layout.ejs│   ├── page.ejs│   ├── post.ejs│   └── tag.ejs├── scripts└── source    ├── css    │   ├── highlight.css    │   └── main.css    ├── images    │   ├── footer.png    │   └── logo.png    └── js        ├── highlight.min.js        ├── highlightjs-line-numbers.js        ├── jquery-3.3.1.min.js        └── main.js</code></pre><p><code>layout</code> 里存放的是 <code>ejs</code> 模版文件。<code>source</code> 里分了三个文件夹，分别存放用到的 css，图片和 js 文件。<code>languages</code> 和 <code>scripts</code> 这两个文件夹没有用到。</p><p>在 ejs 里使用 source 中的文件：</p><pre><code class="ejs">&lt;%- js(&#39;js/main.js&#39;) %&gt;&lt;%- css(&#39;css/main.css&#39;) %&gt;&lt;img class=&quot;typology-logo&quot; src=&quot;/images/logo.png&quot; alt=&quot;hagoromo&quot; style=&quot;width: 125px;&quot;&gt;</code></pre><p>因为 source 的里文件会原封不动的 copy 进 <code>public</code> 文件夹一份。所以可以直接以上述的形式进行引用。</p><h2 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h2><p>最简单办法是直接 copy 了一份我个人 blog 文件夹到 Desktop 上。把主题文件夹移到 themes 文件夹中。使用 <code>hexo s</code> 进行本地测试。</p><p>我最开始还想着，因为需要 render  ejs 文件，还去看了 nodejs 和 koa 等等内容。后来发现那样做会走不少弯路。最好的测试环境，就是拿真实的环境去模拟，可能会出现的种种状况。</p><h2 id="traps-不完全统计"><a href="#traps-不完全统计" class="headerlink" title="traps 不完全统计"></a>traps 不完全统计</h2><h3 id="archive-页面构建"><a href="#archive-页面构建" class="headerlink" title="archive 页面构建"></a>archive 页面构建</h3><p>我最开始构建 archive 页面时，没太弄明白如何使用插件 hexo-genrator-archive 。所以当时选择新建了一个 page，再在 page 里引入 <code>partial(archive)</code>。loop 所有 posts 时使用 global variable <code>site.posts</code>。这样写，一个最大的问题是，最后 archive 页面展示的 post 顺序，不是按照时间顺序来显示的。我也试了很多办法，设法对 <code>site.posts</code> 排序，但都一一告北。直到搞清楚了 hexo-genrator-archive plugin 的逻辑。</p><p>实际上，安装了 hexo-generator-archive plugin 后，在 hexo 的配置文件本身就有里：</p><pre><code class="yaml">archive_dir: archives</code></pre><p>这样在执行完 <code>hexo g</code> 时候，会自动在 <code>public</code> 文件夹下生成一个 <code>archives</code> 文件，这个文件夹里的内容是和 template 文件 <code>archive.ejs</code> 文件相关联的。也就是，这个插件已经做了所有的「router」路由工作。所以在 template 想要创建一个 archive 点击链接，只需要即可。</p><pre><code class="ejs">&lt;a href=&quot;/archives&quot;&gt;Archive&lt;/a&gt;</code></pre><p>接下来整个 archive 的页面，就是在  <code>archive.ejs</code>  中进行的。在 archive 页面里，采用变量 <code>page.posts</code>，输出的 posts 刚好是按照时间顺序从近到远排列。</p><h3 id="pagination-分页实现"><a href="#pagination-分页实现" class="headerlink" title="pagination 分页实现"></a>pagination 分页实现</h3><p>使用 pagination 分页功能，需要现在 config 里配置：</p><pre><code class="yaml">per_page: 10pagination_dir: page</code></pre><p>此外，hexo 还很贴心地提供了有关 pagination 分页的相关 API。大体的实现是就变的很简单。</p><pre><code class="ejs">&lt;% if (page.total &gt; 1){ %&gt;&lt;div class=&quot;hagoromo-pagination&quot;&gt;    &lt;nav class=&quot;navigation pagination&quot; role=&quot;navigation&quot;&gt;        &lt;% let prev_text = &quot;&amp;laquo; &quot; + __(&#39;prev&#39;); %&gt;        &lt;% let next_text = __(&#39;next&#39;) + &quot; &amp;raquo;&quot;; %&gt;        &lt;%- paginator({          prev_text: prev_text,          next_text: next_text        }) %&gt;    &lt;/nav&gt;&lt;/div&gt;&lt;% } %&gt;</code></pre><p>如果自己去实现的话，还是很复杂的，要考虑当前第几页，最后一页和第一页。当前页和第一页，最后一页差值等等。使用 hexo 提供的 <code>paginator()</code> 函数，就直接自动生成了整个分页 module。这之后 css 样式，按照生成的 html tag 上给的 class 来写就行了。</p><h3 id="banner-下拉动画"><a href="#banner-下拉动画" class="headerlink" title="banner 下拉动画"></a>banner 下拉动画</h3><p>我希望实现的 banner 下拉动画效果是，在窗口下拉大概 600 pixel 时，也就是 scrollY&gt;600 时，banner 从顶部出现并固定，当 scrollY&lt;600 时，banner 隐去。</p><p>大体思路是给 <code>window</code> bind 一个 scroll 事件，实时 listen 窗口的 scrollY 位置。对于动画的实现，有多种方式，可以用 css，也可以用 js。我这里使用了 jQuery 的 <code>animate()</code> 函数，相比 css，控制起来更加灵活方便。</p><pre><code class="javascript">$(window).on(&#39;scroll&#39;, function() {    let scrollPosition = $(this).scrollTop();    let $header = $(&#39;.hagoromo-header&#39;);            if ($(window).width() &gt; 800) {        if (scrollPosition &lt; 200) {            $header.finish();            $header.css({                &#39;top&#39;: &#39;0&#39;,            });        }        if (scrollPosition &gt; 600 &amp;&amp; !$header.hasClass(&#39;hagoromo-header-sticky&#39;)) {            $header.addClass(&#39;hagoromo-header-sticky&#39;);            $header.css({                &#39;top&#39;: &#39;-70px&#39;,            });            $header.animate({                top: &quot;0&quot;            },160)        }        if (scrollPosition &lt; 550 &amp;&amp; $header.hasClass(&#39;hagoromo-header-sticky&#39;)) {            $header.animate({                top: &quot;-70px&quot;            },160, function() {                $header.removeClass(&#39;hagoromo-header-sticky&#39;);                $header.finish();                $header.css(&#39;top&#39;, &#39;0&#39;);            })        }    } else {        if (scrollPosition &gt; 55) {            $header.addClass(&#39;hagoromo-header-hidden&#39;)        } else {            $header.removeClass(&#39;hagoromo-header-hidden&#39;)        }    }});</code></pre><p>其中出现的问题是，因为只要有 animation，都要涉及时间的问题，涉及时间的问题就可以看作一次 asynchronous 调用，这样相比平时 synchronous 调用，速度的快慢，时间的长短，总会带来额外的问题。我当时遇到的问题时，如果过快的从下到上滑到顶部，会出现循环动画，即 banner 不停的上下抖动。问题的原因也很浅显，就是在上一个动画还没结束时，有触发了新一轮的动画，一不小心进入 infinite loop。最后为了解决它，找到了 <code>finish()</code> ，强制结束之前动画。这样一来整体的效果就好多了。</p><h3 id="coding-highlight-和-line-number-显示"><a href="#coding-highlight-和-line-number-显示" class="headerlink" title="coding highlight 和 line number 显示"></a>coding highlight 和 line number 显示</h3><p>hexo 自带了代码高亮。可能是因为我没有定义相关的 css ，实际渲染后，code block 有行号，但是没有高亮。而且 code block 渲染后的 html 后是 <code>&lt;figure&gt;&lt;table&gt;</code> 这样形式。参考网上意见后，通常的解决方案是采取 <code>highlight.js</code>。使用之前先把 hexo 内置的 highlight 关闭，这样 code block 渲染回到了传统 <code>&lt;pre&gt;&lt;code&gt;</code> 形式。引入 <code>highlight.js</code>  提供的 js，css 文件后，初始化后就能看到高亮的代码。这个要注意：</p><pre><code class="javascript">hljs.initHighlightingOnLoad();</code></pre><p>这个函数是要写在自己 js 文件的 <code>$(document).ready()</code> <strong>外面</strong>。因为函数本身已经包含 onload 了。</p><p> <code>highlight.js</code> 自身是没有 line number 显示的。这里需要另外一个扩展 <a href="https://github.com/wcoder/highlightjs-line-numbers.js/" target="_blank" rel="noopener">highlightjs-line-numbers.js</a>, 使用方法同  <code>highlight.js</code> 。初始化的时候同样要写在  <code>$(document).ready()</code> <strong>外面</strong>。</p><h3 id="搜索功能的替代性实现"><a href="#搜索功能的替代性实现" class="headerlink" title="搜索功能的替代性实现"></a>搜索功能的替代性实现</h3><p>搜索，平时不经意就会用到功能，凭我个人却写一个 search engine，工作量时很大的。这里有几种方案。</p><p>第一种是调用 algolia 接口，hexo 本身提供了 hexo-algolia 插件。这样实现后的形式是，点击搜索后，页面会出现一个类似 macOS 中 spotlight 那样的输入弹窗，输入要搜索的内容，便会实时给出结果。</p><p>第二种暂时只是我个人想法。就是借助 Google 的 <a href="https://developers.google.com/custom-search/v1/overview" target="_blank" rel="noopener">Custom Search JSON API</a>。但这个需要新建一个 search page 页面来展示 search 结果。需要 js 通过 ajax 得到返回的 json，实时渲染到 search 页面上。</p><p>第三种，也就是我现在使用的比较简单的办法。记得 <a href="www.v2ex.com">V2EX</a> 也是这么实现的。利用 Google 搜索中的 <code>site:</code> 语句。点击 <code>SEARCH</code> 后是直接打开 Google，展示 Google 的站内搜索结果。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文章主要写了自己开发过程中碰到的几个棘手的难题。另外还有一大部分关于设计的内容没有涉及。包括字体，颜色，layout，z-index，footer，responsive design 等等。虽然大部分的设计使用了 typology 的 css 文件，但弄懂其中的逻辑结构，写出更优雅的 css ，还需要一番努力和功夫。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="配置-favicon"><a href="#配置-favicon" class="headerlink" title="配置 favicon"></a>配置 favicon</h3><p>需要将自己准备好 icon 文件，通常是 .ico 格式的文件，存储在 <code>source</code> 文件夹下。在 <code>head.ejs</code> 中加入一条 <code>&lt;link&gt;</code> 来声明 favicon 地址：</p><pre><code class="ejs">&lt;% if (theme.favicon){ %&gt;    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%- theme.favicon %&gt;&quot;&gt;&lt;% } %&gt;</code></pre><p>这里使用 if 结构是为了方便在 <code>config.yaml</code> 中进行配置。</p><p>在 theme 的配置文件 <code>config.yaml</code> 中添加，</p><pre><code class="yaml">favicon: ./favicon.ico</code></pre><p>即可。</p><p>测试的话，local 本地测试是没有看到 icon。但 deploy 之后，把网页加入收藏，在 iOS 端的 Safari 等待片刻就能看到 icon，在桌面端的 Chrome 也可以。但唯独桌面端的 Safari 不显示。在 <code>/Users/reyshawn/Library/Safari/Touch\ Icons\ Cache</code> 这个文件夹下能看到，Safari 需要的 icon 都是 png 格式图片，大小通常是 180*180，参考了以下其他能正常显示 icon 的网站，它们 head 的写法。所以要在 <code>&lt;head&gt;</code> 中加入下面两个 <code>&lt;link&gt;</code>:</p><pre><code class="html">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;./favicon.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;./favicon180x180.png&quot; sizes=&quot;180x180&quot;&gt;</code></pre><p>同时要把 png 的icon 移动到 <code>source</code> 文件夹下。这样在桌面端的 Safari 也能正常显示 favicon 了。不得不讲，苹果对于 icon 分辨率的控制之严苛，也侧面反映对设计，整体 icon 一致性的重视。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/25952907/favicon-ico-vs-link-rel-shortcut-icon" target="_blank" rel="noopener">What is the best practice for creating a favicon on a web site?</a></li><li><a href="https://stackoverflow.com/questions/2997437/what-size-should-apple-touch-icon-png-be-for-ipad-and-iphone" target="_blank" rel="noopener">What size should apple-touch-icon.png be for iPad and iPhone?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决定建立一个静态 Blog，已经是 2016 年的事了。在那之前，也就是在 2016 年 4 月 5 日，自己曾经使用 &lt;a href=&quot;https://github.com/getpelican/pelican&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pelican&lt;/a&gt; 进行过短暂的尝试。生活在互联网时代，当你决定将一切电子化，义无反顾地投入比特的世界时，最大的好处便是，这以后发生的每一起事件，都有着清楚的记录。建立 Blog 这件事也不例外。但仅过 1 天，我就删除了 github 上的 repo。当时的自己这样写道：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两天的尝试发现：没有足够的知识积累，挑战就是「摸着石头过河」，到处都是困难，耐心被一点一点消磨，直到像一只无头苍蝇乱撞，而无法再耐心地解决问题。所以，博客平台搭建计划暂停。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那时自己才刚开始学 Python，也才刚开始接触 Github。其他方面更是经验甚少，处处碰壁。一年以后， 2017 年 3 月，自己使用 Hexo 建立了这个 Blog，并在 Godaddy 上购买了域名，采用 Hexo 预置主题 Next 。全面，简洁，美观大方。这个主题足够好用。当时的主题并不多，所以经常看到其他使用 Hexo 搭建的 Blog ，往往都是差不多的样式，我当时也只是改了以下 banner，才显得稍有不同。这也让我想试着自己去写一个主题。&lt;/p&gt;
&lt;p&gt;目前看到的这个 theme 所有样式，并非我本人设计。它来自于一款付费的 WordPress theme typology。我是一次偶然的机会看到它。考虑到可能的版权问题。自己可能不会把它发布到 &lt;a href=&quot;https://hexo.io/themes/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Themes | Hexo&lt;/a&gt; 或开源到 Github 上（无法联系到这个 theme 的作者）。以下我所做的大部分工作，不过是以 Hexo 的形式对 typology 的再现。为了方便。我把这个模仿之作命名为 hagoromo（羽衣）。至于为什么会叫这个名字，Google 会给你答案。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
      <category term="Front-end" scheme="http://reyshawn.com/tags/Front-end/"/>
    
  </entry>
  
  <entry>
    <title>1/n- Cycle | 6kyu</title>
    <link href="http://reyshawn.com/2018/07/10/1n-%20Cycle%20%7C%206kyu/"/>
    <id>http://reyshawn.com/2018/07/10/1n- Cycle | 6kyu/</id>
    <published>2018-07-10T14:58:13.061Z</published>
    <updated>2019-01-23T01:31:08.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Let be <code>n</code> an integer prime with <code>10</code> e.g. <code>7</code>. </p><p><code>1/7 = 0.142857 142857 142857 ...</code>.</p><p>We see that the decimal part has a cycle: <code>142857</code>. The length of this cycle is <code>6</code>. In the same way:</p><p><code>1/11 = 0.09 09 09 ...</code>. Cycle length is <code>2</code>.</p><p><strong>Task</strong></p><p>Given an integer n (n &gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.</p><p><strong>Exemples:</strong></p><pre><code class="python">cycle(5) = -1cycle(13) = 6 -&gt; 0.076923 076923 0769cycle(21) = 6 -&gt; 0.047619 047619 0476cycle(27) = 3 -&gt; 0.037 037 037 037 0370cycle(33) = 2 -&gt; 0.03 03 03 03 03 03 03 03cycle(37) = 3 -&gt; 0.027 027 027 027 027 0cycle(94) = -1 cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...</code></pre><p>Note</p><ul><li>Translators are welcome for all languages.</li></ul><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">import mathimport fractionsdef cycle(n) :    if n==2 or n==5 :        return -1    t = phi(n)    p = primes(t)    divisor = []    for i in p:        x = i        while t % i == 0:            divisor.append(i)            t //= i        if isprime(t):            divisor.append(t)            break    divisor.sort()    print(divisor)    for i in divisor:        if 10**i % n == 1:            break    return idef phi(n):    &#39;&#39;&#39;compute Euler&#39;s totient function values.&#39;&#39;&#39;    amount = 0    for k in range(1, n + 1):        if math.gcd(n, k) == 1:            amount += 1    return amountdef isprime(n):    &quot;&quot;&quot;Returns True if n is prime.&quot;&quot;&quot;    if n == 2:        return True    if n == 3:        return True    if n % 2 == 0:        return False    if n % 3 == 0:        return False    i = 5    w = 2    while i * i &lt;= n:        if n % i == 0:            return False        i += w        w = 6 - w    return Truedef primes(limit):    D = {}    q = 2    while q &lt;= limit:        if q not in D:            yield q            D[q * q] = [q]        else:            for p in D[q]:                D.setdefault(p + q, []).append(p)            del D[q]        q += 1print(cycle(219199))</code></pre><p>这道题是求 $1/n$ 的循环小数位数的。通过观察其实可以得到如下的性质，假设 $1/n$ 的循环小数位数有 $p$ 位，则有：</p><pre><code class="python">10**p % n == 1</code></pre><p>其实也很好理解，就是 10 扩大 $p$ 倍，小数点向右移动 $p$ 位，整数部分恰好位一个循环数，小数部分则等于 $1/n$ 。</p><p>但是如果按照这个思路来进行求解，写一个循环，对一个稍微大一点的数，如上面的 <code>219199</code>，它的循环位数是 <code>36180</code>。暴力写循环根本就行不通！</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/lechevalier" target="_blank" rel="noopener">lechevalier</a></p><pre><code class="python">def cycle(n):    if not n % 2 or not n % 5:        return -1    x, mods = 1, set()    while x not in mods:        mods.add(x)        x = 10 * x % n    return len(mods)</code></pre><p>lechevalier 所用的这个方法的思路，正是我上面说的，只是并非暴力循环，而是不断迭代。我的疑问是，为何一定能保证，<code>mods</code> 长度刚好是循环的位数？</p><p>方法类似这里给出的答案：<a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits" target="_blank" rel="noopener">How to Calculate Recurring Digits?</a></p><blockquote><p>You can calculate the decimal representation of <code>a / b</code> using the long-division algorithm you learned at school, as Mark Ransom said. To calculate each successive digit, divide the current dividend (numerator or remainder) by <code>b</code>, and find the next dividend as the remainder multiplied by 10 (“bringing down a 0”). When a remainder is the same as some previous remainder, it means that the digits from then on will repeat as well, so you can note this fact and stop.</p></blockquote><p>明白了。其实整个迭代的过程就是去做一次 long division。long division 就是我们小学学过的那种除法计算。</p><p>![long division](/images/long division.png)</p><p>那么为什么这样一种循环就比之前我想的那种暴力破解快呢？答案就在于迭代。每次只用 remainder 乘 10 进行迭代，一个非常小的数，算起来自然比用 $10^{n}$ 直接去除要快得多。 </p><p>参考文章：</p><ul><li><a href="https://math.stackexchange.com/questions/1122203/calculating-eulers-totient-function-values" target="_blank" rel="noopener">Calculating Euler’s totient function values.</a></li><li><a href="https://stackoverflow.com/questions/249372/how-to-calculate-recurring-digits" target="_blank" rel="noopener">How to Calculate Recurring Digits?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Let be &lt;code&gt;n&lt;/code&gt; an integer prime with &lt;code&gt;10&lt;/code&gt; e.g. &lt;code&gt;7&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/7 = 0.142857 142857 142857 ...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We see that the decimal part has a cycle: &lt;code&gt;142857&lt;/code&gt;. The length of this cycle is &lt;code&gt;6&lt;/code&gt;. In the same way:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/11 = 0.09 09 09 ...&lt;/code&gt;. Cycle length is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Given an integer n (n &amp;gt; 1), the function cycle(n) returns the length of the cycle if n and 10 are coprimes, otherwise returns -1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exemples:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;cycle(5) = -1
cycle(13) = 6 -&amp;gt; 0.076923 076923 0769
cycle(21) = 6 -&amp;gt; 0.047619 047619 0476
cycle(27) = 3 -&amp;gt; 0.037 037 037 037 0370
cycle(33) = 2 -&amp;gt; 0.03 03 03 03 03 03 03 03
cycle(37) = 3 -&amp;gt; 0.027 027 027 027 027 0
cycle(94) = -1 

cycle(22) = -1 since 1/22 ~ 0.0 45 45 45 45 ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Translators are welcome for all languages.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="http://reyshawn.com/tags/Algorithm/"/>
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="Python" scheme="http://reyshawn.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Lowest base system | 4kyu</title>
    <link href="http://reyshawn.com/2018/06/29/Lowest%20base%20system%20%7C%204kyu/"/>
    <id>http://reyshawn.com/2018/06/29/Lowest base system | 4kyu/</id>
    <published>2018-06-29T01:58:30.647Z</published>
    <updated>2019-01-22T15:16:13.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>除法，求余，因子</li><li><code>Number.MAX_SAFE_INTEGER</code></li><li>二分法求方程根</li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Your task is determine lowest number base system in which the input <code>n</code> (base 10), expressed in this number base system, is all <code>1</code> in its digit. See an example:</p><p>‘7’ in base 2 is ‘111’ - fits! answer is 2</p><p>‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4</p><p><code>n</code> is always less than <code>Number.MAX_SAFE_INTEGER</code>.</p><p>这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="javascript">function getMinBase (number) {    if (number == 3) return 2;    var divisor = number -1    for (let i = 2; i != divisor; i++) {        var k = number - 1;        if (i &gt; 5999) break;        while (!(k % i)) {            divisor = k / i            k = divisor - 1;            if (k == 0) return i;        }    }    var _root = [2,3,4,5]    var k = 11    for (let i=0; i&lt;_root.length; i++){        var possible = parseInt(Math.pow(number, 1/_root[i]))        var k = 10 * k + 1        if (toTenBase(k,possible) == number) return possible    }    return number -1;}function toTenBase (number, base) {    n = number + &#39;&#39;;    n = n.split(&#39;&#39;).map(a =&gt; parseInt(a));    res = 0    for (var i = n.length -1; i &gt; -1; i--) {        res += Math.pow(base,i) * n[i]    }    return res;}</code></pre><p>我的这个方法，似乎有些根据测试的数据，有些取巧。代码分成两部分，第一步是通常意义的查找，<code>i</code> 从 2 开始，依此类加，找到每次减 1 都能被整除的最小 <code>i</code> 值。这里面为了优化用了一些技巧，比如最开始一部其实是要找 <code>number - 1</code> 的所有因子，但注意，因为一个数的所有因子都是对称的。譬如 12 的因子：1，2，3，4，6，12。从 3 开始往后的每一个数，在之前的相除过程中都得到了。比如和 2 相除得到 6，和 3 相除得到 4。</p><p>所以我在代码的第一部分加入了变量 <code>divisor</code>，并把它加入了跳出循环的条件。因为一旦 <code>i</code> 超过了 <code>number - 1</code>  的一半，那么就不可能存在除了 <code>number -1</code> 之外的数，使得以之为 base 能得到 <code>111...</code>。</p><p>但因为每次 <code>i</code> 都是类加 1，经过多次反复实验，<code>i</code> 超过 5000 之后，再计算速度已经很慢了。于是我写了另一个函数 <code>toTenBase()</code> ，给出任意 number 和 base，计算以 10 base 的数。最开始写这个函数，不过是为了去找一些规律。对于测试中出现的那些很大的数，大部分的结果都是 <code>number - 1</code>，然而在特殊测试部分，类似这样的 <code>Test.assertEquals(getMinBase(2500050001), 50000);</code> 数就很难办。</p><p>后来也是借助函数 <code>toTenBase()</code> 才发现，特殊测试中的数字，化成 <code>111…</code> 形式的话，大多都是 <code>111</code>，<code>1111</code> 和 <code>11111</code>，再大的话就没有了。如果我们设 <code>getMinBase()</code> 函数所得值为 $x$，而对应 number 为 $n$，对于 <code>111</code> 的类型，则变成一个二次方程求解：</p><p>$$x^2 +x+1=n$$</p><p>相应的 <code>1111</code> 类型，则是三次方程求解：</p><p>$$x^3+x^2 +x+1=n$$</p><p>对于 <code>11111</code> ，按照上述形式也可写出四次方程来。那么问题就是，针对这样的方程，该如何解呢？那么我们就要意识到，$n$ 此时已经很大了，相应 $x$ 也很大。所以它可以转化成一个球极限的问题，即：</p><p>$\lim\limits_{x \to \infty }x^3+x^2 +x+1=\lim\limits_{n \to \infty }n$<br>$\lim\limits_{x \to \infty }x^3=\lim\limits_{n \to \infty }n$</p><p>因此对于第一个方程，n 直接开方，对于第二个方程，n 直接开三次方。理论终究只是理论，实际检验一下，发现可以，于是就是有代码的第二部分。</p><h2 id="Other-Solutions"><a href="#Other-Solutions" class="headerlink" title="Other Solutions"></a>Other Solutions</h2><p> <a href="https://www.codewars.com/users/Voile" target="_blank" rel="noopener">Voile</a></p><pre><code class="javascript">function getMinBase(n) {  for(let i=Math.ceil(Math.log2(n)); i&gt;1; i--) {    let root=Math.round(findRoot(n,i));    if([...&#39;1&#39;.repeat(i)].reduce((s,_)=&gt;s*root+1,0)===n) return root;  }}function findRoot(n,i) {  var l=1, r=Number.MAX_SAFE_INTEGER;  while((r-l)/l&gt;1e-12) {    let m=(r+l)/2, g=(Math.pow(m,i)-1)/(m-1);    g&lt;n?l=m:r=m;  }  return (r+l)/2;}</code></pre><p><code>Number.MAX_SAFE_INTEGER</code> 是我们可以在 JavaScript 中进行 <strong>准确计算</strong>的最大数字，比之更大的数依然存在，但如果参与计算就会误差很大。</p><blockquote><p>The <strong>Number.MAX_SAFE_INTEGER</strong> constant represents the maximum safe integer in JavaScript (<code>253 - 1</code>).</p><p>The reasoning behind that number is that JavaScript uses <a href="http://www.wikiwand.com/en/Double_precision_floating-point_format" target="_blank" rel="noopener">double-precision floating-point format numbers</a> as specified in <a href="http://www.wikiwand.com/en/IEEE_floating_point" target="_blank" rel="noopener">IEEE 754</a> and can only safely represent numbers between <code>-(253 - 1)</code> and <code>253 - 1</code>.</p></blockquote><p> <code>findRoot(n,i)</code> 正是求我上面所说 $i-1$ 阶的一元方程。</p><pre><code class="javascript">&gt;x = findRoot(1000,4)9.641969245752986&gt;Math.pow(x,3) + Math.pow(x,2) + Math.pow(x,1) + 1999.9999999995179</code></pre><p>关键一步：<code>g=(Math.pow(m,i)-1)/(m-1)</code>，写成数学式是：</p><p>$g = \dfrac{m^i -1}{m-1} = m^{i-1}+m^{i-2} + … + m + 1$</p><p>求解的方程是：</p><p>$f(x) = x^{i-1}+x^{i-2} + … + x + 1 = n$</p><p>注意到 <code>r</code> 和 <code>l</code>，分别为计算的上界和下届。求  <code>r</code> 和 <code>l</code> 平均值，带入减 $n$，比较 0，大小，按结果分别再次带入到 <code>r</code> 和 <code>l</code>  中。标准的二分法求根的迭代过程，bisection method。</p><p>下面看一下函数的主体部分。主要是 for 循环中 <code>i</code> 的初始值：<code>i=Math.ceil(Math.log2(n))</code>。<code>i</code> 可能的 1 的最大位数，已知当 base 为 2 的时候，1 的位数是最多了，所以这里才会求 2 的对数。然后得到 i 值的上界，之后再依次减 1。</p><p><a href="https://www.codewars.com/users/spiderPan" target="_blank" rel="noopener">spiderPan</a></p><pre><code class="javascript">function getMinBase(number) {  for (var b =2; b&lt;= Math.floor(Math.sqrt(number)); b++) {    var num = number;    while (num % b == 1) {      num = Math.floor(num / b);      if (num == 1) {        return b;      }    }  }  return number - 1;}</code></pre><p> <a href="https://www.codewars.com/users/LesRamer" target="_blank" rel="noopener">LesRamer</a>, <a href="https://www.codewars.com/users/yurak" target="_blank" rel="noopener">yurak</a></p><pre><code class="javascript">function getMinBase(x) {  function test(b) {    var z = x;    while(z % b == 1)      z = (z - 1) / b;    return z == 0;  }  for(var n = Math.ceil(Math.log2(x)); n &gt;= 1; --n) {    var b = Math.floor(Math.pow(x,1/n));    if (test(b)) return b;    if (test(b-1)) return b-1;  }  return -1;}</code></pre><p>参考文章：</p><ul><li><a href="https://math.stackexchange.com/questions/900869/prove-xn-1-x-1xn-1xn-2-x1" target="_blank" rel="noopener">Prove $x^n−1=(x−1)(x^{n−1}+x^{n−2}+…+x+1)$</a></li><li><a href="http://www.wikiwand.com/zh/二分法_(數學)" target="_blank" rel="noopener">二分法 (數學)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;除法，求余，因子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;二分法求方程根&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Your task is determine lowest number base system in which the input &lt;code&gt;n&lt;/code&gt; (base 10), expressed in this number base system, is all &lt;code&gt;1&lt;/code&gt; in its digit. See an example:&lt;/p&gt;
&lt;p&gt;‘7’ in base 2 is ‘111’ - fits! answer is 2&lt;/p&gt;
&lt;p&gt;‘21’ in base 2 is ‘10101’ - contains ‘0’ does not fit ‘21’ in base 3 is ‘210’ - contains ‘0’ and ‘2’ does not fit ‘21’ in base 4 is ‘111’ - contains only ‘1’ it fits! answer is 4&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; is always less than &lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这个题目的难度主要在于性能 performance 方面，对于数值较小的数字，通常方法很容易计算，一旦涉及到九位十位往上的大数，一般的循环方法就会耗时很久。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="http://reyshawn.com/tags/Algorithm/"/>
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>@wraps | 6kyu</title>
    <link href="http://reyshawn.com/2018/06/25/@wraps%20%7C%206kyu/"/>
    <id>http://reyshawn.com/2018/06/25/@wraps | 6kyu/</id>
    <published>2018-06-25T02:21:13.613Z</published>
    <updated>2019-01-22T15:14:53.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li><code>decorator</code> 装饰器用法</li><li><code>try</code>…<code>except</code>… <code>else</code> control flow</li><li><code>getattr()</code> 和 <code>setattr()</code></li><li><code>__dict__.update()</code></li></ul><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :</p><pre><code class="python">def identity(func):  @wraps(func)  def wrapper(*args, **kwargs):    &quot;&quot;&quot;Wraps func&quot;&quot;&quot;    return func(*args, **kwargs)  return wrapper@identitydef return_one():  &quot;&quot;&quot;Return one&quot;&quot;&quot;  return 1return_one.__name__ == &#39;return_one&#39; # If wraps hadn&#39;t been used, __name__ would be equal to &#39;wrapper&#39;return_one.__doc__ == &#39;Return one&#39; # If wraps hadn&#39;t been used, __doc__ would be equal to &#39;Wraps func&#39;</code></pre><p><strong>Note: of course, you may not use the functools module for this kata.</strong></p><p>题目要求，经过一次二重的装饰器，保留原来函数的 <code>__name__</code> 和 <code>__doc__</code>。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 <code>__name__</code> 和 <code>__doc__</code>  得到保留，及为原函数的值。</p><p>依照题目给的例子，就是输出是被 decorator wraps 修饰过的 <code>wrapper</code> 函数，即函数主体和功能还是 <code>wrapper</code>，但因为被 <code>wraps</code> 装饰了，输出的 <code>wrapper</code> 函数的  <code>__name__</code> 和 <code>__doc__</code>  值为原函数 <code>return_one</code> 的值。</p><a id="more"></a><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><pre><code class="python">def wraps(func):    def first(wrapper):        return func    return first</code></pre><p>我的这个方法，其实是不正确的。因为我这个经过几次 decorate 又输出了原函数，按道理应该是输出 <code>wrapper</code> 函数的。</p><h2 id="Other-Solution"><a href="#Other-Solution" class="headerlink" title="Other Solution"></a>Other Solution</h2><p> <a href="https://www.codewars.com/users/siebenschlaefer" target="_blank" rel="noopener">siebenschlaefer</a></p><pre><code class="python">def wraps(wrapped):    def wrapper(func):        for attr in (&#39;__module__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;):            try:                value = getattr(wrapped, attr)            except AttributeError:                pass            else:                setattr(func, attr, value)        func.__dict__.update(getattr(wrapped, attr, {}))        func.__wrapped__ = wrapped        return func    return wrapper</code></pre><p>首先注意一下对应关系。经过一次二重的装饰后，<br><code>wrapped</code> ➡️ <code>return_one</code><br><code>func</code> ➡️ <code>wrapper</code></p><p>目标是输出 <code>func</code> ，但要把 <code>func</code> 的 <code>__name__</code> 和 <code>__doc__</code> 进行修改。修改这些 built-in 的值用到了 <code>getattr()</code> 和 <code>setattr()</code>。</p><blockquote><p>You use them if the attribute you want to access is a variable and not a literal string. They let you parameterize attribute access/setting.</p><p>There’s no reason to do <code>getattr(x, &#39;foobar&#39;)</code>, but you might have a variable called <code>attr</code> that could be set to “foobar” or “otherAttr”, and then do <code>getattr(x, attr)</code>.</p></blockquote><p><code>try</code>…<code>except</code>… <code>else</code>，<code>else</code> 后面是当 <code>try</code> 中的内容无错误时才执行的，否则时执行 <code>except</code> 中的内容。</p><blockquote><p><code>try</code>:   Normal execution block<br><code>except</code> A:<br>   Exception A handle<br><code>except</code> B:<br>   Exception B handle<br><code>except</code>:   Other exception handleelse:<br><code>else</code>:   if no exception,get here<br><code>finally</code>:   print(“finally”)   </p></blockquote><p> <a href="https://www.codewars.com/users/Voile" target="_blank" rel="noopener">Voile</a></p><pre><code class="python">def wraps(func):    def f(g):        g.__name__ = func.__name__        g.__doc__ = func.__doc__        return g    return f</code></pre><p>Voile 的解法更简洁。</p><p>参考文章：</p><ul><li><a href="https://stackoverflow.com/questions/19123707/why-use-setattr-and-getattr-built-ins" target="_blank" rel="noopener">Why use setattr() and getattr() built-ins?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decorator&lt;/code&gt; 装饰器用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;try&lt;/code&gt;…&lt;code&gt;except&lt;/code&gt;… &lt;code&gt;else&lt;/code&gt; control flow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getattr()&lt;/code&gt; 和 &lt;code&gt;setattr()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__dict__.update()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Details&quot;&gt;&lt;a href=&quot;#Details&quot; class=&quot;headerlink&quot; title=&quot;Details&quot;&gt;&lt;/a&gt;Details&lt;/h2&gt;&lt;p&gt;Implement the functools.wraps decorator, which is used to preserve the name and docstring of a decorated function. Your decorator must not modify the behavior of the decorated function. Here’s an example :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;def identity(func):
  @wraps(func)
  def wrapper(*args, **kwargs):
    &amp;quot;&amp;quot;&amp;quot;Wraps func&amp;quot;&amp;quot;&amp;quot;
    return func(*args, **kwargs)
  return wrapper

@identity
def return_one():
  &amp;quot;&amp;quot;&amp;quot;Return one&amp;quot;&amp;quot;&amp;quot;
  return 1

return_one.__name__ == &amp;#39;return_one&amp;#39; # If wraps hadn&amp;#39;t been used, __name__ would be equal to &amp;#39;wrapper&amp;#39;
return_one.__doc__ == &amp;#39;Return one&amp;#39; # If wraps hadn&amp;#39;t been used, __doc__ would be equal to &amp;#39;Wraps func&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note: of course, you may not use the functools module for this kata.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目要求，经过一次二重的装饰器，保留原来函数的 &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;。二重装饰器 decorator，就是用一个 decorator 去 decorate 另一个 decorator。该二重装饰器装饰后的函数， 输出的是一重装饰器装饰过的函数，但是 &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;  得到保留，及为原函数的值。&lt;/p&gt;
&lt;p&gt;依照题目给的例子，就是输出是被 decorator wraps 修饰过的 &lt;code&gt;wrapper&lt;/code&gt; 函数，即函数主体和功能还是 &lt;code&gt;wrapper&lt;/code&gt;，但因为被 &lt;code&gt;wraps&lt;/code&gt; 装饰了，输出的 &lt;code&gt;wrapper&lt;/code&gt; 函数的  &lt;code&gt;__name__&lt;/code&gt; 和 &lt;code&gt;__doc__&lt;/code&gt;  值为原函数 &lt;code&gt;return_one&lt;/code&gt; 的值。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding" scheme="http://reyshawn.com/categories/Coding/"/>
    
    
      <category term="Algorithm" scheme="http://reyshawn.com/tags/Algorithm/"/>
    
      <category term="codewars" scheme="http://reyshawn.com/tags/codewars/"/>
    
      <category term="JavaScript" scheme="http://reyshawn.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
